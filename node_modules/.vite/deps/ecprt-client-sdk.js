import "./chunk-JMHRHAEL.js";

// node_modules/ecprt-client-sdk/dist/ecprt-client-sdk.esm.mjs
function _mergeNamespaces(n, m) {
  m.forEach(function(e) {
    e && typeof e !== "string" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {
      if (k !== "default" && !(k in n)) {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function() {
            return e[k];
          }
        });
      }
    });
  });
  return Object.freeze(n);
}
function _arrayLikeToArray(r2, a) {
  (null == a || a > r2.length) && (a = r2.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r2[e];
  return n;
}
function _arrayWithHoles(r2) {
  if (Array.isArray(r2)) return r2;
}
function _arrayWithoutHoles(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray(r2);
}
function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _construct(t, e, r2) {
  if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
  var o = [null];
  o.push.apply(o, e);
  var p = new (t.bind.apply(t, o))();
  return r2 && _setPrototypeOf(p, r2.prototype), p;
}
function _defineProperties(e, r2) {
  for (var t = 0; t < r2.length; t++) {
    var o = r2[t];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
  }
}
function _createClass(e, r2, t) {
  return r2 && _defineProperties(e.prototype, r2), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: false
  }), e;
}
function _createForOfIteratorHelper(r2, e) {
  var t = "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (!t) {
    if (Array.isArray(r2) || (t = _unsupportedIterableToArray(r2)) || e) {
      t && (r2 = t);
      var n = 0, F = function() {
      };
      return {
        s: F,
        n: function() {
          return n >= r2.length ? {
            done: true
          } : {
            done: false,
            value: r2[n++]
          };
        },
        e: function(r3) {
          throw r3;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o, a = true, u = false;
  return {
    s: function() {
      t = t.call(r2);
    },
    n: function() {
      var r3 = t.next();
      return a = r3.done, r3;
    },
    e: function(r3) {
      u = true, o = r3;
    },
    f: function() {
      try {
        a || null == t.return || t.return();
      } finally {
        if (u) throw o;
      }
    }
  };
}
function _defineProperty(e, r2, t) {
  return (r2 = _toPropertyKey(r2)) in e ? Object.defineProperty(e, r2, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r2] = t, e;
}
function _get() {
  return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e, t, r2) {
    var p = _superPropBase(e, t);
    if (p) {
      var n = Object.getOwnPropertyDescriptor(p, t);
      return n.get ? n.get.call(arguments.length < 3 ? e : r2) : n.value;
    }
  }, _get.apply(null, arguments);
}
function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
    return t2.__proto__ || Object.getPrototypeOf(t2);
  }, _getPrototypeOf(t);
}
function _inherits(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: true,
      configurable: true
    }
  }), Object.defineProperty(t, "prototype", {
    writable: false
  }), e && _setPrototypeOf(t, e);
}
function _isNativeFunction(t) {
  try {
    return -1 !== Function.toString.call(t).indexOf("[native code]");
  } catch (n) {
    return "function" == typeof t;
  }
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct = function() {
    return !!t;
  })();
}
function _iterableToArray(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}
function _iterableToArrayLimit(r2, l) {
  var t = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t) {
    var e, n, i, u, a = [], f = true, o = false;
    try {
      if (i = (t = t.call(r2)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = false;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r3) {
      o = true, n = r3;
    } finally {
      try {
        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _possibleConstructorReturn(t, e) {
  if (e && ("object" == typeof e || "function" == typeof e)) return e;
  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t);
}
function _regenerator() {
  var e, t, r2 = "function" == typeof Symbol ? Symbol : {}, n = r2.iterator || "@@iterator", o = r2.toStringTag || "@@toStringTag";
  function i(r3, n2, o2, i2) {
    var c2 = n2 && n2.prototype instanceof Generator ? n2 : Generator, u2 = Object.create(c2.prototype);
    return _regeneratorDefine(u2, "_invoke", function(r4, n3, o3) {
      var i3, c3, u3, f2 = 0, p = o3 || [], y = false, G = {
        p: 0,
        n: 0,
        v: e,
        a: d,
        f: d.bind(e, 4),
        d: function(t2, r5) {
          return i3 = t2, c3 = 0, u3 = e, G.n = r5, a;
        }
      };
      function d(r5, n4) {
        for (c3 = r5, u3 = n4, t = 0; !y && f2 && !o4 && t < p.length; t++) {
          var o4, i4 = p[t], d2 = G.p, l = i4[2];
          r5 > 3 ? (o4 = l === n4) && (u3 = i4[(c3 = i4[4]) ? 5 : (c3 = 3, 3)], i4[4] = i4[5] = e) : i4[0] <= d2 && ((o4 = r5 < 2 && d2 < i4[1]) ? (c3 = 0, G.v = n4, G.n = i4[1]) : d2 < l && (o4 = r5 < 3 || i4[0] > n4 || n4 > l) && (i4[4] = r5, i4[5] = n4, G.n = l, c3 = 0));
        }
        if (o4 || r5 > 1) return a;
        throw y = true, n4;
      }
      return function(o4, p2, l) {
        if (f2 > 1) throw TypeError("Generator is already running");
        for (y && 1 === p2 && d(p2, l), c3 = p2, u3 = l; (t = c3 < 2 ? e : u3) || !y; ) {
          i3 || (c3 ? c3 < 3 ? (c3 > 1 && (G.n = -1), d(c3, u3)) : G.n = u3 : G.v = u3);
          try {
            if (f2 = 2, i3) {
              if (c3 || (o4 = "next"), t = i3[o4]) {
                if (!(t = t.call(i3, u3))) throw TypeError("iterator result is not an object");
                if (!t.done) return t;
                u3 = t.value, c3 < 2 && (c3 = 0);
              } else 1 === c3 && (t = i3.return) && t.call(i3), c3 < 2 && (u3 = TypeError("The iterator does not provide a '" + o4 + "' method"), c3 = 1);
              i3 = e;
            } else if ((t = (y = G.n < 0) ? u3 : r4.call(n3, G)) !== a) break;
          } catch (t2) {
            i3 = e, c3 = 1, u3 = t2;
          } finally {
            f2 = 1;
          }
        }
        return {
          value: t,
          done: y
        };
      };
    }(r3, o2, i2), true), u2;
  }
  var a = {};
  function Generator() {
  }
  function GeneratorFunction() {
  }
  function GeneratorFunctionPrototype() {
  }
  t = Object.getPrototypeOf;
  var c = [][n] ? t(t([][n]())) : (_regeneratorDefine(t = {}, n, function() {
    return this;
  }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c);
  function f(e2) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(e2, GeneratorFunctionPrototype) : (e2.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine(e2, o, "GeneratorFunction")), e2.prototype = Object.create(u), e2;
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine(u), _regeneratorDefine(u, o, "Generator"), _regeneratorDefine(u, n, function() {
    return this;
  }), _regeneratorDefine(u, "toString", function() {
    return "[object Generator]";
  }), (_regenerator = function() {
    return {
      w: i,
      m: f
    };
  })();
}
function _regeneratorDefine(e, r2, n, t) {
  var i = Object.defineProperty;
  try {
    i({}, "", {});
  } catch (e2) {
    i = 0;
  }
  _regeneratorDefine = function(e2, r3, n2, t2) {
    if (r3) i ? i(e2, r3, {
      value: n2,
      enumerable: !t2,
      configurable: !t2,
      writable: !t2
    }) : e2[r3] = n2;
    else {
      let o = function(r4, n3) {
        _regeneratorDefine(e2, r4, function(e3) {
          return this._invoke(r4, n3, e3);
        });
      };
      o("next", 0), o("throw", 1), o("return", 2);
    }
  }, _regeneratorDefine(e, r2, n, t);
}
function _regeneratorValues(e) {
  if (null != e) {
    var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r2 = 0;
    if (t) return t.call(e);
    if ("function" == typeof e.next) return e;
    if (!isNaN(e.length)) return {
      next: function() {
        return e && r2 >= e.length && (e = void 0), {
          value: e && e[r2++],
          done: !e
        };
      }
    };
  }
  throw new TypeError(typeof e + " is not iterable");
}
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
    return t2.__proto__ = e2, t2;
  }, _setPrototypeOf(t, e);
}
function _slicedToArray(r2, e) {
  return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e) || _unsupportedIterableToArray(r2, e) || _nonIterableRest();
}
function _superPropBase(t, o) {
  for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t)); ) ;
  return t;
}
function _superPropGet(t, o, e, r2) {
  var p = _get(_getPrototypeOf(1 & r2 ? t.prototype : t), o, e);
  return 2 & r2 && "function" == typeof p ? function(t2) {
    return p.apply(e, t2);
  } : p;
}
function _toConsumableArray(r2) {
  return _arrayWithoutHoles(r2) || _iterableToArray(r2) || _unsupportedIterableToArray(r2) || _nonIterableSpread();
}
function _toPrimitive(t, r2) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r2);
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t);
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}
function _unsupportedIterableToArray(r2, a) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray(r2, a);
    var t = {}.toString.call(r2).slice(8, -1);
    return "Object" === t && r2.constructor && (t = r2.constructor.name), "Map" === t || "Set" === t ? Array.from(r2) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r2, a) : void 0;
  }
}
function _wrapNativeSuper(t) {
  var r2 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
  return _wrapNativeSuper = function(t2) {
    if (null === t2 || !_isNativeFunction(t2)) return t2;
    if ("function" != typeof t2) throw new TypeError("Super expression must either be null or a function");
    if (void 0 !== r2) {
      if (r2.has(t2)) return r2.get(t2);
      r2.set(t2, Wrapper);
    }
    function Wrapper() {
      return _construct(t2, arguments, _getPrototypeOf(this).constructor);
    }
    return Wrapper.prototype = Object.create(t2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    }), _setPrototypeOf(Wrapper, t2);
  }, _wrapNativeSuper(t);
}
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg);
  }
}
var FLOAT32_MAX = 34028234663852886e22;
var FLOAT32_MIN = -34028234663852886e22;
var UINT32_MAX = 4294967295;
var INT32_MAX = 2147483647;
var INT32_MIN = -2147483648;
function assertInt32(arg) {
  if (typeof arg !== "number") throw new Error("invalid int 32: " + _typeof(arg));
  if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN) throw new Error("invalid int 32: " + arg);
}
function assertUInt32(arg) {
  if (typeof arg !== "number") throw new Error("invalid uint 32: " + _typeof(arg));
  if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0) throw new Error("invalid uint 32: " + arg);
}
function assertFloat32(arg) {
  if (typeof arg !== "number") throw new Error("invalid float 32: " + _typeof(arg));
  if (!Number.isFinite(arg)) return;
  if (arg > FLOAT32_MAX || arg < FLOAT32_MIN) throw new Error("invalid float 32: " + arg);
}
var enumTypeSymbol = Symbol("@bufbuild/protobuf/enum-type");
function getEnumType(enumObject) {
  var t = enumObject[enumTypeSymbol];
  assert(t, "missing enum type on enum object");
  return t;
}
function setEnumType(enumObject, typeName, values, opt) {
  enumObject[enumTypeSymbol] = makeEnumType(typeName, values.map(function(v) {
    return {
      no: v.no,
      name: v.name,
      localName: enumObject[v.no]
    };
  }));
}
function makeEnumType(typeName, values, _opt) {
  var names = /* @__PURE__ */ Object.create(null);
  var numbers = /* @__PURE__ */ Object.create(null);
  var normalValues = [];
  var _iterator = _createForOfIteratorHelper(values), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var value = _step.value;
      var n = normalizeEnumValue(value);
      normalValues.push(n);
      names[value.name] = n;
      numbers[value.no] = n;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return {
    typeName,
    values: normalValues,
    // We do not surface options at this time
    // options: opt?.options ?? Object.create(null),
    findName: function findName(name) {
      return names[name];
    },
    findNumber: function findNumber(no) {
      return numbers[no];
    }
  };
}
function makeEnum(typeName, values, opt) {
  var enumObject = {};
  var _iterator2 = _createForOfIteratorHelper(values), _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
      var value = _step2.value;
      var n = normalizeEnumValue(value);
      enumObject[n.localName] = n.no;
      enumObject[n.no] = n.localName;
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  setEnumType(enumObject, typeName, values);
  return enumObject;
}
function normalizeEnumValue(value) {
  if ("localName" in value) {
    return value;
  }
  return Object.assign(Object.assign({}, value), {
    localName: value.name
  });
}
var Message = function() {
  function Message2() {
    _classCallCheck(this, Message2);
  }
  return _createClass(Message2, [{
    key: "equals",
    value: (
      /**
       * Compare with a message of the same type.
       * Note that this function disregards extensions and unknown fields.
       */
      function equals(other) {
        return this.getType().runtime.util.equals(this.getType(), this, other);
      }
    )
    /**
     * Create a deep copy.
     */
  }, {
    key: "clone",
    value: function clone() {
      return this.getType().runtime.util.clone(this);
    }
    /**
     * Parse from binary data, merging fields.
     *
     * Repeated fields are appended. Map entries are added, overwriting
     * existing keys.
     *
     * If a message field is already present, it will be merged with the
     * new data.
     */
  }, {
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      var type = this.getType(), format16 = type.runtime.bin, opt = format16.makeReadOptions(options);
      format16.readMessage(this, opt.readerFactory(bytes), bytes.byteLength, opt);
      return this;
    }
    /**
     * Parse a message from a JSON value.
     */
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      var type = this.getType(), format16 = type.runtime.json, opt = format16.makeReadOptions(options);
      format16.readMessage(type, jsonValue, opt, this);
      return this;
    }
    /**
     * Parse a message from a JSON string.
     */
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      var json;
      try {
        json = JSON.parse(jsonString);
      } catch (e) {
        throw new Error("cannot decode ".concat(this.getType().typeName, " from JSON: ").concat(e instanceof Error ? e.message : String(e)));
      }
      return this.fromJson(json, options);
    }
    /**
     * Serialize the message to binary data.
     */
  }, {
    key: "toBinary",
    value: function toBinary(options) {
      var type = this.getType(), bin = type.runtime.bin, opt = bin.makeWriteOptions(options), writer3 = opt.writerFactory();
      bin.writeMessage(this, writer3, opt);
      return writer3.finish();
    }
    /**
     * Serialize the message to a JSON value, a JavaScript value that can be
     * passed to JSON.stringify().
     */
  }, {
    key: "toJson",
    value: function toJson(options) {
      var type = this.getType(), json = type.runtime.json, opt = json.makeWriteOptions(options);
      return json.writeMessage(this, opt);
    }
    /**
     * Serialize the message to a JSON string.
     */
  }, {
    key: "toJsonString",
    value: function toJsonString(options) {
      var _a;
      var value = this.toJson(options);
      return JSON.stringify(value, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);
    }
    /**
     * Override for serialization behavior. This will be invoked when calling
     * JSON.stringify on this message (i.e. JSON.stringify(msg)).
     *
     * Note that this will not serialize google.protobuf.Any with a packed
     * message because the protobuf JSON format specifies that it needs to be
     * unpacked, and this is only possible with a type registry to look up the
     * message type.  As a result, attempting to serialize a message with this
     * type will throw an Error.
     *
     * This method is protected because you should not need to invoke it
     * directly -- instead use JSON.stringify or toJsonString for
     * stringified JSON.  Alternatively, if actual JSON is desired, you should
     * use toJson.
     */
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.toJson({
        emitDefaultValues: true
      });
    }
    /**
     * Retrieve the MessageType of this message - a singleton that represents
     * the protobuf message declaration and provides metadata for reflection-
     * based operations.
     */
  }, {
    key: "getType",
    value: function getType() {
      return Object.getPrototypeOf(this).constructor;
    }
  }]);
}();
function makeMessageType(runtime, typeName, fields, opt) {
  var _a;
  var localName = (_a = opt === null || opt === void 0 ? void 0 : opt.localName) !== null && _a !== void 0 ? _a : typeName.substring(typeName.lastIndexOf(".") + 1);
  var type = _defineProperty({}, localName, function(data) {
    runtime.util.initFields(this);
    runtime.util.initPartial(data, this);
  })[localName];
  Object.setPrototypeOf(type.prototype, new Message());
  Object.assign(type, {
    runtime,
    typeName,
    fields: runtime.util.newFieldList(fields),
    fromBinary: function fromBinary(bytes, options) {
      return new type().fromBinary(bytes, options);
    },
    fromJson: function fromJson(jsonValue, options) {
      return new type().fromJson(jsonValue, options);
    },
    fromJsonString: function fromJsonString(jsonString, options) {
      return new type().fromJsonString(jsonString, options);
    },
    equals: function equals(a, b) {
      return runtime.util.equals(type, a, b);
    }
  });
  return type;
}
function varint64read() {
  var lowBits = 0;
  var highBits = 0;
  for (var shift = 0; shift < 28; shift += 7) {
    var b = this.buf[this.pos++];
    lowBits |= (b & 127) << shift;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  var middleByte = this.buf[this.pos++];
  lowBits |= (middleByte & 15) << 28;
  highBits = (middleByte & 112) >> 4;
  if ((middleByte & 128) == 0) {
    this.assertBounds();
    return [lowBits, highBits];
  }
  for (var _shift = 3; _shift <= 31; _shift += 7) {
    var _b = this.buf[this.pos++];
    highBits |= (_b & 127) << _shift;
    if ((_b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  throw new Error("invalid varint");
}
function varint64write(lo, hi, bytes) {
  for (var i = 0; i < 28; i = i + 7) {
    var shift = lo >>> i;
    var hasNext = !(shift >>> 7 == 0 && hi == 0);
    var _byte = (hasNext ? shift | 128 : shift) & 255;
    bytes.push(_byte);
    if (!hasNext) {
      return;
    }
  }
  var splitBits = lo >>> 28 & 15 | (hi & 7) << 4;
  var hasMoreBits = !(hi >> 3 == 0);
  bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
  if (!hasMoreBits) {
    return;
  }
  for (var _i = 3; _i < 31; _i = _i + 7) {
    var _shift2 = hi >>> _i;
    var _hasNext = !(_shift2 >>> 7 == 0);
    var _byte2 = (_hasNext ? _shift2 | 128 : _shift2) & 255;
    bytes.push(_byte2);
    if (!_hasNext) {
      return;
    }
  }
  bytes.push(hi >>> 31 & 1);
}
var TWO_PWR_32_DBL = 4294967296;
function int64FromString(dec2) {
  var minus = dec2[0] === "-";
  if (minus) {
    dec2 = dec2.slice(1);
  }
  var base = 1e6;
  var lowBits = 0;
  var highBits = 0;
  function add1e6digit(begin, end) {
    var digit1e6 = Number(dec2.slice(begin, end));
    highBits *= base;
    lowBits = lowBits * base + digit1e6;
    if (lowBits >= TWO_PWR_32_DBL) {
      highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);
      lowBits = lowBits % TWO_PWR_32_DBL;
    }
  }
  add1e6digit(-24, -18);
  add1e6digit(-18, -12);
  add1e6digit(-12, -6);
  add1e6digit(-6);
  return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);
}
function int64ToString(lo, hi) {
  var bits = newBits(lo, hi);
  var negative = bits.hi & 2147483648;
  if (negative) {
    bits = negate(bits.lo, bits.hi);
  }
  var result = uInt64ToString(bits.lo, bits.hi);
  return negative ? "-" + result : result;
}
function uInt64ToString(lo, hi) {
  var _toUnsigned = toUnsigned(lo, hi);
  lo = _toUnsigned.lo;
  hi = _toUnsigned.hi;
  if (hi <= 2097151) {
    return String(TWO_PWR_32_DBL * hi + lo);
  }
  var low = lo & 16777215;
  var mid = (lo >>> 24 | hi << 8) & 16777215;
  var high = hi >> 16 & 65535;
  var digitA = low + mid * 6777216 + high * 6710656;
  var digitB = mid + high * 8147497;
  var digitC = high * 2;
  var base = 1e7;
  if (digitA >= base) {
    digitB += Math.floor(digitA / base);
    digitA %= base;
  }
  if (digitB >= base) {
    digitC += Math.floor(digitB / base);
    digitB %= base;
  }
  return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);
}
function toUnsigned(lo, hi) {
  return {
    lo: lo >>> 0,
    hi: hi >>> 0
  };
}
function newBits(lo, hi) {
  return {
    lo: lo | 0,
    hi: hi | 0
  };
}
function negate(lowBits, highBits) {
  highBits = ~highBits;
  if (lowBits) {
    lowBits = ~lowBits + 1;
  } else {
    highBits += 1;
  }
  return newBits(lowBits, highBits);
}
var decimalFrom1e7WithLeadingZeros = function decimalFrom1e7WithLeadingZeros2(digit1e7) {
  var partial = String(digit1e7);
  return "0000000".slice(partial.length) + partial;
};
function varint32write(value, bytes) {
  if (value >= 0) {
    while (value > 127) {
      bytes.push(value & 127 | 128);
      value = value >>> 7;
    }
    bytes.push(value);
  } else {
    for (var i = 0; i < 9; i++) {
      bytes.push(value & 127 | 128);
      value = value >> 7;
    }
    bytes.push(1);
  }
}
function varint32read() {
  var b = this.buf[this.pos++];
  var result = b & 127;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 7;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 14;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 21;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 15) << 28;
  for (var readBytes = 5; (b & 128) !== 0 && readBytes < 10; readBytes++) b = this.buf[this.pos++];
  if ((b & 128) != 0) throw new Error("invalid varint");
  this.assertBounds();
  return result >>> 0;
}
function makeInt64Support() {
  var dv = new DataView(new ArrayBuffer(8));
  var ok = typeof BigInt === "function" && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function" && ((typeof process === "undefined" ? "undefined" : _typeof(process)) != "object" || _typeof(process.env) != "object" || process.env.BUF_BIGINT_DISABLE !== "1");
  if (ok) {
    var MIN = BigInt("-9223372036854775808"), MAX = BigInt("9223372036854775807"), UMIN = BigInt("0"), UMAX = BigInt("18446744073709551615");
    return {
      zero: BigInt(0),
      supported: true,
      parse: function parse2(value) {
        var bi = typeof value == "bigint" ? value : BigInt(value);
        if (bi > MAX || bi < MIN) {
          throw new Error("int64 invalid: ".concat(value));
        }
        return bi;
      },
      uParse: function uParse(value) {
        var bi = typeof value == "bigint" ? value : BigInt(value);
        if (bi > UMAX || bi < UMIN) {
          throw new Error("uint64 invalid: ".concat(value));
        }
        return bi;
      },
      enc: function enc2(value) {
        dv.setBigInt64(0, this.parse(value), true);
        return {
          lo: dv.getInt32(0, true),
          hi: dv.getInt32(4, true)
        };
      },
      uEnc: function uEnc(value) {
        dv.setBigInt64(0, this.uParse(value), true);
        return {
          lo: dv.getInt32(0, true),
          hi: dv.getInt32(4, true)
        };
      },
      dec: function dec2(lo, hi) {
        dv.setInt32(0, lo, true);
        dv.setInt32(4, hi, true);
        return dv.getBigInt64(0, true);
      },
      uDec: function uDec(lo, hi) {
        dv.setInt32(0, lo, true);
        dv.setInt32(4, hi, true);
        return dv.getBigUint64(0, true);
      }
    };
  }
  var assertInt64String = function assertInt64String2(value) {
    return assert(/^-?[0-9]+$/.test(value), "int64 invalid: ".concat(value));
  };
  var assertUInt64String = function assertUInt64String2(value) {
    return assert(/^[0-9]+$/.test(value), "uint64 invalid: ".concat(value));
  };
  return {
    zero: "0",
    supported: false,
    parse: function parse2(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertInt64String(value);
      return value;
    },
    uParse: function uParse(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertUInt64String(value);
      return value;
    },
    enc: function enc2(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertInt64String(value);
      return int64FromString(value);
    },
    uEnc: function uEnc(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertUInt64String(value);
      return int64FromString(value);
    },
    dec: function dec2(lo, hi) {
      return int64ToString(lo, hi);
    },
    uDec: function uDec(lo, hi) {
      return uInt64ToString(lo, hi);
    }
  };
}
var protoInt64 = makeInt64Support();
var ScalarType;
(function(ScalarType2) {
  ScalarType2[ScalarType2["DOUBLE"] = 1] = "DOUBLE";
  ScalarType2[ScalarType2["FLOAT"] = 2] = "FLOAT";
  ScalarType2[ScalarType2["INT64"] = 3] = "INT64";
  ScalarType2[ScalarType2["UINT64"] = 4] = "UINT64";
  ScalarType2[ScalarType2["INT32"] = 5] = "INT32";
  ScalarType2[ScalarType2["FIXED64"] = 6] = "FIXED64";
  ScalarType2[ScalarType2["FIXED32"] = 7] = "FIXED32";
  ScalarType2[ScalarType2["BOOL"] = 8] = "BOOL";
  ScalarType2[ScalarType2["STRING"] = 9] = "STRING";
  ScalarType2[ScalarType2["BYTES"] = 12] = "BYTES";
  ScalarType2[ScalarType2["UINT32"] = 13] = "UINT32";
  ScalarType2[ScalarType2["SFIXED32"] = 15] = "SFIXED32";
  ScalarType2[ScalarType2["SFIXED64"] = 16] = "SFIXED64";
  ScalarType2[ScalarType2["SINT32"] = 17] = "SINT32";
  ScalarType2[ScalarType2["SINT64"] = 18] = "SINT64";
})(ScalarType || (ScalarType = {}));
var LongType;
(function(LongType2) {
  LongType2[LongType2["BIGINT"] = 0] = "BIGINT";
  LongType2[LongType2["STRING"] = 1] = "STRING";
})(LongType || (LongType = {}));
function scalarEquals(type, a, b) {
  if (a === b) {
    return true;
  }
  if (type == ScalarType.BYTES) {
    if (!(a instanceof Uint8Array) || !(b instanceof Uint8Array)) {
      return false;
    }
    if (a.length !== b.length) {
      return false;
    }
    for (var i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  switch (type) {
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      return a == b;
  }
  return false;
}
function scalarZeroValue(type, longType) {
  switch (type) {
    case ScalarType.BOOL:
      return false;
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      return longType == 0 ? protoInt64.zero : "0";
    case ScalarType.DOUBLE:
    case ScalarType.FLOAT:
      return 0;
    case ScalarType.BYTES:
      return new Uint8Array(0);
    case ScalarType.STRING:
      return "";
    default:
      return 0;
  }
}
function isScalarZeroValue(type, value) {
  switch (type) {
    case ScalarType.BOOL:
      return value === false;
    case ScalarType.STRING:
      return value === "";
    case ScalarType.BYTES:
      return value instanceof Uint8Array && !value.byteLength;
    default:
      return value == 0;
  }
}
var WireType;
(function(WireType2) {
  WireType2[WireType2["Varint"] = 0] = "Varint";
  WireType2[WireType2["Bit64"] = 1] = "Bit64";
  WireType2[WireType2["LengthDelimited"] = 2] = "LengthDelimited";
  WireType2[WireType2["StartGroup"] = 3] = "StartGroup";
  WireType2[WireType2["EndGroup"] = 4] = "EndGroup";
  WireType2[WireType2["Bit32"] = 5] = "Bit32";
})(WireType || (WireType = {}));
var BinaryWriter = function() {
  function BinaryWriter2(textEncoder) {
    _classCallCheck(this, BinaryWriter2);
    this.stack = [];
    this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();
    this.chunks = [];
    this.buf = [];
  }
  return _createClass(BinaryWriter2, [{
    key: "finish",
    value: function finish() {
      this.chunks.push(new Uint8Array(this.buf));
      var len = 0;
      for (var i = 0; i < this.chunks.length; i++) len += this.chunks[i].length;
      var bytes = new Uint8Array(len);
      var offset = 0;
      for (var _i = 0; _i < this.chunks.length; _i++) {
        bytes.set(this.chunks[_i], offset);
        offset += this.chunks[_i].length;
      }
      this.chunks = [];
      return bytes;
    }
    /**
     * Start a new fork for length-delimited data like a message
     * or a packed repeated field.
     *
     * Must be joined later with `join()`.
     */
  }, {
    key: "fork",
    value: function fork() {
      this.stack.push({
        chunks: this.chunks,
        buf: this.buf
      });
      this.chunks = [];
      this.buf = [];
      return this;
    }
    /**
     * Join the last fork. Write its length and bytes, then
     * return to the previous state.
     */
  }, {
    key: "join",
    value: function join() {
      var chunk = this.finish();
      var prev = this.stack.pop();
      if (!prev) throw new Error("invalid state, fork stack empty");
      this.chunks = prev.chunks;
      this.buf = prev.buf;
      this.uint32(chunk.byteLength);
      return this.raw(chunk);
    }
    /**
     * Writes a tag (field number and wire type).
     *
     * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
     *
     * Generated code should compute the tag ahead of time and call `uint32()`.
     */
  }, {
    key: "tag",
    value: function tag(fieldNo, type) {
      return this.uint32((fieldNo << 3 | type) >>> 0);
    }
    /**
     * Write a chunk of raw bytes.
     */
  }, {
    key: "raw",
    value: function raw(chunk) {
      if (this.buf.length) {
        this.chunks.push(new Uint8Array(this.buf));
        this.buf = [];
      }
      this.chunks.push(chunk);
      return this;
    }
    /**
     * Write a `uint32` value, an unsigned 32 bit varint.
     */
  }, {
    key: "uint32",
    value: function uint32(value) {
      assertUInt32(value);
      while (value > 127) {
        this.buf.push(value & 127 | 128);
        value = value >>> 7;
      }
      this.buf.push(value);
      return this;
    }
    /**
     * Write a `int32` value, a signed 32 bit varint.
     */
  }, {
    key: "int32",
    value: function int32(value) {
      assertInt32(value);
      varint32write(value, this.buf);
      return this;
    }
    /**
     * Write a `bool` value, a variant.
     */
  }, {
    key: "bool",
    value: function bool(value) {
      this.buf.push(value ? 1 : 0);
      return this;
    }
    /**
     * Write a `bytes` value, length-delimited arbitrary data.
     */
  }, {
    key: "bytes",
    value: function bytes(value) {
      this.uint32(value.byteLength);
      return this.raw(value);
    }
    /**
     * Write a `string` value, length-delimited data converted to UTF-8 text.
     */
  }, {
    key: "string",
    value: function string(value) {
      var chunk = this.textEncoder.encode(value);
      this.uint32(chunk.byteLength);
      return this.raw(chunk);
    }
    /**
     * Write a `float` value, 32-bit floating point number.
     */
  }, {
    key: "float",
    value: function _float(value) {
      assertFloat32(value);
      var chunk = new Uint8Array(4);
      new DataView(chunk.buffer).setFloat32(0, value, true);
      return this.raw(chunk);
    }
    /**
     * Write a `double` value, a 64-bit floating point number.
     */
  }, {
    key: "double",
    value: function _double(value) {
      var chunk = new Uint8Array(8);
      new DataView(chunk.buffer).setFloat64(0, value, true);
      return this.raw(chunk);
    }
    /**
     * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
     */
  }, {
    key: "fixed32",
    value: function fixed32(value) {
      assertUInt32(value);
      var chunk = new Uint8Array(4);
      new DataView(chunk.buffer).setUint32(0, value, true);
      return this.raw(chunk);
    }
    /**
     * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
     */
  }, {
    key: "sfixed32",
    value: function sfixed32(value) {
      assertInt32(value);
      var chunk = new Uint8Array(4);
      new DataView(chunk.buffer).setInt32(0, value, true);
      return this.raw(chunk);
    }
    /**
     * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
     */
  }, {
    key: "sint32",
    value: function sint32(value) {
      assertInt32(value);
      value = (value << 1 ^ value >> 31) >>> 0;
      varint32write(value, this.buf);
      return this;
    }
    /**
     * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
     */
  }, {
    key: "sfixed64",
    value: function sfixed64(value) {
      var chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.enc(value);
      view.setInt32(0, tc.lo, true);
      view.setInt32(4, tc.hi, true);
      return this.raw(chunk);
    }
    /**
     * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
     */
  }, {
    key: "fixed64",
    value: function fixed64(value) {
      var chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.uEnc(value);
      view.setInt32(0, tc.lo, true);
      view.setInt32(4, tc.hi, true);
      return this.raw(chunk);
    }
    /**
     * Write a `int64` value, a signed 64-bit varint.
     */
  }, {
    key: "int64",
    value: function int64(value) {
      var tc = protoInt64.enc(value);
      varint64write(tc.lo, tc.hi, this.buf);
      return this;
    }
    /**
     * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
     */
  }, {
    key: "sint64",
    value: function sint64(value) {
      var tc = protoInt64.enc(value), sign = tc.hi >> 31, lo = tc.lo << 1 ^ sign, hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign;
      varint64write(lo, hi, this.buf);
      return this;
    }
    /**
     * Write a `uint64` value, an unsigned 64-bit varint.
     */
  }, {
    key: "uint64",
    value: function uint64(value) {
      var tc = protoInt64.uEnc(value);
      varint64write(tc.lo, tc.hi, this.buf);
      return this;
    }
  }]);
}();
var BinaryReader = function() {
  function BinaryReader2(buf, textDecoder) {
    _classCallCheck(this, BinaryReader2);
    this.varint64 = varint64read;
    this.uint32 = varint32read;
    this.buf = buf;
    this.len = buf.length;
    this.pos = 0;
    this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder();
  }
  return _createClass(BinaryReader2, [{
    key: "tag",
    value: function tag() {
      var tag2 = this.uint32(), fieldNo = tag2 >>> 3, wireType = tag2 & 7;
      if (fieldNo <= 0 || wireType < 0 || wireType > 5) throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
      return [fieldNo, wireType];
    }
    /**
     * Skip one element and return the skipped data.
     *
     * When skipping StartGroup, provide the tags field number to check for
     * matching field number in the EndGroup tag.
     */
  }, {
    key: "skip",
    value: function skip(wireType, fieldNo) {
      var start = this.pos;
      switch (wireType) {
        case WireType.Varint:
          while (this.buf[this.pos++] & 128) {
          }
          break;
        case WireType.Bit64:
          this.pos += 4;
        case WireType.Bit32:
          this.pos += 4;
          break;
        case WireType.LengthDelimited:
          var len = this.uint32();
          this.pos += len;
          break;
        case WireType.StartGroup:
          for (; ; ) {
            var _this$tag = this.tag(), _this$tag2 = _slicedToArray(_this$tag, 2), fn = _this$tag2[0], wt = _this$tag2[1];
            if (wt === WireType.EndGroup) {
              if (fieldNo !== void 0 && fn !== fieldNo) {
                throw new Error("invalid end group tag");
              }
              break;
            }
            this.skip(wt, fn);
          }
          break;
        default:
          throw new Error("cant skip wire type " + wireType);
      }
      this.assertBounds();
      return this.buf.subarray(start, this.pos);
    }
    /**
     * Throws error if position in byte array is out of range.
     */
  }, {
    key: "assertBounds",
    value: function assertBounds() {
      if (this.pos > this.len) throw new RangeError("premature EOF");
    }
    /**
     * Read a `int32` field, a signed 32 bit varint.
     */
  }, {
    key: "int32",
    value: function int32() {
      return this.uint32() | 0;
    }
    /**
     * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
     */
  }, {
    key: "sint32",
    value: function sint32() {
      var zze = this.uint32();
      return zze >>> 1 ^ -(zze & 1);
    }
    /**
     * Read a `int64` field, a signed 64-bit varint.
     */
  }, {
    key: "int64",
    value: function int64() {
      return protoInt64.dec.apply(protoInt64, _toConsumableArray(this.varint64()));
    }
    /**
     * Read a `uint64` field, an unsigned 64-bit varint.
     */
  }, {
    key: "uint64",
    value: function uint64() {
      return protoInt64.uDec.apply(protoInt64, _toConsumableArray(this.varint64()));
    }
    /**
     * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
     */
  }, {
    key: "sint64",
    value: function sint64() {
      var _this$varint = this.varint64(), _this$varint2 = _slicedToArray(_this$varint, 2), lo = _this$varint2[0], hi = _this$varint2[1];
      var s = -(lo & 1);
      lo = (lo >>> 1 | (hi & 1) << 31) ^ s;
      hi = hi >>> 1 ^ s;
      return protoInt64.dec(lo, hi);
    }
    /**
     * Read a `bool` field, a variant.
     */
  }, {
    key: "bool",
    value: function bool() {
      var _this$varint3 = this.varint64(), _this$varint4 = _slicedToArray(_this$varint3, 2), lo = _this$varint4[0], hi = _this$varint4[1];
      return lo !== 0 || hi !== 0;
    }
    /**
     * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
     */
  }, {
    key: "fixed32",
    value: function fixed32() {
      return this.view.getUint32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
     */
  }, {
    key: "sfixed32",
    value: function sfixed32() {
      return this.view.getInt32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
     */
  }, {
    key: "fixed64",
    value: function fixed64() {
      return protoInt64.uDec(this.sfixed32(), this.sfixed32());
    }
    /**
     * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
     */
  }, {
    key: "sfixed64",
    value: function sfixed64() {
      return protoInt64.dec(this.sfixed32(), this.sfixed32());
    }
    /**
     * Read a `float` field, 32-bit floating point number.
     */
  }, {
    key: "float",
    value: function _float2() {
      return this.view.getFloat32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `double` field, a 64-bit floating point number.
     */
  }, {
    key: "double",
    value: function _double2() {
      return this.view.getFloat64((this.pos += 8) - 8, true);
    }
    /**
     * Read a `bytes` field, length-delimited arbitrary data.
     */
  }, {
    key: "bytes",
    value: function bytes() {
      var len = this.uint32(), start = this.pos;
      this.pos += len;
      this.assertBounds();
      return this.buf.subarray(start, start + len);
    }
    /**
     * Read a `string` field, length-delimited data converted to UTF-8 text.
     */
  }, {
    key: "string",
    value: function string() {
      return this.textDecoder.decode(this.bytes());
    }
  }]);
}();
function makeExtension(runtime, typeName, extendee, field) {
  var fi;
  return {
    typeName,
    extendee,
    get field() {
      if (!fi) {
        var i = typeof field == "function" ? field() : field;
        i.name = typeName.split(".").pop();
        i.jsonName = "[".concat(typeName, "]");
        fi = runtime.util.newFieldList([i]).list()[0];
      }
      return fi;
    },
    runtime
  };
}
function createExtensionContainer(extension) {
  var localName = extension.field.localName;
  var container = /* @__PURE__ */ Object.create(null);
  container[localName] = initExtensionField(extension);
  return [container, function() {
    return container[localName];
  }];
}
function initExtensionField(ext) {
  var field = ext.field;
  if (field.repeated) {
    return [];
  }
  if (field["default"] !== void 0) {
    return field["default"];
  }
  switch (field.kind) {
    case "enum":
      return field.T.values[0].no;
    case "scalar":
      return scalarZeroValue(field.T, field.L);
    case "message":
      var T = field.T, value = new T();
      return T.fieldWrapper ? T.fieldWrapper.unwrapField(value) : value;
    case "map":
      throw "map fields are not allowed to be extensions";
  }
}
function filterUnknownFields(unknownFields, field) {
  if (!field.repeated && (field.kind == "enum" || field.kind == "scalar")) {
    for (var i = unknownFields.length - 1; i >= 0; --i) {
      if (unknownFields[i].no == field.no) {
        return [unknownFields[i]];
      }
    }
    return [];
  }
  return unknownFields.filter(function(uf) {
    return uf.no === field.no;
  });
}
var encTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
var decTable = [];
for (i = 0; i < encTable.length; i++) decTable[encTable[i].charCodeAt(0)] = i;
var i;
decTable["-".charCodeAt(0)] = encTable.indexOf("+");
decTable["_".charCodeAt(0)] = encTable.indexOf("/");
var protoBase64 = {
  /**
   * Decodes a base64 string to a byte array.
   *
   * - ignores white-space, including line breaks and tabs
   * - allows inner padding (can decode concatenated base64 strings)
   * - does not require padding
   * - understands base64url encoding:
   *   "-" instead of "+",
   *   "_" instead of "/",
   *   no padding
   */
  dec: function dec(base64Str) {
    var es = base64Str.length * 3 / 4;
    if (base64Str[base64Str.length - 2] == "=") es -= 2;
    else if (base64Str[base64Str.length - 1] == "=") es -= 1;
    var bytes = new Uint8Array(es), bytePos = 0, groupPos = 0, b, p = 0;
    for (var _i = 0; _i < base64Str.length; _i++) {
      b = decTable[base64Str.charCodeAt(_i)];
      if (b === void 0) {
        switch (base64Str[_i]) {
          case "=":
            groupPos = 0;
          case "\n":
          case "\r":
          case "	":
          case " ":
            continue;
          default:
            throw Error("invalid base64 string.");
        }
      }
      switch (groupPos) {
        case 0:
          p = b;
          groupPos = 1;
          break;
        case 1:
          bytes[bytePos++] = p << 2 | (b & 48) >> 4;
          p = b;
          groupPos = 2;
          break;
        case 2:
          bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;
          p = b;
          groupPos = 3;
          break;
        case 3:
          bytes[bytePos++] = (p & 3) << 6 | b;
          groupPos = 0;
          break;
      }
    }
    if (groupPos == 1) throw Error("invalid base64 string.");
    return bytes.subarray(0, bytePos);
  },
  /**
   * Encode a byte array to a base64 string.
   */
  enc: function enc(bytes) {
    var base64 = "", groupPos = 0, b, p = 0;
    for (var _i2 = 0; _i2 < bytes.length; _i2++) {
      b = bytes[_i2];
      switch (groupPos) {
        case 0:
          base64 += encTable[b >> 2];
          p = (b & 3) << 4;
          groupPos = 1;
          break;
        case 1:
          base64 += encTable[p | b >> 4];
          p = (b & 15) << 2;
          groupPos = 2;
          break;
        case 2:
          base64 += encTable[p | b >> 6];
          base64 += encTable[b & 63];
          groupPos = 0;
          break;
      }
    }
    if (groupPos) {
      base64 += encTable[p];
      base64 += "=";
      if (groupPos == 1) base64 += "=";
    }
    return base64;
  }
};
function getExtension(message, extension, options) {
  assertExtendee(extension, message);
  var opt = extension.runtime.bin.makeReadOptions(options);
  var ufs = filterUnknownFields(message.getType().runtime.bin.listUnknownFields(message), extension.field);
  var _createExtensionConta = createExtensionContainer(extension), _createExtensionConta2 = _slicedToArray(_createExtensionConta, 2), container = _createExtensionConta2[0], get2 = _createExtensionConta2[1];
  var _iterator = _createForOfIteratorHelper(ufs), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var uf = _step.value;
      extension.runtime.bin.readField(container, opt.readerFactory(uf.data), extension.field, uf.wireType, opt);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return get2();
}
function setExtension(message, extension, value, options) {
  assertExtendee(extension, message);
  var readOpt = extension.runtime.bin.makeReadOptions(options);
  var writeOpt = extension.runtime.bin.makeWriteOptions(options);
  if (hasExtension(message, extension)) {
    var ufs = message.getType().runtime.bin.listUnknownFields(message).filter(function(uf2) {
      return uf2.no != extension.field.no;
    });
    message.getType().runtime.bin.discardUnknownFields(message);
    var _iterator2 = _createForOfIteratorHelper(ufs), _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        var uf = _step2.value;
        message.getType().runtime.bin.onUnknownField(message, uf.no, uf.wireType, uf.data);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
  var writer3 = writeOpt.writerFactory();
  var f = extension.field;
  if (!f.opt && !f.repeated && (f.kind == "enum" || f.kind == "scalar")) {
    f = Object.assign(Object.assign({}, extension.field), {
      opt: true
    });
  }
  extension.runtime.bin.writeField(f, value, writer3, writeOpt);
  var reader = readOpt.readerFactory(writer3.finish());
  while (reader.pos < reader.len) {
    var _reader$tag = reader.tag(), _reader$tag2 = _slicedToArray(_reader$tag, 2), no = _reader$tag2[0], wireType = _reader$tag2[1];
    var data = reader.skip(wireType, no);
    message.getType().runtime.bin.onUnknownField(message, no, wireType, data);
  }
}
function hasExtension(message, extension) {
  var messageType = message.getType();
  return extension.extendee.typeName === messageType.typeName && !!messageType.runtime.bin.listUnknownFields(message).find(function(uf) {
    return uf.no == extension.field.no;
  });
}
function assertExtendee(extension, message) {
  assert(extension.extendee.typeName == message.getType().typeName, "extension ".concat(extension.typeName, " can only be applied to message ").concat(extension.extendee.typeName));
}
function isFieldSet(field, target) {
  var localName = field.localName;
  if (field.repeated) {
    return target[localName].length > 0;
  }
  if (field.oneof) {
    return target[field.oneof.localName]["case"] === localName;
  }
  switch (field.kind) {
    case "enum":
    case "scalar":
      if (field.opt || field.req) {
        return target[localName] !== void 0;
      }
      if (field.kind == "enum") {
        return target[localName] !== field.T.values[0].no;
      }
      return !isScalarZeroValue(field.T, target[localName]);
    case "message":
      return target[localName] !== void 0;
    case "map":
      return Object.keys(target[localName]).length > 0;
  }
}
function clearField(field, target) {
  var localName = field.localName;
  var implicitPresence = !field.opt && !field.req;
  if (field.repeated) {
    target[localName] = [];
  } else if (field.oneof) {
    target[field.oneof.localName] = {
      "case": void 0
    };
  } else {
    switch (field.kind) {
      case "map":
        target[localName] = {};
        break;
      case "enum":
        target[localName] = implicitPresence ? field.T.values[0].no : void 0;
        break;
      case "scalar":
        target[localName] = implicitPresence ? scalarZeroValue(field.T, field.L) : void 0;
        break;
      case "message":
        target[localName] = void 0;
        break;
    }
  }
}
function isMessage(arg, type) {
  if (arg === null || _typeof(arg) != "object") {
    return false;
  }
  if (!Object.getOwnPropertyNames(Message.prototype).every(function(m) {
    return m in arg && typeof arg[m] == "function";
  })) {
    return false;
  }
  var actualType = arg.getType();
  if (actualType === null || typeof actualType != "function" || !("typeName" in actualType) || typeof actualType.typeName != "string") {
    return false;
  }
  return type === void 0 ? true : actualType.typeName == type.typeName;
}
function wrapField(type, value) {
  if (isMessage(value) || !type.fieldWrapper) {
    return value;
  }
  return type.fieldWrapper.wrapField(value);
}
({
  "google.protobuf.DoubleValue": ScalarType.DOUBLE,
  "google.protobuf.FloatValue": ScalarType.FLOAT,
  "google.protobuf.Int64Value": ScalarType.INT64,
  "google.protobuf.UInt64Value": ScalarType.UINT64,
  "google.protobuf.Int32Value": ScalarType.INT32,
  "google.protobuf.UInt32Value": ScalarType.UINT32,
  "google.protobuf.BoolValue": ScalarType.BOOL,
  "google.protobuf.StringValue": ScalarType.STRING,
  "google.protobuf.BytesValue": ScalarType.BYTES
});
var jsonReadDefaults = {
  ignoreUnknownFields: false
};
var jsonWriteDefaults = {
  emitDefaultValues: false,
  enumAsInteger: false,
  useProtoFieldName: false,
  prettySpaces: 0
};
function makeReadOptions$1(options) {
  return options ? Object.assign(Object.assign({}, jsonReadDefaults), options) : jsonReadDefaults;
}
function makeWriteOptions$1(options) {
  return options ? Object.assign(Object.assign({}, jsonWriteDefaults), options) : jsonWriteDefaults;
}
var tokenNull = Symbol();
var tokenIgnoredUnknownEnum = Symbol();
function makeJsonFormat() {
  return {
    makeReadOptions: makeReadOptions$1,
    makeWriteOptions: makeWriteOptions$1,
    readMessage: function readMessage(type, json, options, message) {
      if (json == null || Array.isArray(json) || _typeof(json) != "object") {
        throw new Error("cannot decode message ".concat(type.typeName, " from JSON: ").concat(debugJsonValue(json)));
      }
      message = message !== null && message !== void 0 ? message : new type();
      var oneofSeen = /* @__PURE__ */ new Map();
      var registry = options.typeRegistry;
      for (var _i = 0, _Object$entries = Object.entries(json); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), jsonKey = _Object$entries$_i[0], jsonValue = _Object$entries$_i[1];
        var field = type.fields.findJsonName(jsonKey);
        if (field) {
          if (field.oneof) {
            if (jsonValue === null && field.kind == "scalar") {
              continue;
            }
            var seen = oneofSeen.get(field.oneof);
            if (seen !== void 0) {
              throw new Error("cannot decode message ".concat(type.typeName, ' from JSON: multiple keys for oneof "').concat(field.oneof.name, '" present: "').concat(seen, '", "').concat(jsonKey, '"'));
            }
            oneofSeen.set(field.oneof, jsonKey);
          }
          readField$1(message, jsonValue, field, options, type);
        } else {
          var found = false;
          if ((registry === null || registry === void 0 ? void 0 : registry.findExtension) && jsonKey.startsWith("[") && jsonKey.endsWith("]")) {
            var ext = registry.findExtension(jsonKey.substring(1, jsonKey.length - 1));
            if (ext && ext.extendee.typeName == type.typeName) {
              found = true;
              var _createExtensionConta = createExtensionContainer(ext), _createExtensionConta2 = _slicedToArray(_createExtensionConta, 2), container = _createExtensionConta2[0], get2 = _createExtensionConta2[1];
              readField$1(container, jsonValue, ext.field, options, ext);
              setExtension(message, ext, get2(), options);
            }
          }
          if (!found && !options.ignoreUnknownFields) {
            throw new Error("cannot decode message ".concat(type.typeName, ' from JSON: key "').concat(jsonKey, '" is unknown'));
          }
        }
      }
      return message;
    },
    writeMessage: function writeMessage(message, options) {
      var type = message.getType();
      var json = {};
      var field;
      try {
        var _iterator = _createForOfIteratorHelper(type.fields.byNumber()), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            field = _step.value;
            if (!isFieldSet(field, message)) {
              if (field.req) {
                throw "required field not set";
              }
              if (!options.emitDefaultValues) {
                continue;
              }
              if (!canEmitFieldDefaultValue(field)) {
                continue;
              }
            }
            var _value = field.oneof ? message[field.oneof.localName].value : message[field.localName];
            var _jsonValue = writeField(field, _value, options);
            if (_jsonValue !== void 0) {
              json[options.useProtoFieldName ? field.name : field.jsonName] = _jsonValue;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        var registry = options.typeRegistry;
        if (registry === null || registry === void 0 ? void 0 : registry.findExtensionFor) {
          var _iterator2 = _createForOfIteratorHelper(type.runtime.bin.listUnknownFields(message)), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var uf = _step2.value;
              var ext = registry.findExtensionFor(type.typeName, uf.no);
              if (ext && hasExtension(message, ext)) {
                var value = getExtension(message, ext, options);
                var jsonValue = writeField(ext.field, value, options);
                if (jsonValue !== void 0) {
                  json[ext.field.jsonName] = jsonValue;
                }
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
      } catch (e) {
        var m = field ? "cannot encode field ".concat(type.typeName, ".").concat(field.name, " to JSON") : "cannot encode message ".concat(type.typeName, " to JSON");
        var r2 = e instanceof Error ? e.message : String(e);
        throw new Error(m + (r2.length > 0 ? ": ".concat(r2) : ""));
      }
      return json;
    },
    readScalar: function readScalar2(type, json, longType) {
      return _readScalar(type, json, longType !== null && longType !== void 0 ? longType : LongType.BIGINT, true);
    },
    writeScalar: function writeScalar2(type, value, emitDefaultValues) {
      if (value === void 0) {
        return void 0;
      }
      if (emitDefaultValues || isScalarZeroValue(type, value)) {
        return _writeScalar(type, value);
      }
      return void 0;
    },
    debug: debugJsonValue
  };
}
function debugJsonValue(json) {
  if (json === null) {
    return "null";
  }
  switch (_typeof(json)) {
    case "object":
      return Array.isArray(json) ? "array" : "object";
    case "string":
      return json.length > 100 ? "string" : '"'.concat(json.split('"').join('\\"'), '"');
    default:
      return String(json);
  }
}
function readField$1(target, jsonValue, field, options, parentType) {
  var localName = field.localName;
  if (field.repeated) {
    assert(field.kind != "map");
    if (jsonValue === null) {
      return;
    }
    if (!Array.isArray(jsonValue)) {
      throw new Error("cannot decode field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: ").concat(debugJsonValue(jsonValue)));
    }
    var targetArray = target[localName];
    var _iterator3 = _createForOfIteratorHelper(jsonValue), _step3;
    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
        var jsonItem = _step3.value;
        if (jsonItem === null) {
          throw new Error("cannot decode field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: ").concat(debugJsonValue(jsonItem)));
        }
        switch (field.kind) {
          case "message":
            targetArray.push(field.T.fromJson(jsonItem, options));
            break;
          case "enum":
            var enumValue = readEnum(field.T, jsonItem, options.ignoreUnknownFields, true);
            if (enumValue !== tokenIgnoredUnknownEnum) {
              targetArray.push(enumValue);
            }
            break;
          case "scalar":
            try {
              targetArray.push(_readScalar(field.T, jsonItem, field.L, true));
            } catch (e) {
              var m = "cannot decode field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: ").concat(debugJsonValue(jsonItem));
              if (e instanceof Error && e.message.length > 0) {
                m += ": ".concat(e.message);
              }
              throw new Error(m);
            }
            break;
        }
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }
  } else if (field.kind == "map") {
    if (jsonValue === null) {
      return;
    }
    if (_typeof(jsonValue) != "object" || Array.isArray(jsonValue)) {
      throw new Error("cannot decode field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: ").concat(debugJsonValue(jsonValue)));
    }
    var targetMap = target[localName];
    for (var _i2 = 0, _Object$entries2 = Object.entries(jsonValue); _i2 < _Object$entries2.length; _i2++) {
      var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2), jsonMapKey = _Object$entries2$_i[0], jsonMapValue = _Object$entries2$_i[1];
      if (jsonMapValue === null) {
        throw new Error("cannot decode field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: map value null"));
      }
      var key = void 0;
      try {
        key = readMapKey(field.K, jsonMapKey);
      } catch (e) {
        var _m = "cannot decode map key for field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: ").concat(debugJsonValue(jsonValue));
        if (e instanceof Error && e.message.length > 0) {
          _m += ": ".concat(e.message);
        }
        throw new Error(_m);
      }
      switch (field.V.kind) {
        case "message":
          targetMap[key] = field.V.T.fromJson(jsonMapValue, options);
          break;
        case "enum":
          var _enumValue = readEnum(field.V.T, jsonMapValue, options.ignoreUnknownFields, true);
          if (_enumValue !== tokenIgnoredUnknownEnum) {
            targetMap[key] = _enumValue;
          }
          break;
        case "scalar":
          try {
            targetMap[key] = _readScalar(field.V.T, jsonMapValue, LongType.BIGINT, true);
          } catch (e) {
            var _m2 = "cannot decode map value for field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: ").concat(debugJsonValue(jsonValue));
            if (e instanceof Error && e.message.length > 0) {
              _m2 += ": ".concat(e.message);
            }
            throw new Error(_m2);
          }
          break;
      }
    }
  } else {
    if (field.oneof) {
      target = target[field.oneof.localName] = {
        "case": localName
      };
      localName = "value";
    }
    switch (field.kind) {
      case "message":
        var messageType = field.T;
        if (jsonValue === null && messageType.typeName != "google.protobuf.Value") {
          return;
        }
        var currentValue = target[localName];
        if (isMessage(currentValue)) {
          currentValue.fromJson(jsonValue, options);
        } else {
          target[localName] = currentValue = messageType.fromJson(jsonValue, options);
          if (messageType.fieldWrapper && !field.oneof) {
            target[localName] = messageType.fieldWrapper.unwrapField(currentValue);
          }
        }
        break;
      case "enum":
        var _enumValue2 = readEnum(field.T, jsonValue, options.ignoreUnknownFields, false);
        switch (_enumValue2) {
          case tokenNull:
            clearField(field, target);
            break;
          case tokenIgnoredUnknownEnum:
            break;
          default:
            target[localName] = _enumValue2;
            break;
        }
        break;
      case "scalar":
        try {
          var scalarValue = _readScalar(field.T, jsonValue, field.L, false);
          switch (scalarValue) {
            case tokenNull:
              clearField(field, target);
              break;
            default:
              target[localName] = scalarValue;
              break;
          }
        } catch (e) {
          var _m3 = "cannot decode field ".concat(parentType.typeName, ".").concat(field.name, " from JSON: ").concat(debugJsonValue(jsonValue));
          if (e instanceof Error && e.message.length > 0) {
            _m3 += ": ".concat(e.message);
          }
          throw new Error(_m3);
        }
        break;
    }
  }
}
function readMapKey(type, json) {
  if (type === ScalarType.BOOL) {
    switch (json) {
      case "true":
        json = true;
        break;
      case "false":
        json = false;
        break;
    }
  }
  return _readScalar(type, json, LongType.BIGINT, true).toString();
}
function _readScalar(type, json, longType, nullAsZeroValue) {
  if (json === null) {
    if (nullAsZeroValue) {
      return scalarZeroValue(type, longType);
    }
    return tokenNull;
  }
  switch (type) {
    case ScalarType.DOUBLE:
    case ScalarType.FLOAT:
      if (json === "NaN") return Number.NaN;
      if (json === "Infinity") return Number.POSITIVE_INFINITY;
      if (json === "-Infinity") return Number.NEGATIVE_INFINITY;
      if (json === "") {
        break;
      }
      if (typeof json == "string" && json.trim().length !== json.length) {
        break;
      }
      if (typeof json != "string" && typeof json != "number") {
        break;
      }
      var _float = Number(json);
      if (Number.isNaN(_float)) {
        break;
      }
      if (!Number.isFinite(_float)) {
        break;
      }
      if (type == ScalarType.FLOAT) assertFloat32(_float);
      return _float;
    case ScalarType.INT32:
    case ScalarType.FIXED32:
    case ScalarType.SFIXED32:
    case ScalarType.SINT32:
    case ScalarType.UINT32:
      var int32;
      if (typeof json == "number") int32 = json;
      else if (typeof json == "string" && json.length > 0) {
        if (json.trim().length === json.length) int32 = Number(json);
      }
      if (int32 === void 0) break;
      if (type == ScalarType.UINT32 || type == ScalarType.FIXED32) assertUInt32(int32);
      else assertInt32(int32);
      return int32;
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      if (typeof json != "number" && typeof json != "string") break;
      var _long = protoInt64.parse(json);
      return longType ? _long.toString() : _long;
    case ScalarType.FIXED64:
    case ScalarType.UINT64:
      if (typeof json != "number" && typeof json != "string") break;
      var uLong = protoInt64.uParse(json);
      return longType ? uLong.toString() : uLong;
    case ScalarType.BOOL:
      if (typeof json !== "boolean") break;
      return json;
    case ScalarType.STRING:
      if (typeof json !== "string") {
        break;
      }
      try {
        encodeURIComponent(json);
      } catch (e) {
        throw new Error("invalid UTF8");
      }
      return json;
    case ScalarType.BYTES:
      if (json === "") return new Uint8Array(0);
      if (typeof json !== "string") break;
      return protoBase64.dec(json);
  }
  throw new Error();
}
function readEnum(type, json, ignoreUnknownFields, nullAsZeroValue) {
  if (json === null) {
    if (type.typeName == "google.protobuf.NullValue") {
      return 0;
    }
    return nullAsZeroValue ? type.values[0].no : tokenNull;
  }
  switch (_typeof(json)) {
    case "number":
      if (Number.isInteger(json)) {
        return json;
      }
      break;
    case "string":
      var value = type.findName(json);
      if (value !== void 0) {
        return value.no;
      }
      if (ignoreUnknownFields) {
        return tokenIgnoredUnknownEnum;
      }
      break;
  }
  throw new Error("cannot decode enum ".concat(type.typeName, " from JSON: ").concat(debugJsonValue(json)));
}
function canEmitFieldDefaultValue(field) {
  if (field.repeated || field.kind == "map") {
    return true;
  }
  if (field.oneof) {
    return false;
  }
  if (field.kind == "message") {
    return false;
  }
  if (field.opt || field.req) {
    return false;
  }
  return true;
}
function writeField(field, value, options) {
  if (field.kind == "map") {
    assert(_typeof(value) == "object" && value != null);
    var jsonObj = {};
    var entries = Object.entries(value);
    switch (field.V.kind) {
      case "scalar":
        var _iterator4 = _createForOfIteratorHelper(entries), _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
            var _step4$value = _slicedToArray(_step4.value, 2), entryKey = _step4$value[0], entryValue = _step4$value[1];
            jsonObj[entryKey.toString()] = _writeScalar(field.V.T, entryValue);
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
        break;
      case "message":
        var _iterator5 = _createForOfIteratorHelper(entries), _step5;
        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
            var _step5$value = _slicedToArray(_step5.value, 2), _entryKey = _step5$value[0], _entryValue = _step5$value[1];
            jsonObj[_entryKey.toString()] = _entryValue.toJson(options);
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
        break;
      case "enum":
        var enumType = field.V.T;
        var _iterator6 = _createForOfIteratorHelper(entries), _step6;
        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
            var _step6$value = _slicedToArray(_step6.value, 2), _entryKey2 = _step6$value[0], _entryValue2 = _step6$value[1];
            jsonObj[_entryKey2.toString()] = writeEnum(enumType, _entryValue2, options.enumAsInteger);
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }
        break;
    }
    return options.emitDefaultValues || entries.length > 0 ? jsonObj : void 0;
  }
  if (field.repeated) {
    assert(Array.isArray(value));
    var jsonArr = [];
    switch (field.kind) {
      case "scalar":
        for (var i = 0; i < value.length; i++) {
          jsonArr.push(_writeScalar(field.T, value[i]));
        }
        break;
      case "enum":
        for (var _i3 = 0; _i3 < value.length; _i3++) {
          jsonArr.push(writeEnum(field.T, value[_i3], options.enumAsInteger));
        }
        break;
      case "message":
        for (var _i4 = 0; _i4 < value.length; _i4++) {
          jsonArr.push(value[_i4].toJson(options));
        }
        break;
    }
    return options.emitDefaultValues || jsonArr.length > 0 ? jsonArr : void 0;
  }
  switch (field.kind) {
    case "scalar":
      return _writeScalar(field.T, value);
    case "enum":
      return writeEnum(field.T, value, options.enumAsInteger);
    case "message":
      return wrapField(field.T, value).toJson(options);
  }
}
function writeEnum(type, value, enumAsInteger) {
  var _a;
  assert(typeof value == "number");
  if (type.typeName == "google.protobuf.NullValue") {
    return null;
  }
  if (enumAsInteger) {
    return value;
  }
  var val = type.findNumber(value);
  return (_a = val === null || val === void 0 ? void 0 : val.name) !== null && _a !== void 0 ? _a : value;
}
function _writeScalar(type, value) {
  switch (type) {
    case ScalarType.INT32:
    case ScalarType.SFIXED32:
    case ScalarType.SINT32:
    case ScalarType.FIXED32:
    case ScalarType.UINT32:
      assert(typeof value == "number");
      return value;
    case ScalarType.FLOAT:
    case ScalarType.DOUBLE:
      assert(typeof value == "number");
      if (Number.isNaN(value)) return "NaN";
      if (value === Number.POSITIVE_INFINITY) return "Infinity";
      if (value === Number.NEGATIVE_INFINITY) return "-Infinity";
      return value;
    case ScalarType.STRING:
      assert(typeof value == "string");
      return value;
    case ScalarType.BOOL:
      assert(typeof value == "boolean");
      return value;
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      assert(typeof value == "bigint" || typeof value == "string" || typeof value == "number");
      return value.toString();
    case ScalarType.BYTES:
      assert(value instanceof Uint8Array);
      return protoBase64.enc(value);
  }
}
var unknownFieldsSymbol = Symbol("@bufbuild/protobuf/unknown-fields");
var readDefaults = {
  readUnknownFields: true,
  readerFactory: function readerFactory(bytes) {
    return new BinaryReader(bytes);
  }
};
var writeDefaults = {
  writeUnknownFields: true,
  writerFactory: function writerFactory() {
    return new BinaryWriter();
  }
};
function makeReadOptions(options) {
  return options ? Object.assign(Object.assign({}, readDefaults), options) : readDefaults;
}
function makeWriteOptions(options) {
  return options ? Object.assign(Object.assign({}, writeDefaults), options) : writeDefaults;
}
function makeBinaryFormat() {
  return {
    makeReadOptions,
    makeWriteOptions,
    listUnknownFields: function listUnknownFields(message) {
      var _a;
      return (_a = message[unknownFieldsSymbol]) !== null && _a !== void 0 ? _a : [];
    },
    discardUnknownFields: function discardUnknownFields(message) {
      delete message[unknownFieldsSymbol];
    },
    writeUnknownFields: function writeUnknownFields(message, writer3) {
      var m = message;
      var c = m[unknownFieldsSymbol];
      if (c) {
        var _iterator = _createForOfIteratorHelper(c), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var f = _step.value;
            writer3.tag(f.no, f.wireType).raw(f.data);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    },
    onUnknownField: function onUnknownField(message, no, wireType, data) {
      var m = message;
      if (!Array.isArray(m[unknownFieldsSymbol])) {
        m[unknownFieldsSymbol] = [];
      }
      m[unknownFieldsSymbol].push({
        no,
        wireType,
        data
      });
    },
    readMessage: function readMessage(message, reader, lengthOrEndTagFieldNo, options, delimitedMessageEncoding) {
      var type = message.getType();
      var end = delimitedMessageEncoding ? reader.len : reader.pos + lengthOrEndTagFieldNo;
      var fieldNo, wireType;
      while (reader.pos < end) {
        var _reader$tag = reader.tag();
        var _reader$tag2 = _slicedToArray(_reader$tag, 2);
        fieldNo = _reader$tag2[0];
        wireType = _reader$tag2[1];
        if (delimitedMessageEncoding === true && wireType == WireType.EndGroup) {
          break;
        }
        var field = type.fields.find(fieldNo);
        if (!field) {
          var data = reader.skip(wireType, fieldNo);
          if (options.readUnknownFields) {
            this.onUnknownField(message, fieldNo, wireType, data);
          }
          continue;
        }
        readField(message, reader, field, wireType, options);
      }
      if (delimitedMessageEncoding && // eslint-disable-line @typescript-eslint/strict-boolean-expressions
      (wireType != WireType.EndGroup || fieldNo !== lengthOrEndTagFieldNo)) {
        throw new Error("invalid end group tag");
      }
    },
    readField,
    writeMessage: function writeMessage(message, writer3, options) {
      var type = message.getType();
      var _iterator2 = _createForOfIteratorHelper(type.fields.byNumber()), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var field = _step2.value;
          if (!isFieldSet(field, message)) {
            if (field.req) {
              throw new Error("cannot encode field ".concat(type.typeName, ".").concat(field.name, " to binary: required field not set"));
            }
            continue;
          }
          var value = field.oneof ? message[field.oneof.localName].value : message[field.localName];
          _writeField(field, value, writer3, options);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      if (options.writeUnknownFields) {
        this.writeUnknownFields(message, writer3);
      }
      return writer3;
    },
    writeField: function writeField2(field, value, writer3, options) {
      if (value === void 0) {
        return void 0;
      }
      _writeField(field, value, writer3, options);
    }
  };
}
function readField(target, reader, field, wireType, options) {
  var repeated = field.repeated, localName = field.localName;
  if (field.oneof) {
    target = target[field.oneof.localName];
    if (target["case"] != localName) {
      delete target.value;
    }
    target["case"] = localName;
    localName = "value";
  }
  switch (field.kind) {
    case "scalar":
    case "enum":
      var scalarType = field.kind == "enum" ? ScalarType.INT32 : field.T;
      var read = readScalar;
      if (field.kind == "scalar" && field.L > 0) {
        read = readScalarLTString;
      }
      if (repeated) {
        var arr = target[localName];
        var isPacked = wireType == WireType.LengthDelimited && scalarType != ScalarType.STRING && scalarType != ScalarType.BYTES;
        if (isPacked) {
          var e = reader.uint32() + reader.pos;
          while (reader.pos < e) {
            arr.push(read(reader, scalarType));
          }
        } else {
          arr.push(read(reader, scalarType));
        }
      } else {
        target[localName] = read(reader, scalarType);
      }
      break;
    case "message":
      var messageType = field.T;
      if (repeated) {
        target[localName].push(readMessageField(reader, new messageType(), options, field));
      } else {
        if (isMessage(target[localName])) {
          readMessageField(reader, target[localName], options, field);
        } else {
          target[localName] = readMessageField(reader, new messageType(), options, field);
          if (messageType.fieldWrapper && !field.oneof && !field.repeated) {
            target[localName] = messageType.fieldWrapper.unwrapField(target[localName]);
          }
        }
      }
      break;
    case "map":
      var _readMapEntry = readMapEntry(field, reader, options), _readMapEntry2 = _slicedToArray(_readMapEntry, 2), mapKey = _readMapEntry2[0], mapVal = _readMapEntry2[1];
      target[localName][mapKey] = mapVal;
      break;
  }
}
function readMessageField(reader, message, options, field) {
  var format16 = message.getType().runtime.bin;
  var delimited = field === null || field === void 0 ? void 0 : field.delimited;
  format16.readMessage(
    message,
    reader,
    delimited ? field.no : reader.uint32(),
    // eslint-disable-line @typescript-eslint/strict-boolean-expressions
    options,
    delimited
  );
  return message;
}
function readMapEntry(field, reader, options) {
  var length = reader.uint32(), end = reader.pos + length;
  var key, val;
  while (reader.pos < end) {
    var _reader$tag3 = reader.tag(), _reader$tag4 = _slicedToArray(_reader$tag3, 1), fieldNo = _reader$tag4[0];
    switch (fieldNo) {
      case 1:
        key = readScalar(reader, field.K);
        break;
      case 2:
        switch (field.V.kind) {
          case "scalar":
            val = readScalar(reader, field.V.T);
            break;
          case "enum":
            val = reader.int32();
            break;
          case "message":
            val = readMessageField(reader, new field.V.T(), options, void 0);
            break;
        }
        break;
    }
  }
  if (key === void 0) {
    key = scalarZeroValue(field.K, LongType.BIGINT);
  }
  if (typeof key != "string" && typeof key != "number") {
    key = key.toString();
  }
  if (val === void 0) {
    switch (field.V.kind) {
      case "scalar":
        val = scalarZeroValue(field.V.T, LongType.BIGINT);
        break;
      case "enum":
        val = field.V.T.values[0].no;
        break;
      case "message":
        val = new field.V.T();
        break;
    }
  }
  return [key, val];
}
function readScalarLTString(reader, type) {
  var v = readScalar(reader, type);
  return typeof v == "bigint" ? v.toString() : v;
}
function readScalar(reader, type) {
  switch (type) {
    case ScalarType.STRING:
      return reader.string();
    case ScalarType.BOOL:
      return reader.bool();
    case ScalarType.DOUBLE:
      return reader["double"]();
    case ScalarType.FLOAT:
      return reader["float"]();
    case ScalarType.INT32:
      return reader.int32();
    case ScalarType.INT64:
      return reader.int64();
    case ScalarType.UINT64:
      return reader.uint64();
    case ScalarType.FIXED64:
      return reader.fixed64();
    case ScalarType.BYTES:
      return reader.bytes();
    case ScalarType.FIXED32:
      return reader.fixed32();
    case ScalarType.SFIXED32:
      return reader.sfixed32();
    case ScalarType.SFIXED64:
      return reader.sfixed64();
    case ScalarType.SINT64:
      return reader.sint64();
    case ScalarType.UINT32:
      return reader.uint32();
    case ScalarType.SINT32:
      return reader.sint32();
  }
}
function _writeField(field, value, writer3, options) {
  assert(value !== void 0);
  var repeated = field.repeated;
  switch (field.kind) {
    case "scalar":
    case "enum":
      var scalarType = field.kind == "enum" ? ScalarType.INT32 : field.T;
      if (repeated) {
        assert(Array.isArray(value));
        if (field.packed) {
          writePacked(writer3, scalarType, field.no, value);
        } else {
          var _iterator3 = _createForOfIteratorHelper(value), _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
              var item = _step3.value;
              writeScalar(writer3, scalarType, field.no, item);
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        }
      } else {
        writeScalar(writer3, scalarType, field.no, value);
      }
      break;
    case "message":
      if (repeated) {
        assert(Array.isArray(value));
        var _iterator4 = _createForOfIteratorHelper(value), _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
            var _item = _step4.value;
            writeMessageField(writer3, options, field, _item);
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
      } else {
        writeMessageField(writer3, options, field, value);
      }
      break;
    case "map":
      assert(_typeof(value) == "object" && value != null);
      for (var _i = 0, _Object$entries = Object.entries(value); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), key = _Object$entries$_i[0], val = _Object$entries$_i[1];
        writeMapEntry(writer3, options, field, key, val);
      }
      break;
  }
}
function writeMapEntry(writer3, options, field, key, value) {
  writer3.tag(field.no, WireType.LengthDelimited);
  writer3.fork();
  var keyValue = key;
  switch (field.K) {
    case ScalarType.INT32:
    case ScalarType.FIXED32:
    case ScalarType.UINT32:
    case ScalarType.SFIXED32:
    case ScalarType.SINT32:
      keyValue = Number.parseInt(key);
      break;
    case ScalarType.BOOL:
      assert(key == "true" || key == "false");
      keyValue = key == "true";
      break;
  }
  writeScalar(writer3, field.K, 1, keyValue);
  switch (field.V.kind) {
    case "scalar":
      writeScalar(writer3, field.V.T, 2, value);
      break;
    case "enum":
      writeScalar(writer3, ScalarType.INT32, 2, value);
      break;
    case "message":
      assert(value !== void 0);
      writer3.tag(2, WireType.LengthDelimited).bytes(value.toBinary(options));
      break;
  }
  writer3.join();
}
function writeMessageField(writer3, options, field, value) {
  var message = wrapField(field.T, value);
  if (field.delimited) writer3.tag(field.no, WireType.StartGroup).raw(message.toBinary(options)).tag(field.no, WireType.EndGroup);
  else writer3.tag(field.no, WireType.LengthDelimited).bytes(message.toBinary(options));
}
function writeScalar(writer3, type, fieldNo, value) {
  assert(value !== void 0);
  var _scalarTypeInfo = scalarTypeInfo(type), _scalarTypeInfo2 = _slicedToArray(_scalarTypeInfo, 2), wireType = _scalarTypeInfo2[0], method = _scalarTypeInfo2[1];
  writer3.tag(fieldNo, wireType)[method](value);
}
function writePacked(writer3, type, fieldNo, value) {
  if (!value.length) {
    return;
  }
  writer3.tag(fieldNo, WireType.LengthDelimited).fork();
  var _scalarTypeInfo3 = scalarTypeInfo(type), _scalarTypeInfo4 = _slicedToArray(_scalarTypeInfo3, 2), method = _scalarTypeInfo4[1];
  for (var i = 0; i < value.length; i++) {
    writer3[method](value[i]);
  }
  writer3.join();
}
function scalarTypeInfo(type) {
  var wireType = WireType.Varint;
  switch (type) {
    case ScalarType.BYTES:
    case ScalarType.STRING:
      wireType = WireType.LengthDelimited;
      break;
    case ScalarType.DOUBLE:
    case ScalarType.FIXED64:
    case ScalarType.SFIXED64:
      wireType = WireType.Bit64;
      break;
    case ScalarType.FIXED32:
    case ScalarType.SFIXED32:
    case ScalarType.FLOAT:
      wireType = WireType.Bit32;
      break;
  }
  var method = ScalarType[type].toLowerCase();
  return [wireType, method];
}
function makeUtilCommon() {
  return {
    setEnumType,
    initPartial: function initPartial(source, target) {
      if (source === void 0) {
        return;
      }
      var type = target.getType();
      var _iterator = _createForOfIteratorHelper(type.fields.byMember()), _step;
      try {
        var _loop = function _loop2() {
          var member = _step.value;
          var localName = member.localName, t = target, s = source;
          if (s[localName] == null) {
            return 0;
          }
          switch (member.kind) {
            case "oneof":
              var sk = s[localName]["case"];
              if (sk === void 0) {
                return 0;
              }
              var sourceField = member.findField(sk);
              var val = s[localName].value;
              if (sourceField && sourceField.kind == "message" && !isMessage(val, sourceField.T)) {
                val = new sourceField.T(val);
              } else if (sourceField && sourceField.kind === "scalar" && sourceField.T === ScalarType.BYTES) {
                val = toU8Arr(val);
              }
              t[localName] = {
                "case": sk,
                value: val
              };
              break;
            case "scalar":
            case "enum":
              var copy = s[localName];
              if (member.T === ScalarType.BYTES) {
                copy = member.repeated ? copy.map(toU8Arr) : toU8Arr(copy);
              }
              t[localName] = copy;
              break;
            case "map":
              switch (member.V.kind) {
                case "scalar":
                case "enum":
                  if (member.V.T === ScalarType.BYTES) {
                    for (var _i = 0, _Object$entries = Object.entries(s[localName]); _i < _Object$entries.length; _i++) {
                      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), k = _Object$entries$_i[0], v = _Object$entries$_i[1];
                      t[localName][k] = toU8Arr(v);
                    }
                  } else {
                    Object.assign(t[localName], s[localName]);
                  }
                  break;
                case "message":
                  var messageType = member.V.T;
                  for (var _i2 = 0, _Object$keys = Object.keys(s[localName]); _i2 < _Object$keys.length; _i2++) {
                    var _k = _Object$keys[_i2];
                    var _val = s[localName][_k];
                    if (!messageType.fieldWrapper) {
                      _val = new messageType(_val);
                    }
                    t[localName][_k] = _val;
                  }
                  break;
              }
              break;
            case "message":
              var mt = member.T;
              if (member.repeated) {
                t[localName] = s[localName].map(function(val2) {
                  return isMessage(val2, mt) ? val2 : new mt(val2);
                });
              } else {
                var _val2 = s[localName];
                if (mt.fieldWrapper) {
                  if (
                    // We can't use BytesValue.typeName as that will create a circular import
                    mt.typeName === "google.protobuf.BytesValue"
                  ) {
                    t[localName] = toU8Arr(_val2);
                  } else {
                    t[localName] = _val2;
                  }
                } else {
                  t[localName] = isMessage(_val2, mt) ? _val2 : new mt(_val2);
                }
              }
              break;
          }
        }, _ret;
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          _ret = _loop();
          if (_ret === 0) continue;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    },
    // TODO use isFieldSet() here to support future field presence
    equals: function equals(type, a, b) {
      if (a === b) {
        return true;
      }
      if (!a || !b) {
        return false;
      }
      return type.fields.byMember().every(function(m) {
        var va = a[m.localName];
        var vb = b[m.localName];
        if (m.repeated) {
          if (va.length !== vb.length) {
            return false;
          }
          switch (m.kind) {
            case "message":
              return va.every(function(a2, i) {
                return m.T.equals(a2, vb[i]);
              });
            case "scalar":
              return va.every(function(a2, i) {
                return scalarEquals(m.T, a2, vb[i]);
              });
            case "enum":
              return va.every(function(a2, i) {
                return scalarEquals(ScalarType.INT32, a2, vb[i]);
              });
          }
          throw new Error("repeated cannot contain ".concat(m.kind));
        }
        switch (m.kind) {
          case "message":
            var _a = va;
            var _b = vb;
            if (m.T.fieldWrapper) {
              if (_a !== void 0 && !isMessage(_a)) {
                _a = m.T.fieldWrapper.wrapField(_a);
              }
              if (_b !== void 0 && !isMessage(_b)) {
                _b = m.T.fieldWrapper.wrapField(_b);
              }
            }
            return m.T.equals(_a, _b);
          case "enum":
            return scalarEquals(ScalarType.INT32, va, vb);
          case "scalar":
            return scalarEquals(m.T, va, vb);
          case "oneof":
            if (va["case"] !== vb["case"]) {
              return false;
            }
            var s = m.findField(va["case"]);
            if (s === void 0) {
              return true;
            }
            switch (s.kind) {
              case "message":
                return s.T.equals(va.value, vb.value);
              case "enum":
                return scalarEquals(ScalarType.INT32, va.value, vb.value);
              case "scalar":
                return scalarEquals(s.T, va.value, vb.value);
            }
            throw new Error("oneof cannot contain ".concat(s.kind));
          case "map":
            var keys = Object.keys(va).concat(Object.keys(vb));
            switch (m.V.kind) {
              case "message":
                var messageType = m.V.T;
                return keys.every(function(k) {
                  return messageType.equals(va[k], vb[k]);
                });
              case "enum":
                return keys.every(function(k) {
                  return scalarEquals(ScalarType.INT32, va[k], vb[k]);
                });
              case "scalar":
                var scalarType = m.V.T;
                return keys.every(function(k) {
                  return scalarEquals(scalarType, va[k], vb[k]);
                });
            }
            break;
        }
      });
    },
    // TODO use isFieldSet() here to support future field presence
    clone: function clone(message) {
      var type = message.getType(), target = new type(), any = target;
      var _iterator2 = _createForOfIteratorHelper(type.fields.byMember()), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var member = _step2.value;
          var source = message[member.localName];
          var copy = void 0;
          if (member.repeated) {
            copy = source.map(cloneSingularField);
          } else if (member.kind == "map") {
            copy = any[member.localName];
            for (var _i3 = 0, _Object$entries2 = Object.entries(source); _i3 < _Object$entries2.length; _i3++) {
              var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i3], 2), key = _Object$entries2$_i[0], v = _Object$entries2$_i[1];
              copy[key] = cloneSingularField(v);
            }
          } else if (member.kind == "oneof") {
            var f = member.findField(source["case"]);
            copy = f ? {
              "case": source["case"],
              value: cloneSingularField(source.value)
            } : {
              "case": void 0
            };
          } else {
            copy = cloneSingularField(source);
          }
          any[member.localName] = copy;
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      var _iterator3 = _createForOfIteratorHelper(type.runtime.bin.listUnknownFields(message)), _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
          var uf = _step3.value;
          type.runtime.bin.onUnknownField(any, uf.no, uf.wireType, uf.data);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      return target;
    }
  };
}
function cloneSingularField(value) {
  if (value === void 0) {
    return value;
  }
  if (isMessage(value)) {
    return value.clone();
  }
  if (value instanceof Uint8Array) {
    var c = new Uint8Array(value.byteLength);
    c.set(value);
    return c;
  }
  return value;
}
function toU8Arr(input) {
  return input instanceof Uint8Array ? input : new Uint8Array(input);
}
function makeProtoRuntime(syntax, newFieldList, initFields) {
  return {
    syntax,
    json: makeJsonFormat(),
    bin: makeBinaryFormat(),
    util: Object.assign(Object.assign({}, makeUtilCommon()), {
      newFieldList,
      initFields
    }),
    makeMessageType: function makeMessageType$1(typeName, fields, opt) {
      return makeMessageType(this, typeName, fields, opt);
    },
    makeEnum,
    makeEnumType,
    getEnumType,
    makeExtension: function makeExtension$1(typeName, extendee, field) {
      return makeExtension(this, typeName, extendee, field);
    }
  };
}
var InternalFieldList = function() {
  function InternalFieldList2(fields, normalizer) {
    _classCallCheck(this, InternalFieldList2);
    this._fields = fields;
    this._normalizer = normalizer;
  }
  return _createClass(InternalFieldList2, [{
    key: "findJsonName",
    value: function findJsonName(jsonName) {
      if (!this.jsonNames) {
        var t = {};
        var _iterator = _createForOfIteratorHelper(this.list()), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var f = _step.value;
            t[f.jsonName] = t[f.name] = f;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        this.jsonNames = t;
      }
      return this.jsonNames[jsonName];
    }
  }, {
    key: "find",
    value: function find(fieldNo) {
      if (!this.numbers) {
        var t = {};
        var _iterator2 = _createForOfIteratorHelper(this.list()), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var f = _step2.value;
            t[f.no] = f;
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        this.numbers = t;
      }
      return this.numbers[fieldNo];
    }
  }, {
    key: "list",
    value: function list() {
      if (!this.all) {
        this.all = this._normalizer(this._fields);
      }
      return this.all;
    }
  }, {
    key: "byNumber",
    value: function byNumber() {
      if (!this.numbersAsc) {
        this.numbersAsc = this.list().concat().sort(function(a, b) {
          return a.no - b.no;
        });
      }
      return this.numbersAsc;
    }
  }, {
    key: "byMember",
    value: function byMember() {
      if (!this.members) {
        this.members = [];
        var a = this.members;
        var o;
        var _iterator3 = _createForOfIteratorHelper(this.list()), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var f = _step3.value;
            if (f.oneof) {
              if (f.oneof !== o) {
                o = f.oneof;
                a.push(o);
              }
            } else {
              a.push(f);
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }
      return this.members;
    }
  }]);
}();
function localFieldName(protoName, inOneof) {
  var name = protoCamelCase(protoName);
  if (inOneof) {
    return name;
  }
  return safeObjectProperty(safeMessageProperty(name));
}
function localOneofName(protoName) {
  return localFieldName(protoName, false);
}
var fieldJsonName = protoCamelCase;
function protoCamelCase(snakeCase) {
  var capNext = false;
  var b = [];
  for (var i = 0; i < snakeCase.length; i++) {
    var c = snakeCase.charAt(i);
    switch (c) {
      case "_":
        capNext = true;
        break;
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        b.push(c);
        capNext = false;
        break;
      default:
        if (capNext) {
          capNext = false;
          c = c.toUpperCase();
        }
        b.push(c);
        break;
    }
  }
  return b.join("");
}
var reservedObjectProperties = /* @__PURE__ */ new Set([
  // names reserved by JavaScript
  "constructor",
  "toString",
  "toJSON",
  "valueOf"
]);
var reservedMessageProperties = /* @__PURE__ */ new Set([
  // names reserved by the runtime
  "getType",
  "clone",
  "equals",
  "fromBinary",
  "fromJson",
  "fromJsonString",
  "toBinary",
  "toJson",
  "toJsonString",
  // names reserved by the runtime for the future
  "toObject"
]);
var fallback = function fallback2(name) {
  return "".concat(name, "$");
};
var safeMessageProperty = function safeMessageProperty2(name) {
  if (reservedMessageProperties.has(name)) {
    return fallback(name);
  }
  return name;
};
var safeObjectProperty = function safeObjectProperty2(name) {
  if (reservedObjectProperties.has(name)) {
    return fallback(name);
  }
  return name;
};
var InternalOneofInfo = function() {
  function InternalOneofInfo2(name) {
    _classCallCheck(this, InternalOneofInfo2);
    this.kind = "oneof";
    this.repeated = false;
    this.packed = false;
    this.opt = false;
    this.req = false;
    this["default"] = void 0;
    this.fields = [];
    this.name = name;
    this.localName = localOneofName(name);
  }
  return _createClass(InternalOneofInfo2, [{
    key: "addField",
    value: function addField(field) {
      assert(field.oneof === this, "field ".concat(field.name, " not one of ").concat(this.name));
      this.fields.push(field);
    }
  }, {
    key: "findField",
    value: function findField(localName) {
      if (!this._lookup) {
        this._lookup = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < this.fields.length; i++) {
          this._lookup[this.fields[i].localName] = this.fields[i];
        }
      }
      return this._lookup[localName];
    }
  }]);
}();
function normalizeFieldInfos(fieldInfos, packedByDefault) {
  var _a, _b, _c, _d, _e, _f;
  var r2 = [];
  var o;
  var _iterator = _createForOfIteratorHelper(typeof fieldInfos == "function" ? fieldInfos() : fieldInfos), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var field = _step.value;
      var f = field;
      f.localName = localFieldName(field.name, field.oneof !== void 0);
      f.jsonName = (_a = field.jsonName) !== null && _a !== void 0 ? _a : fieldJsonName(field.name);
      f.repeated = (_b = field.repeated) !== null && _b !== void 0 ? _b : false;
      if (field.kind == "scalar") {
        f.L = (_c = field.L) !== null && _c !== void 0 ? _c : LongType.BIGINT;
      }
      f.delimited = (_d = field.delimited) !== null && _d !== void 0 ? _d : false;
      f.req = (_e = field.req) !== null && _e !== void 0 ? _e : false;
      f.opt = (_f = field.opt) !== null && _f !== void 0 ? _f : false;
      if (field.packed === void 0) {
        if (packedByDefault) {
          f.packed = field.kind == "enum" || field.kind == "scalar" && field.T != ScalarType.BYTES && field.T != ScalarType.STRING;
        }
      }
      if (field.oneof !== void 0) {
        var ooname = typeof field.oneof == "string" ? field.oneof : field.oneof.name;
        if (!o || o.name != ooname) {
          o = new InternalOneofInfo(ooname);
        }
        f.oneof = o;
        o.addField(f);
      }
      r2.push(f);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return r2;
}
var proto3 = makeProtoRuntime(
  "proto3",
  function(fields) {
    return new InternalFieldList(fields, function(source) {
      return normalizeFieldInfos(source, true);
    });
  },
  // TODO merge with proto2 and initExtensionField, also see initPartial, equals, clone
  function(target) {
    var _iterator = _createForOfIteratorHelper(target.getType().fields.byMember()), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var member = _step.value;
        if (member.opt) {
          continue;
        }
        var name = member.localName, t = target;
        if (member.repeated) {
          t[name] = [];
          continue;
        }
        switch (member.kind) {
          case "oneof":
            t[name] = {
              "case": void 0
            };
            break;
          case "enum":
            t[name] = 0;
            break;
          case "map":
            t[name] = {};
            break;
          case "scalar":
            t[name] = scalarZeroValue(member.T, member.L);
            break;
          case "message":
            break;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
);
var Timestamp = function(_Message) {
  function Timestamp2(data) {
    var _this;
    _classCallCheck(this, Timestamp2);
    _this = _callSuper(this, Timestamp2);
    _this.seconds = protoInt64.zero;
    _this.nanos = 0;
    proto3.util.initPartial(data, _this);
    return _this;
  }
  _inherits(Timestamp2, _Message);
  return _createClass(Timestamp2, [{
    key: "fromJson",
    value: function fromJson(json, options) {
      if (typeof json !== "string") {
        throw new Error("cannot decode google.protobuf.Timestamp from JSON: ".concat(proto3.json.debug(json)));
      }
      var matches = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
      if (!matches) {
        throw new Error("cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string");
      }
      var ms = Date.parse(matches[1] + "-" + matches[2] + "-" + matches[3] + "T" + matches[4] + ":" + matches[5] + ":" + matches[6] + (matches[8] ? matches[8] : "Z"));
      if (Number.isNaN(ms)) {
        throw new Error("cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string");
      }
      if (ms < Date.parse("0001-01-01T00:00:00Z") || ms > Date.parse("9999-12-31T23:59:59Z")) {
        throw new Error("cannot decode message google.protobuf.Timestamp from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive");
      }
      this.seconds = protoInt64.parse(ms / 1e3);
      this.nanos = 0;
      if (matches[7]) {
        this.nanos = parseInt("1" + matches[7] + "0".repeat(9 - matches[7].length)) - 1e9;
      }
      return this;
    }
  }, {
    key: "toJson",
    value: function toJson(options) {
      var ms = Number(this.seconds) * 1e3;
      if (ms < Date.parse("0001-01-01T00:00:00Z") || ms > Date.parse("9999-12-31T23:59:59Z")) {
        throw new Error("cannot encode google.protobuf.Timestamp to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive");
      }
      if (this.nanos < 0) {
        throw new Error("cannot encode google.protobuf.Timestamp to JSON: nanos must not be negative");
      }
      var z = "Z";
      if (this.nanos > 0) {
        var nanosStr = (this.nanos + 1e9).toString().substring(1);
        if (nanosStr.substring(3) === "000000") {
          z = "." + nanosStr.substring(0, 3) + "Z";
        } else if (nanosStr.substring(6) === "000") {
          z = "." + nanosStr.substring(0, 6) + "Z";
        } else {
          z = "." + nanosStr + "Z";
        }
      }
      return new Date(ms).toISOString().replace(".000Z", z);
    }
  }, {
    key: "toDate",
    value: function toDate() {
      return new Date(Number(this.seconds) * 1e3 + Math.ceil(this.nanos / 1e6));
    }
  }], [{
    key: "now",
    value: function now() {
      return Timestamp2.fromDate(/* @__PURE__ */ new Date());
    }
  }, {
    key: "fromDate",
    value: function fromDate(date) {
      var ms = date.getTime();
      return new Timestamp2({
        seconds: protoInt64.parse(Math.floor(ms / 1e3)),
        nanos: ms % 1e3 * 1e6
      });
    }
  }, {
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new Timestamp2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new Timestamp2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new Timestamp2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(Timestamp2, a, b);
    }
  }]);
}(Message);
Timestamp.runtime = proto3;
Timestamp.typeName = "google.protobuf.Timestamp";
Timestamp.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "seconds",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 2,
    name: "nanos",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }];
});
var MetricsBatch = proto3.makeMessageType("livekit.MetricsBatch", function() {
  return [{
    no: 1,
    name: "timestamp_ms",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 2,
    name: "normalized_timestamp",
    kind: "message",
    T: Timestamp
  }, {
    no: 3,
    name: "str_data",
    kind: "scalar",
    T: 9,
    repeated: true
  }, {
    no: 4,
    name: "time_series",
    kind: "message",
    T: TimeSeriesMetric,
    repeated: true
  }, {
    no: 5,
    name: "events",
    kind: "message",
    T: EventMetric,
    repeated: true
  }];
});
var TimeSeriesMetric = proto3.makeMessageType("livekit.TimeSeriesMetric", function() {
  return [{
    no: 1,
    name: "label",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 2,
    name: "participant_identity",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 3,
    name: "track_sid",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 4,
    name: "samples",
    kind: "message",
    T: MetricSample,
    repeated: true
  }, {
    no: 5,
    name: "rid",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }];
});
var MetricSample = proto3.makeMessageType("livekit.MetricSample", function() {
  return [{
    no: 1,
    name: "timestamp_ms",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 2,
    name: "normalized_timestamp",
    kind: "message",
    T: Timestamp
  }, {
    no: 3,
    name: "value",
    kind: "scalar",
    T: 2
    /* ScalarType.FLOAT */
  }];
});
var EventMetric = proto3.makeMessageType("livekit.EventMetric", function() {
  return [{
    no: 1,
    name: "label",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 2,
    name: "participant_identity",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 3,
    name: "track_sid",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 4,
    name: "start_timestamp_ms",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 5,
    name: "end_timestamp_ms",
    kind: "scalar",
    T: 3,
    opt: true
  }, {
    no: 6,
    name: "normalized_start_timestamp",
    kind: "message",
    T: Timestamp
  }, {
    no: 7,
    name: "normalized_end_timestamp",
    kind: "message",
    T: Timestamp,
    opt: true
  }, {
    no: 8,
    name: "metadata",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 9,
    name: "rid",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }];
});
var AudioCodec;
(function(AudioCodec2) {
  AudioCodec2[AudioCodec2["DEFAULT_AC"] = 0] = "DEFAULT_AC";
  AudioCodec2[AudioCodec2["OPUS"] = 1] = "OPUS";
  AudioCodec2[AudioCodec2["AAC"] = 2] = "AAC";
})(AudioCodec || (AudioCodec = {}));
proto3.util.setEnumType(AudioCodec, "livekit.AudioCodec", [{
  no: 0,
  name: "DEFAULT_AC"
}, {
  no: 1,
  name: "OPUS"
}, {
  no: 2,
  name: "AAC"
}]);
var VideoCodec;
(function(VideoCodec2) {
  VideoCodec2[VideoCodec2["DEFAULT_VC"] = 0] = "DEFAULT_VC";
  VideoCodec2[VideoCodec2["H264_BASELINE"] = 1] = "H264_BASELINE";
  VideoCodec2[VideoCodec2["H264_MAIN"] = 2] = "H264_MAIN";
  VideoCodec2[VideoCodec2["H264_HIGH"] = 3] = "H264_HIGH";
  VideoCodec2[VideoCodec2["VP8"] = 4] = "VP8";
})(VideoCodec || (VideoCodec = {}));
proto3.util.setEnumType(VideoCodec, "livekit.VideoCodec", [{
  no: 0,
  name: "DEFAULT_VC"
}, {
  no: 1,
  name: "H264_BASELINE"
}, {
  no: 2,
  name: "H264_MAIN"
}, {
  no: 3,
  name: "H264_HIGH"
}, {
  no: 4,
  name: "VP8"
}]);
var ImageCodec;
(function(ImageCodec2) {
  ImageCodec2[ImageCodec2["IC_DEFAULT"] = 0] = "IC_DEFAULT";
  ImageCodec2[ImageCodec2["IC_JPEG"] = 1] = "IC_JPEG";
})(ImageCodec || (ImageCodec = {}));
proto3.util.setEnumType(ImageCodec, "livekit.ImageCodec", [{
  no: 0,
  name: "IC_DEFAULT"
}, {
  no: 1,
  name: "IC_JPEG"
}]);
var TrackType;
(function(TrackType2) {
  TrackType2[TrackType2["AUDIO"] = 0] = "AUDIO";
  TrackType2[TrackType2["VIDEO"] = 1] = "VIDEO";
  TrackType2[TrackType2["DATA"] = 2] = "DATA";
})(TrackType || (TrackType = {}));
proto3.util.setEnumType(TrackType, "livekit.TrackType", [{
  no: 0,
  name: "AUDIO"
}, {
  no: 1,
  name: "VIDEO"
}, {
  no: 2,
  name: "DATA"
}]);
var TrackSource;
(function(TrackSource2) {
  TrackSource2[TrackSource2["UNKNOWN"] = 0] = "UNKNOWN";
  TrackSource2[TrackSource2["CAMERA"] = 1] = "CAMERA";
  TrackSource2[TrackSource2["MICROPHONE"] = 2] = "MICROPHONE";
  TrackSource2[TrackSource2["SCREEN_SHARE"] = 3] = "SCREEN_SHARE";
  TrackSource2[TrackSource2["SCREEN_SHARE_AUDIO"] = 4] = "SCREEN_SHARE_AUDIO";
})(TrackSource || (TrackSource = {}));
proto3.util.setEnumType(TrackSource, "livekit.TrackSource", [{
  no: 0,
  name: "UNKNOWN"
}, {
  no: 1,
  name: "CAMERA"
}, {
  no: 2,
  name: "MICROPHONE"
}, {
  no: 3,
  name: "SCREEN_SHARE"
}, {
  no: 4,
  name: "SCREEN_SHARE_AUDIO"
}]);
var VideoQuality$1;
(function(VideoQuality2) {
  VideoQuality2[VideoQuality2["LOW"] = 0] = "LOW";
  VideoQuality2[VideoQuality2["MEDIUM"] = 1] = "MEDIUM";
  VideoQuality2[VideoQuality2["HIGH"] = 2] = "HIGH";
  VideoQuality2[VideoQuality2["OFF"] = 3] = "OFF";
})(VideoQuality$1 || (VideoQuality$1 = {}));
proto3.util.setEnumType(VideoQuality$1, "livekit.VideoQuality", [{
  no: 0,
  name: "LOW"
}, {
  no: 1,
  name: "MEDIUM"
}, {
  no: 2,
  name: "HIGH"
}, {
  no: 3,
  name: "OFF"
}]);
var ConnectionQuality$1;
(function(ConnectionQuality2) {
  ConnectionQuality2[ConnectionQuality2["POOR"] = 0] = "POOR";
  ConnectionQuality2[ConnectionQuality2["GOOD"] = 1] = "GOOD";
  ConnectionQuality2[ConnectionQuality2["EXCELLENT"] = 2] = "EXCELLENT";
  ConnectionQuality2[ConnectionQuality2["LOST"] = 3] = "LOST";
})(ConnectionQuality$1 || (ConnectionQuality$1 = {}));
proto3.util.setEnumType(ConnectionQuality$1, "livekit.ConnectionQuality", [{
  no: 0,
  name: "POOR"
}, {
  no: 1,
  name: "GOOD"
}, {
  no: 2,
  name: "EXCELLENT"
}, {
  no: 3,
  name: "LOST"
}]);
var ClientConfigSetting;
(function(ClientConfigSetting2) {
  ClientConfigSetting2[ClientConfigSetting2["UNSET"] = 0] = "UNSET";
  ClientConfigSetting2[ClientConfigSetting2["DISABLED"] = 1] = "DISABLED";
  ClientConfigSetting2[ClientConfigSetting2["ENABLED"] = 2] = "ENABLED";
})(ClientConfigSetting || (ClientConfigSetting = {}));
proto3.util.setEnumType(ClientConfigSetting, "livekit.ClientConfigSetting", [{
  no: 0,
  name: "UNSET"
}, {
  no: 1,
  name: "DISABLED"
}, {
  no: 2,
  name: "ENABLED"
}]);
var DisconnectReason;
(function(DisconnectReason2) {
  DisconnectReason2[DisconnectReason2["UNKNOWN_REASON"] = 0] = "UNKNOWN_REASON";
  DisconnectReason2[DisconnectReason2["CLIENT_INITIATED"] = 1] = "CLIENT_INITIATED";
  DisconnectReason2[DisconnectReason2["DUPLICATE_IDENTITY"] = 2] = "DUPLICATE_IDENTITY";
  DisconnectReason2[DisconnectReason2["SERVER_SHUTDOWN"] = 3] = "SERVER_SHUTDOWN";
  DisconnectReason2[DisconnectReason2["PARTICIPANT_REMOVED"] = 4] = "PARTICIPANT_REMOVED";
  DisconnectReason2[DisconnectReason2["ROOM_DELETED"] = 5] = "ROOM_DELETED";
  DisconnectReason2[DisconnectReason2["STATE_MISMATCH"] = 6] = "STATE_MISMATCH";
  DisconnectReason2[DisconnectReason2["JOIN_FAILURE"] = 7] = "JOIN_FAILURE";
  DisconnectReason2[DisconnectReason2["MIGRATION"] = 8] = "MIGRATION";
  DisconnectReason2[DisconnectReason2["SIGNAL_CLOSE"] = 9] = "SIGNAL_CLOSE";
  DisconnectReason2[DisconnectReason2["ROOM_CLOSED"] = 10] = "ROOM_CLOSED";
  DisconnectReason2[DisconnectReason2["USER_UNAVAILABLE"] = 11] = "USER_UNAVAILABLE";
  DisconnectReason2[DisconnectReason2["USER_REJECTED"] = 12] = "USER_REJECTED";
  DisconnectReason2[DisconnectReason2["SIP_TRUNK_FAILURE"] = 13] = "SIP_TRUNK_FAILURE";
})(DisconnectReason || (DisconnectReason = {}));
proto3.util.setEnumType(DisconnectReason, "livekit.DisconnectReason", [{
  no: 0,
  name: "UNKNOWN_REASON"
}, {
  no: 1,
  name: "CLIENT_INITIATED"
}, {
  no: 2,
  name: "DUPLICATE_IDENTITY"
}, {
  no: 3,
  name: "SERVER_SHUTDOWN"
}, {
  no: 4,
  name: "PARTICIPANT_REMOVED"
}, {
  no: 5,
  name: "ROOM_DELETED"
}, {
  no: 6,
  name: "STATE_MISMATCH"
}, {
  no: 7,
  name: "JOIN_FAILURE"
}, {
  no: 8,
  name: "MIGRATION"
}, {
  no: 9,
  name: "SIGNAL_CLOSE"
}, {
  no: 10,
  name: "ROOM_CLOSED"
}, {
  no: 11,
  name: "USER_UNAVAILABLE"
}, {
  no: 12,
  name: "USER_REJECTED"
}, {
  no: 13,
  name: "SIP_TRUNK_FAILURE"
}]);
var ReconnectReason;
(function(ReconnectReason2) {
  ReconnectReason2[ReconnectReason2["RR_UNKNOWN"] = 0] = "RR_UNKNOWN";
  ReconnectReason2[ReconnectReason2["RR_SIGNAL_DISCONNECTED"] = 1] = "RR_SIGNAL_DISCONNECTED";
  ReconnectReason2[ReconnectReason2["RR_PUBLISHER_FAILED"] = 2] = "RR_PUBLISHER_FAILED";
  ReconnectReason2[ReconnectReason2["RR_SUBSCRIBER_FAILED"] = 3] = "RR_SUBSCRIBER_FAILED";
  ReconnectReason2[ReconnectReason2["RR_SWITCH_CANDIDATE"] = 4] = "RR_SWITCH_CANDIDATE";
})(ReconnectReason || (ReconnectReason = {}));
proto3.util.setEnumType(ReconnectReason, "livekit.ReconnectReason", [{
  no: 0,
  name: "RR_UNKNOWN"
}, {
  no: 1,
  name: "RR_SIGNAL_DISCONNECTED"
}, {
  no: 2,
  name: "RR_PUBLISHER_FAILED"
}, {
  no: 3,
  name: "RR_SUBSCRIBER_FAILED"
}, {
  no: 4,
  name: "RR_SWITCH_CANDIDATE"
}]);
var SubscriptionError;
(function(SubscriptionError2) {
  SubscriptionError2[SubscriptionError2["SE_UNKNOWN"] = 0] = "SE_UNKNOWN";
  SubscriptionError2[SubscriptionError2["SE_CODEC_UNSUPPORTED"] = 1] = "SE_CODEC_UNSUPPORTED";
  SubscriptionError2[SubscriptionError2["SE_TRACK_NOTFOUND"] = 2] = "SE_TRACK_NOTFOUND";
})(SubscriptionError || (SubscriptionError = {}));
proto3.util.setEnumType(SubscriptionError, "livekit.SubscriptionError", [{
  no: 0,
  name: "SE_UNKNOWN"
}, {
  no: 1,
  name: "SE_CODEC_UNSUPPORTED"
}, {
  no: 2,
  name: "SE_TRACK_NOTFOUND"
}]);
var AudioTrackFeature;
(function(AudioTrackFeature2) {
  AudioTrackFeature2[AudioTrackFeature2["TF_STEREO"] = 0] = "TF_STEREO";
  AudioTrackFeature2[AudioTrackFeature2["TF_NO_DTX"] = 1] = "TF_NO_DTX";
  AudioTrackFeature2[AudioTrackFeature2["TF_AUTO_GAIN_CONTROL"] = 2] = "TF_AUTO_GAIN_CONTROL";
  AudioTrackFeature2[AudioTrackFeature2["TF_ECHO_CANCELLATION"] = 3] = "TF_ECHO_CANCELLATION";
  AudioTrackFeature2[AudioTrackFeature2["TF_NOISE_SUPPRESSION"] = 4] = "TF_NOISE_SUPPRESSION";
  AudioTrackFeature2[AudioTrackFeature2["TF_ENHANCED_NOISE_CANCELLATION"] = 5] = "TF_ENHANCED_NOISE_CANCELLATION";
})(AudioTrackFeature || (AudioTrackFeature = {}));
proto3.util.setEnumType(AudioTrackFeature, "livekit.AudioTrackFeature", [{
  no: 0,
  name: "TF_STEREO"
}, {
  no: 1,
  name: "TF_NO_DTX"
}, {
  no: 2,
  name: "TF_AUTO_GAIN_CONTROL"
}, {
  no: 3,
  name: "TF_ECHO_CANCELLATION"
}, {
  no: 4,
  name: "TF_NOISE_SUPPRESSION"
}, {
  no: 5,
  name: "TF_ENHANCED_NOISE_CANCELLATION"
}]);
var Room$1 = function(_Message) {
  function Room2(data) {
    var _this;
    _classCallCheck(this, Room2);
    _this = _callSuper(this, Room2);
    _this.sid = "";
    _this.name = "";
    _this.emptyTimeout = 0;
    _this.departureTimeout = 0;
    _this.maxParticipants = 0;
    _this.creationTime = protoInt64.zero;
    _this.turnPassword = "";
    _this.enabledCodecs = [];
    _this.metadata = "";
    _this.numParticipants = 0;
    _this.numPublishers = 0;
    _this.activeRecording = false;
    proto3.util.initPartial(data, _this);
    return _this;
  }
  _inherits(Room2, _Message);
  return _createClass(Room2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new Room2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new Room2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new Room2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(Room2, a, b);
    }
  }]);
}(Message);
Room$1.runtime = proto3;
Room$1.typeName = "livekit.Room";
Room$1.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "empty_timeout",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 14,
    name: "departure_timeout",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 4,
    name: "max_participants",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 5,
    name: "creation_time",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 6,
    name: "turn_password",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 7,
    name: "enabled_codecs",
    kind: "message",
    T: Codec,
    repeated: true
  }, {
    no: 8,
    name: "metadata",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 9,
    name: "num_participants",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 11,
    name: "num_publishers",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 10,
    name: "active_recording",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 13,
    name: "version",
    kind: "message",
    T: TimedVersion
  }];
});
var Codec = function(_Message2) {
  function Codec2(data) {
    var _this2;
    _classCallCheck(this, Codec2);
    _this2 = _callSuper(this, Codec2);
    _this2.mime = "";
    _this2.fmtpLine = "";
    proto3.util.initPartial(data, _this2);
    return _this2;
  }
  _inherits(Codec2, _Message2);
  return _createClass(Codec2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new Codec2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new Codec2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new Codec2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(Codec2, a, b);
    }
  }]);
}(Message);
Codec.runtime = proto3;
Codec.typeName = "livekit.Codec";
Codec.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "mime",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "fmtp_line",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }];
});
var PlayoutDelay = function(_Message3) {
  function PlayoutDelay2(data) {
    var _this3;
    _classCallCheck(this, PlayoutDelay2);
    _this3 = _callSuper(this, PlayoutDelay2);
    _this3.enabled = false;
    _this3.min = 0;
    _this3.max = 0;
    proto3.util.initPartial(data, _this3);
    return _this3;
  }
  _inherits(PlayoutDelay2, _Message3);
  return _createClass(PlayoutDelay2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new PlayoutDelay2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new PlayoutDelay2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new PlayoutDelay2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(PlayoutDelay2, a, b);
    }
  }]);
}(Message);
PlayoutDelay.runtime = proto3;
PlayoutDelay.typeName = "livekit.PlayoutDelay";
PlayoutDelay.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "enabled",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 2,
    name: "min",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 3,
    name: "max",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }];
});
var ParticipantPermission = function(_Message4) {
  function ParticipantPermission2(data) {
    var _this4;
    _classCallCheck(this, ParticipantPermission2);
    _this4 = _callSuper(this, ParticipantPermission2);
    _this4.canSubscribe = false;
    _this4.canPublish = false;
    _this4.canPublishData = false;
    _this4.canPublishSources = [];
    _this4.hidden = false;
    _this4.recorder = false;
    _this4.canUpdateMetadata = false;
    _this4.agent = false;
    _this4.canSubscribeMetrics = false;
    proto3.util.initPartial(data, _this4);
    return _this4;
  }
  _inherits(ParticipantPermission2, _Message4);
  return _createClass(ParticipantPermission2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new ParticipantPermission2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new ParticipantPermission2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new ParticipantPermission2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(ParticipantPermission2, a, b);
    }
  }]);
}(Message);
ParticipantPermission.runtime = proto3;
ParticipantPermission.typeName = "livekit.ParticipantPermission";
ParticipantPermission.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "can_subscribe",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 2,
    name: "can_publish",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 3,
    name: "can_publish_data",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 9,
    name: "can_publish_sources",
    kind: "enum",
    T: proto3.getEnumType(TrackSource),
    repeated: true
  }, {
    no: 7,
    name: "hidden",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 8,
    name: "recorder",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 10,
    name: "can_update_metadata",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 11,
    name: "agent",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 12,
    name: "can_subscribe_metrics",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }];
});
var ParticipantInfo = function(_Message5) {
  function ParticipantInfo2(data) {
    var _this5;
    _classCallCheck(this, ParticipantInfo2);
    _this5 = _callSuper(this, ParticipantInfo2);
    _this5.sid = "";
    _this5.identity = "";
    _this5.state = ParticipantInfo_State.JOINING;
    _this5.tracks = [];
    _this5.metadata = "";
    _this5.joinedAt = protoInt64.zero;
    _this5.name = "";
    _this5.version = 0;
    _this5.region = "";
    _this5.isPublisher = false;
    _this5.kind = ParticipantInfo_Kind.STANDARD;
    _this5.attributes = {};
    _this5.disconnectReason = DisconnectReason.UNKNOWN_REASON;
    proto3.util.initPartial(data, _this5);
    return _this5;
  }
  _inherits(ParticipantInfo2, _Message5);
  return _createClass(ParticipantInfo2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new ParticipantInfo2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new ParticipantInfo2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new ParticipantInfo2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(ParticipantInfo2, a, b);
    }
  }]);
}(Message);
ParticipantInfo.runtime = proto3;
ParticipantInfo.typeName = "livekit.ParticipantInfo";
ParticipantInfo.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "identity",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "state",
    kind: "enum",
    T: proto3.getEnumType(ParticipantInfo_State)
  }, {
    no: 4,
    name: "tracks",
    kind: "message",
    T: TrackInfo,
    repeated: true
  }, {
    no: 5,
    name: "metadata",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 6,
    name: "joined_at",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 9,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 10,
    name: "version",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 11,
    name: "permission",
    kind: "message",
    T: ParticipantPermission
  }, {
    no: 12,
    name: "region",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 13,
    name: "is_publisher",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 14,
    name: "kind",
    kind: "enum",
    T: proto3.getEnumType(ParticipantInfo_Kind)
  }, {
    no: 15,
    name: "attributes",
    kind: "map",
    K: 9,
    V: {
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  }, {
    no: 16,
    name: "disconnect_reason",
    kind: "enum",
    T: proto3.getEnumType(DisconnectReason)
  }];
});
var ParticipantInfo_State;
(function(ParticipantInfo_State2) {
  ParticipantInfo_State2[ParticipantInfo_State2["JOINING"] = 0] = "JOINING";
  ParticipantInfo_State2[ParticipantInfo_State2["JOINED"] = 1] = "JOINED";
  ParticipantInfo_State2[ParticipantInfo_State2["ACTIVE"] = 2] = "ACTIVE";
  ParticipantInfo_State2[ParticipantInfo_State2["DISCONNECTED"] = 3] = "DISCONNECTED";
})(ParticipantInfo_State || (ParticipantInfo_State = {}));
proto3.util.setEnumType(ParticipantInfo_State, "livekit.ParticipantInfo.State", [{
  no: 0,
  name: "JOINING"
}, {
  no: 1,
  name: "JOINED"
}, {
  no: 2,
  name: "ACTIVE"
}, {
  no: 3,
  name: "DISCONNECTED"
}]);
var ParticipantInfo_Kind;
(function(ParticipantInfo_Kind2) {
  ParticipantInfo_Kind2[ParticipantInfo_Kind2["STANDARD"] = 0] = "STANDARD";
  ParticipantInfo_Kind2[ParticipantInfo_Kind2["INGRESS"] = 1] = "INGRESS";
  ParticipantInfo_Kind2[ParticipantInfo_Kind2["EGRESS"] = 2] = "EGRESS";
  ParticipantInfo_Kind2[ParticipantInfo_Kind2["SIP"] = 3] = "SIP";
  ParticipantInfo_Kind2[ParticipantInfo_Kind2["AGENT"] = 4] = "AGENT";
})(ParticipantInfo_Kind || (ParticipantInfo_Kind = {}));
proto3.util.setEnumType(ParticipantInfo_Kind, "livekit.ParticipantInfo.Kind", [{
  no: 0,
  name: "STANDARD"
}, {
  no: 1,
  name: "INGRESS"
}, {
  no: 2,
  name: "EGRESS"
}, {
  no: 3,
  name: "SIP"
}, {
  no: 4,
  name: "AGENT"
}]);
var Encryption = function(_Message6) {
  function Encryption2(data) {
    var _this6;
    _classCallCheck(this, Encryption2);
    _this6 = _callSuper(this, Encryption2);
    proto3.util.initPartial(data, _this6);
    return _this6;
  }
  _inherits(Encryption2, _Message6);
  return _createClass(Encryption2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new Encryption2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new Encryption2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new Encryption2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(Encryption2, a, b);
    }
  }]);
}(Message);
Encryption.runtime = proto3;
Encryption.typeName = "livekit.Encryption";
Encryption.fields = proto3.util.newFieldList(function() {
  return [];
});
var Encryption_Type;
(function(Encryption_Type2) {
  Encryption_Type2[Encryption_Type2["NONE"] = 0] = "NONE";
  Encryption_Type2[Encryption_Type2["GCM"] = 1] = "GCM";
  Encryption_Type2[Encryption_Type2["CUSTOM"] = 2] = "CUSTOM";
})(Encryption_Type || (Encryption_Type = {}));
proto3.util.setEnumType(Encryption_Type, "livekit.Encryption.Type", [{
  no: 0,
  name: "NONE"
}, {
  no: 1,
  name: "GCM"
}, {
  no: 2,
  name: "CUSTOM"
}]);
var SimulcastCodecInfo = function(_Message7) {
  function SimulcastCodecInfo2(data) {
    var _this7;
    _classCallCheck(this, SimulcastCodecInfo2);
    _this7 = _callSuper(this, SimulcastCodecInfo2);
    _this7.mimeType = "";
    _this7.mid = "";
    _this7.cid = "";
    _this7.layers = [];
    proto3.util.initPartial(data, _this7);
    return _this7;
  }
  _inherits(SimulcastCodecInfo2, _Message7);
  return _createClass(SimulcastCodecInfo2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new SimulcastCodecInfo2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new SimulcastCodecInfo2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new SimulcastCodecInfo2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(SimulcastCodecInfo2, a, b);
    }
  }]);
}(Message);
SimulcastCodecInfo.runtime = proto3;
SimulcastCodecInfo.typeName = "livekit.SimulcastCodecInfo";
SimulcastCodecInfo.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "mime_type",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "mid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "cid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 4,
    name: "layers",
    kind: "message",
    T: VideoLayer,
    repeated: true
  }];
});
var TrackInfo = function(_Message8) {
  function TrackInfo2(data) {
    var _this8;
    _classCallCheck(this, TrackInfo2);
    _this8 = _callSuper(this, TrackInfo2);
    _this8.sid = "";
    _this8.type = TrackType.AUDIO;
    _this8.name = "";
    _this8.muted = false;
    _this8.width = 0;
    _this8.height = 0;
    _this8.simulcast = false;
    _this8.disableDtx = false;
    _this8.source = TrackSource.UNKNOWN;
    _this8.layers = [];
    _this8.mimeType = "";
    _this8.mid = "";
    _this8.codecs = [];
    _this8.stereo = false;
    _this8.disableRed = false;
    _this8.encryption = Encryption_Type.NONE;
    _this8.stream = "";
    _this8.audioFeatures = [];
    proto3.util.initPartial(data, _this8);
    return _this8;
  }
  _inherits(TrackInfo2, _Message8);
  return _createClass(TrackInfo2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new TrackInfo2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new TrackInfo2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new TrackInfo2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(TrackInfo2, a, b);
    }
  }]);
}(Message);
TrackInfo.runtime = proto3;
TrackInfo.typeName = "livekit.TrackInfo";
TrackInfo.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "type",
    kind: "enum",
    T: proto3.getEnumType(TrackType)
  }, {
    no: 3,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 4,
    name: "muted",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 5,
    name: "width",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 6,
    name: "height",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 7,
    name: "simulcast",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 8,
    name: "disable_dtx",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 9,
    name: "source",
    kind: "enum",
    T: proto3.getEnumType(TrackSource)
  }, {
    no: 10,
    name: "layers",
    kind: "message",
    T: VideoLayer,
    repeated: true
  }, {
    no: 11,
    name: "mime_type",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 12,
    name: "mid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 13,
    name: "codecs",
    kind: "message",
    T: SimulcastCodecInfo,
    repeated: true
  }, {
    no: 14,
    name: "stereo",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 15,
    name: "disable_red",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 16,
    name: "encryption",
    kind: "enum",
    T: proto3.getEnumType(Encryption_Type)
  }, {
    no: 17,
    name: "stream",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 18,
    name: "version",
    kind: "message",
    T: TimedVersion
  }, {
    no: 19,
    name: "audio_features",
    kind: "enum",
    T: proto3.getEnumType(AudioTrackFeature),
    repeated: true
  }];
});
var VideoLayer = function(_Message9) {
  function VideoLayer2(data) {
    var _this9;
    _classCallCheck(this, VideoLayer2);
    _this9 = _callSuper(this, VideoLayer2);
    _this9.quality = VideoQuality$1.LOW;
    _this9.width = 0;
    _this9.height = 0;
    _this9.bitrate = 0;
    _this9.ssrc = 0;
    proto3.util.initPartial(data, _this9);
    return _this9;
  }
  _inherits(VideoLayer2, _Message9);
  return _createClass(VideoLayer2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new VideoLayer2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new VideoLayer2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new VideoLayer2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(VideoLayer2, a, b);
    }
  }]);
}(Message);
VideoLayer.runtime = proto3;
VideoLayer.typeName = "livekit.VideoLayer";
VideoLayer.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "quality",
    kind: "enum",
    T: proto3.getEnumType(VideoQuality$1)
  }, {
    no: 2,
    name: "width",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 3,
    name: "height",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 4,
    name: "bitrate",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 5,
    name: "ssrc",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }];
});
var DataPacket = function(_Message0) {
  function DataPacket2(data) {
    var _this0;
    _classCallCheck(this, DataPacket2);
    _this0 = _callSuper(this, DataPacket2);
    _this0.kind = DataPacket_Kind.RELIABLE;
    _this0.participantIdentity = "";
    _this0.destinationIdentities = [];
    _this0.value = {
      "case": void 0
    };
    proto3.util.initPartial(data, _this0);
    return _this0;
  }
  _inherits(DataPacket2, _Message0);
  return _createClass(DataPacket2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new DataPacket2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new DataPacket2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new DataPacket2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(DataPacket2, a, b);
    }
  }]);
}(Message);
DataPacket.runtime = proto3;
DataPacket.typeName = "livekit.DataPacket";
DataPacket.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "kind",
    kind: "enum",
    T: proto3.getEnumType(DataPacket_Kind)
  }, {
    no: 4,
    name: "participant_identity",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 5,
    name: "destination_identities",
    kind: "scalar",
    T: 9,
    repeated: true
  }, {
    no: 2,
    name: "user",
    kind: "message",
    T: UserPacket,
    oneof: "value"
  }, {
    no: 3,
    name: "speaker",
    kind: "message",
    T: ActiveSpeakerUpdate,
    oneof: "value"
  }, {
    no: 6,
    name: "sip_dtmf",
    kind: "message",
    T: SipDTMF,
    oneof: "value"
  }, {
    no: 7,
    name: "transcription",
    kind: "message",
    T: Transcription,
    oneof: "value"
  }, {
    no: 8,
    name: "metrics",
    kind: "message",
    T: MetricsBatch,
    oneof: "value"
  }, {
    no: 9,
    name: "chat_message",
    kind: "message",
    T: ChatMessage,
    oneof: "value"
  }, {
    no: 10,
    name: "rpc_request",
    kind: "message",
    T: RpcRequest,
    oneof: "value"
  }, {
    no: 11,
    name: "rpc_ack",
    kind: "message",
    T: RpcAck,
    oneof: "value"
  }, {
    no: 12,
    name: "rpc_response",
    kind: "message",
    T: RpcResponse,
    oneof: "value"
  }, {
    no: 13,
    name: "stream_header",
    kind: "message",
    T: DataStream_Header,
    oneof: "value"
  }, {
    no: 14,
    name: "stream_chunk",
    kind: "message",
    T: DataStream_Chunk,
    oneof: "value"
  }];
});
var DataPacket_Kind;
(function(DataPacket_Kind2) {
  DataPacket_Kind2[DataPacket_Kind2["RELIABLE"] = 0] = "RELIABLE";
  DataPacket_Kind2[DataPacket_Kind2["LOSSY"] = 1] = "LOSSY";
})(DataPacket_Kind || (DataPacket_Kind = {}));
proto3.util.setEnumType(DataPacket_Kind, "livekit.DataPacket.Kind", [{
  no: 0,
  name: "RELIABLE"
}, {
  no: 1,
  name: "LOSSY"
}]);
var ActiveSpeakerUpdate = function(_Message1) {
  function ActiveSpeakerUpdate2(data) {
    var _this1;
    _classCallCheck(this, ActiveSpeakerUpdate2);
    _this1 = _callSuper(this, ActiveSpeakerUpdate2);
    _this1.speakers = [];
    proto3.util.initPartial(data, _this1);
    return _this1;
  }
  _inherits(ActiveSpeakerUpdate2, _Message1);
  return _createClass(ActiveSpeakerUpdate2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new ActiveSpeakerUpdate2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new ActiveSpeakerUpdate2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new ActiveSpeakerUpdate2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(ActiveSpeakerUpdate2, a, b);
    }
  }]);
}(Message);
ActiveSpeakerUpdate.runtime = proto3;
ActiveSpeakerUpdate.typeName = "livekit.ActiveSpeakerUpdate";
ActiveSpeakerUpdate.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "speakers",
    kind: "message",
    T: SpeakerInfo,
    repeated: true
  }];
});
var SpeakerInfo = function(_Message10) {
  function SpeakerInfo2(data) {
    var _this10;
    _classCallCheck(this, SpeakerInfo2);
    _this10 = _callSuper(this, SpeakerInfo2);
    _this10.sid = "";
    _this10.level = 0;
    _this10.active = false;
    proto3.util.initPartial(data, _this10);
    return _this10;
  }
  _inherits(SpeakerInfo2, _Message10);
  return _createClass(SpeakerInfo2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new SpeakerInfo2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new SpeakerInfo2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new SpeakerInfo2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(SpeakerInfo2, a, b);
    }
  }]);
}(Message);
SpeakerInfo.runtime = proto3;
SpeakerInfo.typeName = "livekit.SpeakerInfo";
SpeakerInfo.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "level",
    kind: "scalar",
    T: 2
    /* ScalarType.FLOAT */
  }, {
    no: 3,
    name: "active",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }];
});
var UserPacket = function(_Message11) {
  function UserPacket2(data) {
    var _this11;
    _classCallCheck(this, UserPacket2);
    _this11 = _callSuper(this, UserPacket2);
    _this11.participantSid = "";
    _this11.participantIdentity = "";
    _this11.payload = new Uint8Array(0);
    _this11.destinationSids = [];
    _this11.destinationIdentities = [];
    proto3.util.initPartial(data, _this11);
    return _this11;
  }
  _inherits(UserPacket2, _Message11);
  return _createClass(UserPacket2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new UserPacket2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new UserPacket2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new UserPacket2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(UserPacket2, a, b);
    }
  }]);
}(Message);
UserPacket.runtime = proto3;
UserPacket.typeName = "livekit.UserPacket";
UserPacket.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "participant_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 5,
    name: "participant_identity",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "payload",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  }, {
    no: 3,
    name: "destination_sids",
    kind: "scalar",
    T: 9,
    repeated: true
  }, {
    no: 6,
    name: "destination_identities",
    kind: "scalar",
    T: 9,
    repeated: true
  }, {
    no: 4,
    name: "topic",
    kind: "scalar",
    T: 9,
    opt: true
  }, {
    no: 8,
    name: "id",
    kind: "scalar",
    T: 9,
    opt: true
  }, {
    no: 9,
    name: "start_time",
    kind: "scalar",
    T: 4,
    opt: true
  }, {
    no: 10,
    name: "end_time",
    kind: "scalar",
    T: 4,
    opt: true
  }];
});
var SipDTMF = function(_Message12) {
  function SipDTMF2(data) {
    var _this12;
    _classCallCheck(this, SipDTMF2);
    _this12 = _callSuper(this, SipDTMF2);
    _this12.code = 0;
    _this12.digit = "";
    proto3.util.initPartial(data, _this12);
    return _this12;
  }
  _inherits(SipDTMF2, _Message12);
  return _createClass(SipDTMF2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new SipDTMF2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new SipDTMF2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new SipDTMF2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(SipDTMF2, a, b);
    }
  }]);
}(Message);
SipDTMF.runtime = proto3;
SipDTMF.typeName = "livekit.SipDTMF";
SipDTMF.fields = proto3.util.newFieldList(function() {
  return [{
    no: 3,
    name: "code",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 4,
    name: "digit",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }];
});
var Transcription = function(_Message13) {
  function Transcription2(data) {
    var _this13;
    _classCallCheck(this, Transcription2);
    _this13 = _callSuper(this, Transcription2);
    _this13.transcribedParticipantIdentity = "";
    _this13.trackId = "";
    _this13.segments = [];
    proto3.util.initPartial(data, _this13);
    return _this13;
  }
  _inherits(Transcription2, _Message13);
  return _createClass(Transcription2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new Transcription2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new Transcription2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new Transcription2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(Transcription2, a, b);
    }
  }]);
}(Message);
Transcription.runtime = proto3;
Transcription.typeName = "livekit.Transcription";
Transcription.fields = proto3.util.newFieldList(function() {
  return [{
    no: 2,
    name: "transcribed_participant_identity",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "track_id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 4,
    name: "segments",
    kind: "message",
    T: TranscriptionSegment,
    repeated: true
  }];
});
var TranscriptionSegment = function(_Message14) {
  function TranscriptionSegment2(data) {
    var _this14;
    _classCallCheck(this, TranscriptionSegment2);
    _this14 = _callSuper(this, TranscriptionSegment2);
    _this14.id = "";
    _this14.text = "";
    _this14.startTime = protoInt64.zero;
    _this14.endTime = protoInt64.zero;
    _this14["final"] = false;
    _this14.language = "";
    _this14.error = false;
    _this14.failureReason = "";
    proto3.util.initPartial(data, _this14);
    return _this14;
  }
  _inherits(TranscriptionSegment2, _Message14);
  return _createClass(TranscriptionSegment2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new TranscriptionSegment2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new TranscriptionSegment2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new TranscriptionSegment2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(TranscriptionSegment2, a, b);
    }
  }]);
}(Message);
TranscriptionSegment.runtime = proto3;
TranscriptionSegment.typeName = "livekit.TranscriptionSegment";
TranscriptionSegment.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "text",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "start_time",
    kind: "scalar",
    T: 4
    /* ScalarType.UINT64 */
  }, {
    no: 4,
    name: "end_time",
    kind: "scalar",
    T: 4
    /* ScalarType.UINT64 */
  }, {
    no: 5,
    name: "final",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 6,
    name: "language",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 7,
    name: "error",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 8,
    name: "failure_reason",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }];
});
var ChatMessage = function(_Message15) {
  function ChatMessage2(data) {
    var _this15;
    _classCallCheck(this, ChatMessage2);
    _this15 = _callSuper(this, ChatMessage2);
    _this15.id = "";
    _this15.timestamp = protoInt64.zero;
    _this15.message = "";
    _this15.deleted = false;
    _this15.generated = false;
    proto3.util.initPartial(data, _this15);
    return _this15;
  }
  _inherits(ChatMessage2, _Message15);
  return _createClass(ChatMessage2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new ChatMessage2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new ChatMessage2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new ChatMessage2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(ChatMessage2, a, b);
    }
  }]);
}(Message);
ChatMessage.runtime = proto3;
ChatMessage.typeName = "livekit.ChatMessage";
ChatMessage.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "timestamp",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 3,
    name: "edit_timestamp",
    kind: "scalar",
    T: 3,
    opt: true
  }, {
    no: 4,
    name: "message",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 5,
    name: "deleted",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 6,
    name: "generated",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }];
});
var RpcRequest = function(_Message16) {
  function RpcRequest2(data) {
    var _this16;
    _classCallCheck(this, RpcRequest2);
    _this16 = _callSuper(this, RpcRequest2);
    _this16.id = "";
    _this16.method = "";
    _this16.payload = "";
    _this16.responseTimeoutMs = 0;
    _this16.version = 0;
    proto3.util.initPartial(data, _this16);
    return _this16;
  }
  _inherits(RpcRequest2, _Message16);
  return _createClass(RpcRequest2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new RpcRequest2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new RpcRequest2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new RpcRequest2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(RpcRequest2, a, b);
    }
  }]);
}(Message);
RpcRequest.runtime = proto3;
RpcRequest.typeName = "livekit.RpcRequest";
RpcRequest.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "method",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "payload",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 4,
    name: "response_timeout_ms",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 5,
    name: "version",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }];
});
var RpcAck = function(_Message17) {
  function RpcAck2(data) {
    var _this17;
    _classCallCheck(this, RpcAck2);
    _this17 = _callSuper(this, RpcAck2);
    _this17.requestId = "";
    proto3.util.initPartial(data, _this17);
    return _this17;
  }
  _inherits(RpcAck2, _Message17);
  return _createClass(RpcAck2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new RpcAck2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new RpcAck2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new RpcAck2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(RpcAck2, a, b);
    }
  }]);
}(Message);
RpcAck.runtime = proto3;
RpcAck.typeName = "livekit.RpcAck";
RpcAck.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "request_id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }];
});
var RpcResponse = function(_Message18) {
  function RpcResponse2(data) {
    var _this18;
    _classCallCheck(this, RpcResponse2);
    _this18 = _callSuper(this, RpcResponse2);
    _this18.requestId = "";
    _this18.value = {
      "case": void 0
    };
    proto3.util.initPartial(data, _this18);
    return _this18;
  }
  _inherits(RpcResponse2, _Message18);
  return _createClass(RpcResponse2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new RpcResponse2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new RpcResponse2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new RpcResponse2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(RpcResponse2, a, b);
    }
  }]);
}(Message);
RpcResponse.runtime = proto3;
RpcResponse.typeName = "livekit.RpcResponse";
RpcResponse.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "request_id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "payload",
    kind: "scalar",
    T: 9,
    oneof: "value"
  }, {
    no: 3,
    name: "error",
    kind: "message",
    T: RpcError$1,
    oneof: "value"
  }];
});
var RpcError$1 = function(_Message19) {
  function RpcError2(data) {
    var _this19;
    _classCallCheck(this, RpcError2);
    _this19 = _callSuper(this, RpcError2);
    _this19.code = 0;
    _this19.message = "";
    _this19.data = "";
    proto3.util.initPartial(data, _this19);
    return _this19;
  }
  _inherits(RpcError2, _Message19);
  return _createClass(RpcError2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new RpcError2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new RpcError2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new RpcError2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(RpcError2, a, b);
    }
  }]);
}(Message);
RpcError$1.runtime = proto3;
RpcError$1.typeName = "livekit.RpcError";
RpcError$1.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "code",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 2,
    name: "message",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "data",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }];
});
var ParticipantTracks = function(_Message20) {
  function ParticipantTracks2(data) {
    var _this20;
    _classCallCheck(this, ParticipantTracks2);
    _this20 = _callSuper(this, ParticipantTracks2);
    _this20.participantSid = "";
    _this20.trackSids = [];
    proto3.util.initPartial(data, _this20);
    return _this20;
  }
  _inherits(ParticipantTracks2, _Message20);
  return _createClass(ParticipantTracks2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new ParticipantTracks2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new ParticipantTracks2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new ParticipantTracks2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(ParticipantTracks2, a, b);
    }
  }]);
}(Message);
ParticipantTracks.runtime = proto3;
ParticipantTracks.typeName = "livekit.ParticipantTracks";
ParticipantTracks.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "participant_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "track_sids",
    kind: "scalar",
    T: 9,
    repeated: true
  }];
});
var ServerInfo = function(_Message21) {
  function ServerInfo2(data) {
    var _this21;
    _classCallCheck(this, ServerInfo2);
    _this21 = _callSuper(this, ServerInfo2);
    _this21.edition = ServerInfo_Edition.Standard;
    _this21.version = "";
    _this21.protocol = 0;
    _this21.region = "";
    _this21.nodeId = "";
    _this21.debugInfo = "";
    _this21.agentProtocol = 0;
    proto3.util.initPartial(data, _this21);
    return _this21;
  }
  _inherits(ServerInfo2, _Message21);
  return _createClass(ServerInfo2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new ServerInfo2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new ServerInfo2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new ServerInfo2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(ServerInfo2, a, b);
    }
  }]);
}(Message);
ServerInfo.runtime = proto3;
ServerInfo.typeName = "livekit.ServerInfo";
ServerInfo.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "edition",
    kind: "enum",
    T: proto3.getEnumType(ServerInfo_Edition)
  }, {
    no: 2,
    name: "version",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "protocol",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }, {
    no: 4,
    name: "region",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 5,
    name: "node_id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 6,
    name: "debug_info",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 7,
    name: "agent_protocol",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }];
});
var ServerInfo_Edition;
(function(ServerInfo_Edition2) {
  ServerInfo_Edition2[ServerInfo_Edition2["Standard"] = 0] = "Standard";
  ServerInfo_Edition2[ServerInfo_Edition2["Cloud"] = 1] = "Cloud";
})(ServerInfo_Edition || (ServerInfo_Edition = {}));
proto3.util.setEnumType(ServerInfo_Edition, "livekit.ServerInfo.Edition", [{
  no: 0,
  name: "Standard"
}, {
  no: 1,
  name: "Cloud"
}]);
var ClientInfo = function(_Message22) {
  function ClientInfo2(data) {
    var _this22;
    _classCallCheck(this, ClientInfo2);
    _this22 = _callSuper(this, ClientInfo2);
    _this22.sdk = ClientInfo_SDK.UNKNOWN;
    _this22.version = "";
    _this22.protocol = 0;
    _this22.os = "";
    _this22.osVersion = "";
    _this22.deviceModel = "";
    _this22.browser = "";
    _this22.browserVersion = "";
    _this22.address = "";
    _this22.network = "";
    _this22.otherSdks = "";
    proto3.util.initPartial(data, _this22);
    return _this22;
  }
  _inherits(ClientInfo2, _Message22);
  return _createClass(ClientInfo2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new ClientInfo2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new ClientInfo2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new ClientInfo2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(ClientInfo2, a, b);
    }
  }]);
}(Message);
ClientInfo.runtime = proto3;
ClientInfo.typeName = "livekit.ClientInfo";
ClientInfo.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "sdk",
    kind: "enum",
    T: proto3.getEnumType(ClientInfo_SDK)
  }, {
    no: 2,
    name: "version",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "protocol",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }, {
    no: 4,
    name: "os",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 5,
    name: "os_version",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 6,
    name: "device_model",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 7,
    name: "browser",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 8,
    name: "browser_version",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 9,
    name: "address",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 10,
    name: "network",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 11,
    name: "other_sdks",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }];
});
var ClientInfo_SDK;
(function(ClientInfo_SDK2) {
  ClientInfo_SDK2[ClientInfo_SDK2["UNKNOWN"] = 0] = "UNKNOWN";
  ClientInfo_SDK2[ClientInfo_SDK2["JS"] = 1] = "JS";
  ClientInfo_SDK2[ClientInfo_SDK2["SWIFT"] = 2] = "SWIFT";
  ClientInfo_SDK2[ClientInfo_SDK2["ANDROID"] = 3] = "ANDROID";
  ClientInfo_SDK2[ClientInfo_SDK2["FLUTTER"] = 4] = "FLUTTER";
  ClientInfo_SDK2[ClientInfo_SDK2["GO"] = 5] = "GO";
  ClientInfo_SDK2[ClientInfo_SDK2["UNITY"] = 6] = "UNITY";
  ClientInfo_SDK2[ClientInfo_SDK2["REACT_NATIVE"] = 7] = "REACT_NATIVE";
  ClientInfo_SDK2[ClientInfo_SDK2["RUST"] = 8] = "RUST";
  ClientInfo_SDK2[ClientInfo_SDK2["PYTHON"] = 9] = "PYTHON";
  ClientInfo_SDK2[ClientInfo_SDK2["CPP"] = 10] = "CPP";
  ClientInfo_SDK2[ClientInfo_SDK2["UNITY_WEB"] = 11] = "UNITY_WEB";
  ClientInfo_SDK2[ClientInfo_SDK2["NODE"] = 12] = "NODE";
})(ClientInfo_SDK || (ClientInfo_SDK = {}));
proto3.util.setEnumType(ClientInfo_SDK, "livekit.ClientInfo.SDK", [{
  no: 0,
  name: "UNKNOWN"
}, {
  no: 1,
  name: "JS"
}, {
  no: 2,
  name: "SWIFT"
}, {
  no: 3,
  name: "ANDROID"
}, {
  no: 4,
  name: "FLUTTER"
}, {
  no: 5,
  name: "GO"
}, {
  no: 6,
  name: "UNITY"
}, {
  no: 7,
  name: "REACT_NATIVE"
}, {
  no: 8,
  name: "RUST"
}, {
  no: 9,
  name: "PYTHON"
}, {
  no: 10,
  name: "CPP"
}, {
  no: 11,
  name: "UNITY_WEB"
}, {
  no: 12,
  name: "NODE"
}]);
var ClientConfiguration = function(_Message23) {
  function ClientConfiguration2(data) {
    var _this23;
    _classCallCheck(this, ClientConfiguration2);
    _this23 = _callSuper(this, ClientConfiguration2);
    _this23.resumeConnection = ClientConfigSetting.UNSET;
    _this23.forceRelay = ClientConfigSetting.UNSET;
    proto3.util.initPartial(data, _this23);
    return _this23;
  }
  _inherits(ClientConfiguration2, _Message23);
  return _createClass(ClientConfiguration2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new ClientConfiguration2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new ClientConfiguration2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new ClientConfiguration2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(ClientConfiguration2, a, b);
    }
  }]);
}(Message);
ClientConfiguration.runtime = proto3;
ClientConfiguration.typeName = "livekit.ClientConfiguration";
ClientConfiguration.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "video",
    kind: "message",
    T: VideoConfiguration
  }, {
    no: 2,
    name: "screen",
    kind: "message",
    T: VideoConfiguration
  }, {
    no: 3,
    name: "resume_connection",
    kind: "enum",
    T: proto3.getEnumType(ClientConfigSetting)
  }, {
    no: 4,
    name: "disabled_codecs",
    kind: "message",
    T: DisabledCodecs
  }, {
    no: 5,
    name: "force_relay",
    kind: "enum",
    T: proto3.getEnumType(ClientConfigSetting)
  }];
});
var VideoConfiguration = function(_Message24) {
  function VideoConfiguration2(data) {
    var _this24;
    _classCallCheck(this, VideoConfiguration2);
    _this24 = _callSuper(this, VideoConfiguration2);
    _this24.hardwareEncoder = ClientConfigSetting.UNSET;
    proto3.util.initPartial(data, _this24);
    return _this24;
  }
  _inherits(VideoConfiguration2, _Message24);
  return _createClass(VideoConfiguration2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new VideoConfiguration2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new VideoConfiguration2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new VideoConfiguration2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(VideoConfiguration2, a, b);
    }
  }]);
}(Message);
VideoConfiguration.runtime = proto3;
VideoConfiguration.typeName = "livekit.VideoConfiguration";
VideoConfiguration.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "hardware_encoder",
    kind: "enum",
    T: proto3.getEnumType(ClientConfigSetting)
  }];
});
var DisabledCodecs = function(_Message25) {
  function DisabledCodecs2(data) {
    var _this25;
    _classCallCheck(this, DisabledCodecs2);
    _this25 = _callSuper(this, DisabledCodecs2);
    _this25.codecs = [];
    _this25.publish = [];
    proto3.util.initPartial(data, _this25);
    return _this25;
  }
  _inherits(DisabledCodecs2, _Message25);
  return _createClass(DisabledCodecs2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new DisabledCodecs2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new DisabledCodecs2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new DisabledCodecs2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(DisabledCodecs2, a, b);
    }
  }]);
}(Message);
DisabledCodecs.runtime = proto3;
DisabledCodecs.typeName = "livekit.DisabledCodecs";
DisabledCodecs.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "codecs",
    kind: "message",
    T: Codec,
    repeated: true
  }, {
    no: 2,
    name: "publish",
    kind: "message",
    T: Codec,
    repeated: true
  }];
});
var RTPDrift = function(_Message26) {
  function RTPDrift2(data) {
    var _this26;
    _classCallCheck(this, RTPDrift2);
    _this26 = _callSuper(this, RTPDrift2);
    _this26.duration = 0;
    _this26.startTimestamp = protoInt64.zero;
    _this26.endTimestamp = protoInt64.zero;
    _this26.rtpClockTicks = protoInt64.zero;
    _this26.driftSamples = protoInt64.zero;
    _this26.driftMs = 0;
    _this26.clockRate = 0;
    proto3.util.initPartial(data, _this26);
    return _this26;
  }
  _inherits(RTPDrift2, _Message26);
  return _createClass(RTPDrift2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new RTPDrift2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new RTPDrift2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new RTPDrift2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(RTPDrift2, a, b);
    }
  }]);
}(Message);
RTPDrift.runtime = proto3;
RTPDrift.typeName = "livekit.RTPDrift";
RTPDrift.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "start_time",
    kind: "message",
    T: Timestamp
  }, {
    no: 2,
    name: "end_time",
    kind: "message",
    T: Timestamp
  }, {
    no: 3,
    name: "duration",
    kind: "scalar",
    T: 1
    /* ScalarType.DOUBLE */
  }, {
    no: 4,
    name: "start_timestamp",
    kind: "scalar",
    T: 4
    /* ScalarType.UINT64 */
  }, {
    no: 5,
    name: "end_timestamp",
    kind: "scalar",
    T: 4
    /* ScalarType.UINT64 */
  }, {
    no: 6,
    name: "rtp_clock_ticks",
    kind: "scalar",
    T: 4
    /* ScalarType.UINT64 */
  }, {
    no: 7,
    name: "drift_samples",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 8,
    name: "drift_ms",
    kind: "scalar",
    T: 1
    /* ScalarType.DOUBLE */
  }, {
    no: 9,
    name: "clock_rate",
    kind: "scalar",
    T: 1
    /* ScalarType.DOUBLE */
  }];
});
var RTPStats = function(_Message27) {
  function RTPStats2(data) {
    var _this27;
    _classCallCheck(this, RTPStats2);
    _this27 = _callSuper(this, RTPStats2);
    _this27.duration = 0;
    _this27.packets = 0;
    _this27.packetRate = 0;
    _this27.bytes = protoInt64.zero;
    _this27.headerBytes = protoInt64.zero;
    _this27.bitrate = 0;
    _this27.packetsLost = 0;
    _this27.packetLossRate = 0;
    _this27.packetLossPercentage = 0;
    _this27.packetsDuplicate = 0;
    _this27.packetDuplicateRate = 0;
    _this27.bytesDuplicate = protoInt64.zero;
    _this27.headerBytesDuplicate = protoInt64.zero;
    _this27.bitrateDuplicate = 0;
    _this27.packetsPadding = 0;
    _this27.packetPaddingRate = 0;
    _this27.bytesPadding = protoInt64.zero;
    _this27.headerBytesPadding = protoInt64.zero;
    _this27.bitratePadding = 0;
    _this27.packetsOutOfOrder = 0;
    _this27.frames = 0;
    _this27.frameRate = 0;
    _this27.jitterCurrent = 0;
    _this27.jitterMax = 0;
    _this27.gapHistogram = {};
    _this27.nacks = 0;
    _this27.nackAcks = 0;
    _this27.nackMisses = 0;
    _this27.nackRepeated = 0;
    _this27.plis = 0;
    _this27.firs = 0;
    _this27.rttCurrent = 0;
    _this27.rttMax = 0;
    _this27.keyFrames = 0;
    _this27.layerLockPlis = 0;
    proto3.util.initPartial(data, _this27);
    return _this27;
  }
  _inherits(RTPStats2, _Message27);
  return _createClass(RTPStats2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new RTPStats2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new RTPStats2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new RTPStats2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(RTPStats2, a, b);
    }
  }]);
}(Message);
RTPStats.runtime = proto3;
RTPStats.typeName = "livekit.RTPStats";
RTPStats.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "start_time",
    kind: "message",
    T: Timestamp
  }, {
    no: 2,
    name: "end_time",
    kind: "message",
    T: Timestamp
  }, {
    no: 3,
    name: "duration",
    kind: "scalar",
    T: 1
    /* ScalarType.DOUBLE */
  }, {
    no: 4,
    name: "packets",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 5,
    name: "packet_rate",
    kind: "scalar",
    T: 1
    /* ScalarType.DOUBLE */
  }, {
    no: 6,
    name: "bytes",
    kind: "scalar",
    T: 4
    /* ScalarType.UINT64 */
  }, {
    no: 39,
    name: "header_bytes",
    kind: "scalar",
    T: 4
    /* ScalarType.UINT64 */
  }, {
    no: 7,
    name: "bitrate",
    kind: "scalar",
    T: 1
    /* ScalarType.DOUBLE */
  }, {
    no: 8,
    name: "packets_lost",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 9,
    name: "packet_loss_rate",
    kind: "scalar",
    T: 1
    /* ScalarType.DOUBLE */
  }, {
    no: 10,
    name: "packet_loss_percentage",
    kind: "scalar",
    T: 2
    /* ScalarType.FLOAT */
  }, {
    no: 11,
    name: "packets_duplicate",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 12,
    name: "packet_duplicate_rate",
    kind: "scalar",
    T: 1
    /* ScalarType.DOUBLE */
  }, {
    no: 13,
    name: "bytes_duplicate",
    kind: "scalar",
    T: 4
    /* ScalarType.UINT64 */
  }, {
    no: 40,
    name: "header_bytes_duplicate",
    kind: "scalar",
    T: 4
    /* ScalarType.UINT64 */
  }, {
    no: 14,
    name: "bitrate_duplicate",
    kind: "scalar",
    T: 1
    /* ScalarType.DOUBLE */
  }, {
    no: 15,
    name: "packets_padding",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 16,
    name: "packet_padding_rate",
    kind: "scalar",
    T: 1
    /* ScalarType.DOUBLE */
  }, {
    no: 17,
    name: "bytes_padding",
    kind: "scalar",
    T: 4
    /* ScalarType.UINT64 */
  }, {
    no: 41,
    name: "header_bytes_padding",
    kind: "scalar",
    T: 4
    /* ScalarType.UINT64 */
  }, {
    no: 18,
    name: "bitrate_padding",
    kind: "scalar",
    T: 1
    /* ScalarType.DOUBLE */
  }, {
    no: 19,
    name: "packets_out_of_order",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 20,
    name: "frames",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 21,
    name: "frame_rate",
    kind: "scalar",
    T: 1
    /* ScalarType.DOUBLE */
  }, {
    no: 22,
    name: "jitter_current",
    kind: "scalar",
    T: 1
    /* ScalarType.DOUBLE */
  }, {
    no: 23,
    name: "jitter_max",
    kind: "scalar",
    T: 1
    /* ScalarType.DOUBLE */
  }, {
    no: 24,
    name: "gap_histogram",
    kind: "map",
    K: 5,
    V: {
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    }
  }, {
    no: 25,
    name: "nacks",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 37,
    name: "nack_acks",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 26,
    name: "nack_misses",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 38,
    name: "nack_repeated",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 27,
    name: "plis",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 28,
    name: "last_pli",
    kind: "message",
    T: Timestamp
  }, {
    no: 29,
    name: "firs",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 30,
    name: "last_fir",
    kind: "message",
    T: Timestamp
  }, {
    no: 31,
    name: "rtt_current",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 32,
    name: "rtt_max",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 33,
    name: "key_frames",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 34,
    name: "last_key_frame",
    kind: "message",
    T: Timestamp
  }, {
    no: 35,
    name: "layer_lock_plis",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 36,
    name: "last_layer_lock_pli",
    kind: "message",
    T: Timestamp
  }, {
    no: 44,
    name: "packet_drift",
    kind: "message",
    T: RTPDrift
  }, {
    no: 45,
    name: "ntp_report_drift",
    kind: "message",
    T: RTPDrift
  }, {
    no: 46,
    name: "rebased_report_drift",
    kind: "message",
    T: RTPDrift
  }, {
    no: 47,
    name: "received_report_drift",
    kind: "message",
    T: RTPDrift
  }];
});
var RTCPSenderReportState = function(_Message28) {
  function RTCPSenderReportState2(data) {
    var _this28;
    _classCallCheck(this, RTCPSenderReportState2);
    _this28 = _callSuper(this, RTCPSenderReportState2);
    _this28.rtpTimestamp = 0;
    _this28.rtpTimestampExt = protoInt64.zero;
    _this28.ntpTimestamp = protoInt64.zero;
    _this28.at = protoInt64.zero;
    _this28.atAdjusted = protoInt64.zero;
    _this28.packets = 0;
    _this28.octets = protoInt64.zero;
    proto3.util.initPartial(data, _this28);
    return _this28;
  }
  _inherits(RTCPSenderReportState2, _Message28);
  return _createClass(RTCPSenderReportState2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new RTCPSenderReportState2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new RTCPSenderReportState2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new RTCPSenderReportState2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(RTCPSenderReportState2, a, b);
    }
  }]);
}(Message);
RTCPSenderReportState.runtime = proto3;
RTCPSenderReportState.typeName = "livekit.RTCPSenderReportState";
RTCPSenderReportState.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "rtp_timestamp",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 2,
    name: "rtp_timestamp_ext",
    kind: "scalar",
    T: 4
    /* ScalarType.UINT64 */
  }, {
    no: 3,
    name: "ntp_timestamp",
    kind: "scalar",
    T: 4
    /* ScalarType.UINT64 */
  }, {
    no: 4,
    name: "at",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 5,
    name: "at_adjusted",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 6,
    name: "packets",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 7,
    name: "octets",
    kind: "scalar",
    T: 4
    /* ScalarType.UINT64 */
  }];
});
var RTPForwarderState = function(_Message29) {
  function RTPForwarderState2(data) {
    var _this29;
    _classCallCheck(this, RTPForwarderState2);
    _this29 = _callSuper(this, RTPForwarderState2);
    _this29.started = false;
    _this29.referenceLayerSpatial = 0;
    _this29.preStartTime = protoInt64.zero;
    _this29.extFirstTimestamp = protoInt64.zero;
    _this29.dummyStartTimestampOffset = protoInt64.zero;
    _this29.codecMunger = {
      "case": void 0
    };
    _this29.senderReportState = [];
    proto3.util.initPartial(data, _this29);
    return _this29;
  }
  _inherits(RTPForwarderState2, _Message29);
  return _createClass(RTPForwarderState2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new RTPForwarderState2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new RTPForwarderState2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new RTPForwarderState2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(RTPForwarderState2, a, b);
    }
  }]);
}(Message);
RTPForwarderState.runtime = proto3;
RTPForwarderState.typeName = "livekit.RTPForwarderState";
RTPForwarderState.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "started",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 2,
    name: "reference_layer_spatial",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }, {
    no: 3,
    name: "pre_start_time",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 4,
    name: "ext_first_timestamp",
    kind: "scalar",
    T: 4
    /* ScalarType.UINT64 */
  }, {
    no: 5,
    name: "dummy_start_timestamp_offset",
    kind: "scalar",
    T: 4
    /* ScalarType.UINT64 */
  }, {
    no: 6,
    name: "rtp_munger",
    kind: "message",
    T: RTPMungerState
  }, {
    no: 7,
    name: "vp8_munger",
    kind: "message",
    T: VP8MungerState,
    oneof: "codec_munger"
  }, {
    no: 8,
    name: "sender_report_state",
    kind: "message",
    T: RTCPSenderReportState,
    repeated: true
  }];
});
var RTPMungerState = function(_Message30) {
  function RTPMungerState2(data) {
    var _this30;
    _classCallCheck(this, RTPMungerState2);
    _this30 = _callSuper(this, RTPMungerState2);
    _this30.extLastSequenceNumber = protoInt64.zero;
    _this30.extSecondLastSequenceNumber = protoInt64.zero;
    _this30.extLastTimestamp = protoInt64.zero;
    _this30.extSecondLastTimestamp = protoInt64.zero;
    _this30.lastMarker = false;
    _this30.secondLastMarker = false;
    proto3.util.initPartial(data, _this30);
    return _this30;
  }
  _inherits(RTPMungerState2, _Message30);
  return _createClass(RTPMungerState2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new RTPMungerState2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new RTPMungerState2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new RTPMungerState2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(RTPMungerState2, a, b);
    }
  }]);
}(Message);
RTPMungerState.runtime = proto3;
RTPMungerState.typeName = "livekit.RTPMungerState";
RTPMungerState.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "ext_last_sequence_number",
    kind: "scalar",
    T: 4
    /* ScalarType.UINT64 */
  }, {
    no: 2,
    name: "ext_second_last_sequence_number",
    kind: "scalar",
    T: 4
    /* ScalarType.UINT64 */
  }, {
    no: 3,
    name: "ext_last_timestamp",
    kind: "scalar",
    T: 4
    /* ScalarType.UINT64 */
  }, {
    no: 4,
    name: "ext_second_last_timestamp",
    kind: "scalar",
    T: 4
    /* ScalarType.UINT64 */
  }, {
    no: 5,
    name: "last_marker",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 6,
    name: "second_last_marker",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }];
});
var VP8MungerState = function(_Message31) {
  function VP8MungerState2(data) {
    var _this31;
    _classCallCheck(this, VP8MungerState2);
    _this31 = _callSuper(this, VP8MungerState2);
    _this31.extLastPictureId = 0;
    _this31.pictureIdUsed = false;
    _this31.lastTl0PicIdx = 0;
    _this31.tl0PicIdxUsed = false;
    _this31.tidUsed = false;
    _this31.lastKeyIdx = 0;
    _this31.keyIdxUsed = false;
    proto3.util.initPartial(data, _this31);
    return _this31;
  }
  _inherits(VP8MungerState2, _Message31);
  return _createClass(VP8MungerState2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new VP8MungerState2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new VP8MungerState2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new VP8MungerState2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(VP8MungerState2, a, b);
    }
  }]);
}(Message);
VP8MungerState.runtime = proto3;
VP8MungerState.typeName = "livekit.VP8MungerState";
VP8MungerState.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "ext_last_picture_id",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }, {
    no: 2,
    name: "picture_id_used",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 3,
    name: "last_tl0_pic_idx",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 4,
    name: "tl0_pic_idx_used",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 5,
    name: "tid_used",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 6,
    name: "last_key_idx",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 7,
    name: "key_idx_used",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }];
});
var TimedVersion = function(_Message32) {
  function TimedVersion2(data) {
    var _this32;
    _classCallCheck(this, TimedVersion2);
    _this32 = _callSuper(this, TimedVersion2);
    _this32.unixMicro = protoInt64.zero;
    _this32.ticks = 0;
    proto3.util.initPartial(data, _this32);
    return _this32;
  }
  _inherits(TimedVersion2, _Message32);
  return _createClass(TimedVersion2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new TimedVersion2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new TimedVersion2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new TimedVersion2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(TimedVersion2, a, b);
    }
  }]);
}(Message);
TimedVersion.runtime = proto3;
TimedVersion.typeName = "livekit.TimedVersion";
TimedVersion.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "unix_micro",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 2,
    name: "ticks",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }];
});
var DataStream = function(_Message33) {
  function DataStream2(data) {
    var _this33;
    _classCallCheck(this, DataStream2);
    _this33 = _callSuper(this, DataStream2);
    proto3.util.initPartial(data, _this33);
    return _this33;
  }
  _inherits(DataStream2, _Message33);
  return _createClass(DataStream2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new DataStream2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new DataStream2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new DataStream2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(DataStream2, a, b);
    }
  }]);
}(Message);
DataStream.runtime = proto3;
DataStream.typeName = "livekit.DataStream";
DataStream.fields = proto3.util.newFieldList(function() {
  return [];
});
var DataStream_OperationType;
(function(DataStream_OperationType2) {
  DataStream_OperationType2[DataStream_OperationType2["CREATE"] = 0] = "CREATE";
  DataStream_OperationType2[DataStream_OperationType2["UPDATE"] = 1] = "UPDATE";
  DataStream_OperationType2[DataStream_OperationType2["DELETE"] = 2] = "DELETE";
  DataStream_OperationType2[DataStream_OperationType2["REACTION"] = 3] = "REACTION";
})(DataStream_OperationType || (DataStream_OperationType = {}));
proto3.util.setEnumType(DataStream_OperationType, "livekit.DataStream.OperationType", [{
  no: 0,
  name: "CREATE"
}, {
  no: 1,
  name: "UPDATE"
}, {
  no: 2,
  name: "DELETE"
}, {
  no: 3,
  name: "REACTION"
}]);
var DataStream_TextHeader = function(_Message34) {
  function DataStream_TextHeader2(data) {
    var _this34;
    _classCallCheck(this, DataStream_TextHeader2);
    _this34 = _callSuper(this, DataStream_TextHeader2);
    _this34.operationType = DataStream_OperationType.CREATE;
    _this34.version = 0;
    _this34.replyToStreamId = "";
    _this34.attachedStreamIds = [];
    _this34.generated = false;
    proto3.util.initPartial(data, _this34);
    return _this34;
  }
  _inherits(DataStream_TextHeader2, _Message34);
  return _createClass(DataStream_TextHeader2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new DataStream_TextHeader2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new DataStream_TextHeader2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new DataStream_TextHeader2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(DataStream_TextHeader2, a, b);
    }
  }]);
}(Message);
DataStream_TextHeader.runtime = proto3;
DataStream_TextHeader.typeName = "livekit.DataStream.TextHeader";
DataStream_TextHeader.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "operation_type",
    kind: "enum",
    T: proto3.getEnumType(DataStream_OperationType)
  }, {
    no: 2,
    name: "version",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }, {
    no: 3,
    name: "reply_to_stream_id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 4,
    name: "attached_stream_ids",
    kind: "scalar",
    T: 9,
    repeated: true
  }, {
    no: 5,
    name: "generated",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }];
});
var DataStream_FileHeader = function(_Message35) {
  function DataStream_FileHeader2(data) {
    var _this35;
    _classCallCheck(this, DataStream_FileHeader2);
    _this35 = _callSuper(this, DataStream_FileHeader2);
    _this35.fileName = "";
    proto3.util.initPartial(data, _this35);
    return _this35;
  }
  _inherits(DataStream_FileHeader2, _Message35);
  return _createClass(DataStream_FileHeader2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new DataStream_FileHeader2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new DataStream_FileHeader2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new DataStream_FileHeader2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(DataStream_FileHeader2, a, b);
    }
  }]);
}(Message);
DataStream_FileHeader.runtime = proto3;
DataStream_FileHeader.typeName = "livekit.DataStream.FileHeader";
DataStream_FileHeader.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "file_name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }];
});
var DataStream_Header = function(_Message36) {
  function DataStream_Header2(data) {
    var _this36;
    _classCallCheck(this, DataStream_Header2);
    _this36 = _callSuper(this, DataStream_Header2);
    _this36.streamId = "";
    _this36.timestamp = protoInt64.zero;
    _this36.topic = "";
    _this36.mimeType = "";
    _this36.encryptionType = Encryption_Type.NONE;
    _this36.extensions = {};
    _this36.contentHeader = {
      "case": void 0
    };
    proto3.util.initPartial(data, _this36);
    return _this36;
  }
  _inherits(DataStream_Header2, _Message36);
  return _createClass(DataStream_Header2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new DataStream_Header2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new DataStream_Header2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new DataStream_Header2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(DataStream_Header2, a, b);
    }
  }]);
}(Message);
DataStream_Header.runtime = proto3;
DataStream_Header.typeName = "livekit.DataStream.Header";
DataStream_Header.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "stream_id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "timestamp",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 3,
    name: "topic",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 4,
    name: "mime_type",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 5,
    name: "total_length",
    kind: "scalar",
    T: 4,
    opt: true
  }, {
    no: 7,
    name: "encryption_type",
    kind: "enum",
    T: proto3.getEnumType(Encryption_Type)
  }, {
    no: 8,
    name: "extensions",
    kind: "map",
    K: 9,
    V: {
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  }, {
    no: 9,
    name: "text_header",
    kind: "message",
    T: DataStream_TextHeader,
    oneof: "content_header"
  }, {
    no: 10,
    name: "file_header",
    kind: "message",
    T: DataStream_FileHeader,
    oneof: "content_header"
  }];
});
var DataStream_Chunk = function(_Message37) {
  function DataStream_Chunk2(data) {
    var _this37;
    _classCallCheck(this, DataStream_Chunk2);
    _this37 = _callSuper(this, DataStream_Chunk2);
    _this37.streamId = "";
    _this37.chunkIndex = protoInt64.zero;
    _this37.content = new Uint8Array(0);
    _this37.complete = false;
    _this37.version = 0;
    proto3.util.initPartial(data, _this37);
    return _this37;
  }
  _inherits(DataStream_Chunk2, _Message37);
  return _createClass(DataStream_Chunk2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new DataStream_Chunk2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new DataStream_Chunk2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new DataStream_Chunk2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(DataStream_Chunk2, a, b);
    }
  }]);
}(Message);
DataStream_Chunk.runtime = proto3;
DataStream_Chunk.typeName = "livekit.DataStream.Chunk";
DataStream_Chunk.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "stream_id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "chunk_index",
    kind: "scalar",
    T: 4
    /* ScalarType.UINT64 */
  }, {
    no: 3,
    name: "content",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  }, {
    no: 4,
    name: "complete",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 5,
    name: "version",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }, {
    no: 6,
    name: "iv",
    kind: "scalar",
    T: 12,
    opt: true
  }];
});
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var loglevel = { exports: {} };
(function(module) {
  (function(root, definition) {
    if (module.exports) {
      module.exports = definition();
    } else {
      root.log = definition();
    }
  })(commonjsGlobal, function() {
    var noop = function noop2() {
    };
    var undefinedType = "undefined";
    var isIE = (typeof window === "undefined" ? "undefined" : _typeof(window)) !== undefinedType && _typeof(window.navigator) !== undefinedType && /Trident\/|MSIE /.test(window.navigator.userAgent);
    var logMethods = ["trace", "debug", "info", "warn", "error"];
    var _loggersByName = {};
    var defaultLogger = null;
    function bindMethod(obj, methodName) {
      var method = obj[methodName];
      if (typeof method.bind === "function") {
        return method.bind(obj);
      } else {
        try {
          return Function.prototype.bind.call(method, obj);
        } catch (e) {
          return function() {
            return Function.prototype.apply.apply(method, [obj, arguments]);
          };
        }
      }
    }
    function traceForIE() {
      if (console.log) {
        if (console.log.apply) {
          console.log.apply(console, arguments);
        } else {
          Function.prototype.apply.apply(console.log, [console, arguments]);
        }
      }
      if (console.trace) console.trace();
    }
    function realMethod(methodName) {
      if (methodName === "debug") {
        methodName = "log";
      }
      if ((typeof console === "undefined" ? "undefined" : _typeof(console)) === undefinedType) {
        return false;
      } else if (methodName === "trace" && isIE) {
        return traceForIE;
      } else if (console[methodName] !== void 0) {
        return bindMethod(console, methodName);
      } else if (console.log !== void 0) {
        return bindMethod(console, "log");
      } else {
        return noop;
      }
    }
    function replaceLoggingMethods() {
      var level = this.getLevel();
      for (var i = 0; i < logMethods.length; i++) {
        var methodName = logMethods[i];
        this[methodName] = i < level ? noop : this.methodFactory(methodName, level, this.name);
      }
      this.log = this.debug;
      if ((typeof console === "undefined" ? "undefined" : _typeof(console)) === undefinedType && level < this.levels.SILENT) {
        return "No console available for logging";
      }
    }
    function enableLoggingWhenConsoleArrives(methodName) {
      return function() {
        if ((typeof console === "undefined" ? "undefined" : _typeof(console)) !== undefinedType) {
          replaceLoggingMethods.call(this);
          this[methodName].apply(this, arguments);
        }
      };
    }
    function defaultMethodFactory(methodName, _level, _loggerName) {
      return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);
    }
    function Logger(name, factory) {
      var self2 = this;
      var inheritedLevel;
      var defaultLevel;
      var userLevel;
      var storageKey = "loglevel";
      if (typeof name === "string") {
        storageKey += ":" + name;
      } else if (_typeof(name) === "symbol") {
        storageKey = void 0;
      }
      function persistLevelIfPossible(levelNum) {
        var levelName = (logMethods[levelNum] || "silent").toUpperCase();
        if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === undefinedType || !storageKey) return;
        try {
          window.localStorage[storageKey] = levelName;
          return;
        } catch (ignore) {
        }
        try {
          window.document.cookie = encodeURIComponent(storageKey) + "=" + levelName + ";";
        } catch (ignore) {
        }
      }
      function getPersistedLevel() {
        var storedLevel;
        if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === undefinedType || !storageKey) return;
        try {
          storedLevel = window.localStorage[storageKey];
        } catch (ignore) {
        }
        if (_typeof(storedLevel) === undefinedType) {
          try {
            var cookie = window.document.cookie;
            var cookieName = encodeURIComponent(storageKey);
            var location = cookie.indexOf(cookieName + "=");
            if (location !== -1) {
              storedLevel = /^([^;]+)/.exec(cookie.slice(location + cookieName.length + 1))[1];
            }
          } catch (ignore) {
          }
        }
        if (self2.levels[storedLevel] === void 0) {
          storedLevel = void 0;
        }
        return storedLevel;
      }
      function clearPersistedLevel() {
        if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === undefinedType || !storageKey) return;
        try {
          window.localStorage.removeItem(storageKey);
        } catch (ignore) {
        }
        try {
          window.document.cookie = encodeURIComponent(storageKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
        } catch (ignore) {
        }
      }
      function normalizeLevel(input) {
        var level = input;
        if (typeof level === "string" && self2.levels[level.toUpperCase()] !== void 0) {
          level = self2.levels[level.toUpperCase()];
        }
        if (typeof level === "number" && level >= 0 && level <= self2.levels.SILENT) {
          return level;
        } else {
          throw new TypeError("log.setLevel() called with invalid level: " + input);
        }
      }
      self2.name = name;
      self2.levels = {
        "TRACE": 0,
        "DEBUG": 1,
        "INFO": 2,
        "WARN": 3,
        "ERROR": 4,
        "SILENT": 5
      };
      self2.methodFactory = factory || defaultMethodFactory;
      self2.getLevel = function() {
        if (userLevel != null) {
          return userLevel;
        } else if (defaultLevel != null) {
          return defaultLevel;
        } else {
          return inheritedLevel;
        }
      };
      self2.setLevel = function(level, persist) {
        userLevel = normalizeLevel(level);
        if (persist !== false) {
          persistLevelIfPossible(userLevel);
        }
        return replaceLoggingMethods.call(self2);
      };
      self2.setDefaultLevel = function(level) {
        defaultLevel = normalizeLevel(level);
        if (!getPersistedLevel()) {
          self2.setLevel(level, false);
        }
      };
      self2.resetLevel = function() {
        userLevel = null;
        clearPersistedLevel();
        replaceLoggingMethods.call(self2);
      };
      self2.enableAll = function(persist) {
        self2.setLevel(self2.levels.TRACE, persist);
      };
      self2.disableAll = function(persist) {
        self2.setLevel(self2.levels.SILENT, persist);
      };
      self2.rebuild = function() {
        if (defaultLogger !== self2) {
          inheritedLevel = normalizeLevel(defaultLogger.getLevel());
        }
        replaceLoggingMethods.call(self2);
        if (defaultLogger === self2) {
          for (var childName in _loggersByName) {
            _loggersByName[childName].rebuild();
          }
        }
      };
      inheritedLevel = normalizeLevel(defaultLogger ? defaultLogger.getLevel() : "WARN");
      var initialLevel = getPersistedLevel();
      if (initialLevel != null) {
        userLevel = normalizeLevel(initialLevel);
      }
      replaceLoggingMethods.call(self2);
    }
    defaultLogger = new Logger();
    defaultLogger.getLogger = function getLogger2(name) {
      if (_typeof(name) !== "symbol" && typeof name !== "string" || name === "") {
        throw new TypeError("You must supply a name when creating a logger.");
      }
      var logger = _loggersByName[name];
      if (!logger) {
        logger = _loggersByName[name] = new Logger(name, defaultLogger.methodFactory);
      }
      return logger;
    };
    var _log = (typeof window === "undefined" ? "undefined" : _typeof(window)) !== undefinedType ? window.log : void 0;
    defaultLogger.noConflict = function() {
      if ((typeof window === "undefined" ? "undefined" : _typeof(window)) !== undefinedType && window.log === defaultLogger) {
        window.log = _log;
      }
      return defaultLogger;
    };
    defaultLogger.getLoggers = function getLoggers() {
      return _loggersByName;
    };
    defaultLogger["default"] = defaultLogger;
    return defaultLogger;
  });
})(loglevel);
var loglevelExports = loglevel.exports;
var LogLevel;
(function(LogLevel2) {
  LogLevel2[LogLevel2["trace"] = 0] = "trace";
  LogLevel2[LogLevel2["debug"] = 1] = "debug";
  LogLevel2[LogLevel2["info"] = 2] = "info";
  LogLevel2[LogLevel2["warn"] = 3] = "warn";
  LogLevel2[LogLevel2["error"] = 4] = "error";
  LogLevel2[LogLevel2["silent"] = 5] = "silent";
})(LogLevel || (LogLevel = {}));
var LoggerNames;
(function(LoggerNames2) {
  LoggerNames2["Default"] = "livekit";
  LoggerNames2["Room"] = "livekit-room";
  LoggerNames2["Participant"] = "livekit-participant";
  LoggerNames2["Track"] = "livekit-track";
  LoggerNames2["Publication"] = "livekit-track-publication";
  LoggerNames2["Engine"] = "livekit-engine";
  LoggerNames2["Signal"] = "livekit-signal";
  LoggerNames2["PCManager"] = "livekit-pc-manager";
  LoggerNames2["PCTransport"] = "livekit-pc-transport";
  LoggerNames2["E2EE"] = "lk-e2ee";
})(LoggerNames || (LoggerNames = {}));
var livekitLogger = loglevelExports.getLogger("livekit");
var livekitLoggers = Object.values(LoggerNames).map(function(name) {
  return loglevelExports.getLogger(name);
});
livekitLogger.setDefaultLevel(LogLevel.info);
function getLogger(name) {
  var logger = loglevelExports.getLogger(name);
  logger.setDefaultLevel(livekitLogger.getLevel());
  return logger;
}
function setLogLevel(level, loggerName) {
  if (loggerName) {
    loglevelExports.getLogger(loggerName).setLevel(level);
  } else {
    var _iterator = _createForOfIteratorHelper(livekitLoggers), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var logger = _step.value;
        logger.setLevel(level);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
}
function setLogExtension(extension, logger) {
  var loggers = logger ? [logger] : livekitLoggers;
  loggers.forEach(function(logR) {
    var originalFactory = logR.methodFactory;
    logR.methodFactory = function(methodName, configLevel, loggerName) {
      var rawMethod = originalFactory(methodName, configLevel, loggerName);
      var logLevel = LogLevel[methodName];
      var needLog = logLevel >= configLevel && logLevel < LogLevel.silent;
      return function(msg, context) {
        if (context) rawMethod(msg, context);
        else rawMethod(msg);
        if (needLog) {
          extension(logLevel, msg, context);
        }
      };
    };
    logR.setLevel(logR.getLevel());
  });
}
var workerLogger = loglevelExports.getLogger("lk-e2ee");
var maxRetryDelay = 7e3;
var DEFAULT_RETRY_DELAYS_IN_MS = [0, 300, 2 * 2 * 300, 3 * 3 * 300, 4 * 4 * 300, maxRetryDelay, maxRetryDelay, maxRetryDelay, maxRetryDelay, maxRetryDelay];
var DefaultReconnectPolicy = function() {
  function DefaultReconnectPolicy2(retryDelays) {
    _classCallCheck(this, DefaultReconnectPolicy2);
    this._retryDelays = retryDelays !== void 0 ? _toConsumableArray(retryDelays) : DEFAULT_RETRY_DELAYS_IN_MS;
  }
  return _createClass(DefaultReconnectPolicy2, [{
    key: "nextRetryDelayInMs",
    value: function nextRetryDelayInMs(context) {
      if (context.retryCount >= this._retryDelays.length) return null;
      var retryDelay = this._retryDelays[context.retryCount];
      if (context.retryCount <= 1) return retryDelay;
      return retryDelay + Math.random() * 1e3;
    }
  }]);
}();
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
var SignalTarget;
(function(SignalTarget2) {
  SignalTarget2[SignalTarget2["PUBLISHER"] = 0] = "PUBLISHER";
  SignalTarget2[SignalTarget2["SUBSCRIBER"] = 1] = "SUBSCRIBER";
})(SignalTarget || (SignalTarget = {}));
proto3.util.setEnumType(SignalTarget, "livekit.SignalTarget", [{
  no: 0,
  name: "PUBLISHER"
}, {
  no: 1,
  name: "SUBSCRIBER"
}]);
var StreamState;
(function(StreamState2) {
  StreamState2[StreamState2["ACTIVE"] = 0] = "ACTIVE";
  StreamState2[StreamState2["PAUSED"] = 1] = "PAUSED";
})(StreamState || (StreamState = {}));
proto3.util.setEnumType(StreamState, "livekit.StreamState", [{
  no: 0,
  name: "ACTIVE"
}, {
  no: 1,
  name: "PAUSED"
}]);
var CandidateProtocol;
(function(CandidateProtocol2) {
  CandidateProtocol2[CandidateProtocol2["UDP"] = 0] = "UDP";
  CandidateProtocol2[CandidateProtocol2["TCP"] = 1] = "TCP";
  CandidateProtocol2[CandidateProtocol2["TLS"] = 2] = "TLS";
})(CandidateProtocol || (CandidateProtocol = {}));
proto3.util.setEnumType(CandidateProtocol, "livekit.CandidateProtocol", [{
  no: 0,
  name: "UDP"
}, {
  no: 1,
  name: "TCP"
}, {
  no: 2,
  name: "TLS"
}]);
var RequestType;
(function(RequestType2) {
  RequestType2[RequestType2["AddAudioTrack"] = 0] = "AddAudioTrack";
  RequestType2[RequestType2["AddVideoTrack"] = 1] = "AddVideoTrack";
  RequestType2[RequestType2["Join"] = 2] = "Join";
  RequestType2[RequestType2["Leave"] = 3] = "Leave";
  RequestType2[RequestType2["MuteAudio"] = 4] = "MuteAudio";
  RequestType2[RequestType2["MuteVideo"] = 5] = "MuteVideo";
  RequestType2[RequestType2["UnmuteAudio"] = 6] = "UnmuteAudio";
  RequestType2[RequestType2["UnmuteVideo"] = 7] = "UnmuteVideo";
})(RequestType || (RequestType = {}));
proto3.util.setEnumType(RequestType, "livekit.RequestType", [{
  no: 0,
  name: "AddAudioTrack"
}, {
  no: 1,
  name: "AddVideoTrack"
}, {
  no: 2,
  name: "Join"
}, {
  no: 3,
  name: "Leave"
}, {
  no: 4,
  name: "MuteAudio"
}, {
  no: 5,
  name: "MuteVideo"
}, {
  no: 6,
  name: "UnmuteAudio"
}, {
  no: 7,
  name: "UnmuteVideo"
}]);
var SignalRequest = function(_Message) {
  function SignalRequest2(data) {
    var _this;
    _classCallCheck(this, SignalRequest2);
    _this = _callSuper(this, SignalRequest2);
    _this.message = {
      "case": void 0
    };
    proto3.util.initPartial(data, _this);
    return _this;
  }
  _inherits(SignalRequest2, _Message);
  return _createClass(SignalRequest2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new SignalRequest2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new SignalRequest2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new SignalRequest2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(SignalRequest2, a, b);
    }
  }]);
}(Message);
SignalRequest.runtime = proto3;
SignalRequest.typeName = "livekit.SignalRequest";
SignalRequest.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "offer",
    kind: "message",
    T: SessionDescription,
    oneof: "message"
  }, {
    no: 2,
    name: "answer",
    kind: "message",
    T: SessionDescription,
    oneof: "message"
  }, {
    no: 3,
    name: "trickle",
    kind: "message",
    T: TrickleRequest,
    oneof: "message"
  }, {
    no: 4,
    name: "add_track",
    kind: "message",
    T: AddTrackRequest,
    oneof: "message"
  }, {
    no: 5,
    name: "mute",
    kind: "message",
    T: MuteTrackRequest,
    oneof: "message"
  }, {
    no: 6,
    name: "subscription",
    kind: "message",
    T: UpdateSubscription,
    oneof: "message"
  }, {
    no: 7,
    name: "track_setting",
    kind: "message",
    T: UpdateTrackSettings,
    oneof: "message"
  }, {
    no: 8,
    name: "leave",
    kind: "message",
    T: LeaveRequest,
    oneof: "message"
  }, {
    no: 10,
    name: "update_layers",
    kind: "message",
    T: UpdateVideoLayers,
    oneof: "message"
  }, {
    no: 11,
    name: "subscription_permission",
    kind: "message",
    T: SubscriptionPermission,
    oneof: "message"
  }, {
    no: 12,
    name: "sync_state",
    kind: "message",
    T: SyncState,
    oneof: "message"
  }, {
    no: 13,
    name: "simulate",
    kind: "message",
    T: SimulateScenario,
    oneof: "message"
  }, {
    no: 14,
    name: "ping",
    kind: "scalar",
    T: 3,
    oneof: "message"
  }, {
    no: 15,
    name: "update_metadata",
    kind: "message",
    T: UpdateParticipantMetadata,
    oneof: "message"
  }, {
    no: 16,
    name: "ping_req",
    kind: "message",
    T: Ping,
    oneof: "message"
  }, {
    no: 17,
    name: "update_audio_track",
    kind: "message",
    T: UpdateLocalAudioTrack,
    oneof: "message"
  }, {
    no: 18,
    name: "update_video_track",
    kind: "message",
    T: UpdateLocalVideoTrack,
    oneof: "message"
  }, {
    no: 19,
    name: "health_check",
    kind: "message",
    T: HealthCheck,
    oneof: "message"
  }];
});
var SignalResponse = function(_Message2) {
  function SignalResponse2(data) {
    var _this2;
    _classCallCheck(this, SignalResponse2);
    _this2 = _callSuper(this, SignalResponse2);
    _this2.message = {
      "case": void 0
    };
    proto3.util.initPartial(data, _this2);
    return _this2;
  }
  _inherits(SignalResponse2, _Message2);
  return _createClass(SignalResponse2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new SignalResponse2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new SignalResponse2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new SignalResponse2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(SignalResponse2, a, b);
    }
  }]);
}(Message);
SignalResponse.runtime = proto3;
SignalResponse.typeName = "livekit.SignalResponse";
SignalResponse.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "join",
    kind: "message",
    T: JoinResponse,
    oneof: "message"
  }, {
    no: 2,
    name: "answer",
    kind: "message",
    T: SessionDescription,
    oneof: "message"
  }, {
    no: 3,
    name: "offer",
    kind: "message",
    T: SessionDescription,
    oneof: "message"
  }, {
    no: 4,
    name: "trickle",
    kind: "message",
    T: TrickleRequest,
    oneof: "message"
  }, {
    no: 5,
    name: "update",
    kind: "message",
    T: ParticipantUpdate,
    oneof: "message"
  }, {
    no: 6,
    name: "track_published",
    kind: "message",
    T: TrackPublishedResponse,
    oneof: "message"
  }, {
    no: 8,
    name: "leave",
    kind: "message",
    T: LeaveRequest,
    oneof: "message"
  }, {
    no: 9,
    name: "mute",
    kind: "message",
    T: MuteTrackRequest,
    oneof: "message"
  }, {
    no: 10,
    name: "speakers_changed",
    kind: "message",
    T: SpeakersChanged,
    oneof: "message"
  }, {
    no: 11,
    name: "room_update",
    kind: "message",
    T: RoomUpdate,
    oneof: "message"
  }, {
    no: 12,
    name: "connection_quality",
    kind: "message",
    T: ConnectionQualityUpdate,
    oneof: "message"
  }, {
    no: 13,
    name: "stream_state_update",
    kind: "message",
    T: StreamStateUpdate,
    oneof: "message"
  }, {
    no: 14,
    name: "subscribed_quality_update",
    kind: "message",
    T: SubscribedQualityUpdate,
    oneof: "message"
  }, {
    no: 15,
    name: "subscription_permission_update",
    kind: "message",
    T: SubscriptionPermissionUpdate,
    oneof: "message"
  }, {
    no: 16,
    name: "refresh_token",
    kind: "scalar",
    T: 9,
    oneof: "message"
  }, {
    no: 17,
    name: "track_unpublished",
    kind: "message",
    T: TrackUnpublishedResponse,
    oneof: "message"
  }, {
    no: 18,
    name: "pong",
    kind: "scalar",
    T: 3,
    oneof: "message"
  }, {
    no: 19,
    name: "reconnect",
    kind: "message",
    T: ReconnectResponse,
    oneof: "message"
  }, {
    no: 20,
    name: "pong_resp",
    kind: "message",
    T: Pong,
    oneof: "message"
  }, {
    no: 21,
    name: "subscription_response",
    kind: "message",
    T: SubscriptionResponse,
    oneof: "message"
  }, {
    no: 22,
    name: "health_check_response",
    kind: "message",
    T: HealthCheckResponse,
    oneof: "message"
  }, {
    no: 23,
    name: "request_response",
    kind: "message",
    T: RequestResponse,
    oneof: "message"
  }, {
    no: 24,
    name: "track_subscribed",
    kind: "message",
    T: TrackSubscribed,
    oneof: "message"
  }];
});
var SimulcastCodec = function(_Message3) {
  function SimulcastCodec2(data) {
    var _this3;
    _classCallCheck(this, SimulcastCodec2);
    _this3 = _callSuper(this, SimulcastCodec2);
    _this3.codec = "";
    _this3.cid = "";
    proto3.util.initPartial(data, _this3);
    return _this3;
  }
  _inherits(SimulcastCodec2, _Message3);
  return _createClass(SimulcastCodec2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new SimulcastCodec2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new SimulcastCodec2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new SimulcastCodec2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(SimulcastCodec2, a, b);
    }
  }]);
}(Message);
SimulcastCodec.runtime = proto3;
SimulcastCodec.typeName = "livekit.SimulcastCodec";
SimulcastCodec.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "codec",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "cid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }];
});
var AddTrackRequest = function(_Message4) {
  function AddTrackRequest2(data) {
    var _this4;
    _classCallCheck(this, AddTrackRequest2);
    _this4 = _callSuper(this, AddTrackRequest2);
    _this4.cid = "";
    _this4.name = "";
    _this4.type = TrackType.AUDIO;
    _this4.width = 0;
    _this4.height = 0;
    _this4.muted = false;
    _this4.disableDtx = false;
    _this4.source = TrackSource.UNKNOWN;
    _this4.layers = [];
    _this4.simulcastCodecs = [];
    _this4.sid = "";
    _this4.stereo = false;
    _this4.disableRed = false;
    _this4.encryption = Encryption_Type.NONE;
    _this4.stream = "";
    proto3.util.initPartial(data, _this4);
    return _this4;
  }
  _inherits(AddTrackRequest2, _Message4);
  return _createClass(AddTrackRequest2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new AddTrackRequest2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new AddTrackRequest2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new AddTrackRequest2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(AddTrackRequest2, a, b);
    }
  }]);
}(Message);
AddTrackRequest.runtime = proto3;
AddTrackRequest.typeName = "livekit.AddTrackRequest";
AddTrackRequest.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "cid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "type",
    kind: "enum",
    T: proto3.getEnumType(TrackType)
  }, {
    no: 4,
    name: "width",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 5,
    name: "height",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 6,
    name: "muted",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 7,
    name: "disable_dtx",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 8,
    name: "source",
    kind: "enum",
    T: proto3.getEnumType(TrackSource)
  }, {
    no: 9,
    name: "layers",
    kind: "message",
    T: VideoLayer,
    repeated: true
  }, {
    no: 10,
    name: "simulcast_codecs",
    kind: "message",
    T: SimulcastCodec,
    repeated: true
  }, {
    no: 11,
    name: "sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 12,
    name: "stereo",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 13,
    name: "disable_red",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 14,
    name: "encryption",
    kind: "enum",
    T: proto3.getEnumType(Encryption_Type)
  }, {
    no: 15,
    name: "stream",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }];
});
var TrickleRequest = function(_Message5) {
  function TrickleRequest2(data) {
    var _this5;
    _classCallCheck(this, TrickleRequest2);
    _this5 = _callSuper(this, TrickleRequest2);
    _this5.candidateInit = "";
    _this5.target = SignalTarget.PUBLISHER;
    _this5["final"] = false;
    proto3.util.initPartial(data, _this5);
    return _this5;
  }
  _inherits(TrickleRequest2, _Message5);
  return _createClass(TrickleRequest2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new TrickleRequest2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new TrickleRequest2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new TrickleRequest2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(TrickleRequest2, a, b);
    }
  }]);
}(Message);
TrickleRequest.runtime = proto3;
TrickleRequest.typeName = "livekit.TrickleRequest";
TrickleRequest.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "candidateInit",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "target",
    kind: "enum",
    T: proto3.getEnumType(SignalTarget)
  }, {
    no: 3,
    name: "final",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }];
});
var MuteTrackRequest = function(_Message6) {
  function MuteTrackRequest2(data) {
    var _this6;
    _classCallCheck(this, MuteTrackRequest2);
    _this6 = _callSuper(this, MuteTrackRequest2);
    _this6.sid = "";
    _this6.muted = false;
    proto3.util.initPartial(data, _this6);
    return _this6;
  }
  _inherits(MuteTrackRequest2, _Message6);
  return _createClass(MuteTrackRequest2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new MuteTrackRequest2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new MuteTrackRequest2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new MuteTrackRequest2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(MuteTrackRequest2, a, b);
    }
  }]);
}(Message);
MuteTrackRequest.runtime = proto3;
MuteTrackRequest.typeName = "livekit.MuteTrackRequest";
MuteTrackRequest.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "muted",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }];
});
var JoinResponse = function(_Message7) {
  function JoinResponse2(data) {
    var _this7;
    _classCallCheck(this, JoinResponse2);
    _this7 = _callSuper(this, JoinResponse2);
    _this7.otherParticipants = [];
    _this7.serverVersion = "";
    _this7.iceServers = [];
    _this7.subscriberPrimary = false;
    _this7.alternativeUrl = "";
    _this7.serverRegion = "";
    _this7.pingTimeout = 0;
    _this7.pingInterval = 0;
    _this7.sifTrailer = new Uint8Array(0);
    _this7.enabledPublishCodecs = [];
    _this7.fastPublish = false;
    proto3.util.initPartial(data, _this7);
    return _this7;
  }
  _inherits(JoinResponse2, _Message7);
  return _createClass(JoinResponse2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new JoinResponse2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new JoinResponse2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new JoinResponse2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(JoinResponse2, a, b);
    }
  }]);
}(Message);
JoinResponse.runtime = proto3;
JoinResponse.typeName = "livekit.JoinResponse";
JoinResponse.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "room",
    kind: "message",
    T: Room$1
  }, {
    no: 2,
    name: "participant",
    kind: "message",
    T: ParticipantInfo
  }, {
    no: 3,
    name: "other_participants",
    kind: "message",
    T: ParticipantInfo,
    repeated: true
  }, {
    no: 4,
    name: "server_version",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 5,
    name: "ice_servers",
    kind: "message",
    T: ICEServer,
    repeated: true
  }, {
    no: 6,
    name: "subscriber_primary",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 7,
    name: "alternative_url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 8,
    name: "client_configuration",
    kind: "message",
    T: ClientConfiguration
  }, {
    no: 9,
    name: "server_region",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 10,
    name: "ping_timeout",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }, {
    no: 11,
    name: "ping_interval",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }, {
    no: 12,
    name: "server_info",
    kind: "message",
    T: ServerInfo
  }, {
    no: 13,
    name: "sif_trailer",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  }, {
    no: 14,
    name: "enabled_publish_codecs",
    kind: "message",
    T: Codec,
    repeated: true
  }, {
    no: 15,
    name: "fast_publish",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }];
});
var ReconnectResponse = function(_Message8) {
  function ReconnectResponse2(data) {
    var _this8;
    _classCallCheck(this, ReconnectResponse2);
    _this8 = _callSuper(this, ReconnectResponse2);
    _this8.iceServers = [];
    proto3.util.initPartial(data, _this8);
    return _this8;
  }
  _inherits(ReconnectResponse2, _Message8);
  return _createClass(ReconnectResponse2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new ReconnectResponse2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new ReconnectResponse2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new ReconnectResponse2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(ReconnectResponse2, a, b);
    }
  }]);
}(Message);
ReconnectResponse.runtime = proto3;
ReconnectResponse.typeName = "livekit.ReconnectResponse";
ReconnectResponse.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "ice_servers",
    kind: "message",
    T: ICEServer,
    repeated: true
  }, {
    no: 2,
    name: "client_configuration",
    kind: "message",
    T: ClientConfiguration
  }];
});
var TrackPublishedResponse = function(_Message9) {
  function TrackPublishedResponse2(data) {
    var _this9;
    _classCallCheck(this, TrackPublishedResponse2);
    _this9 = _callSuper(this, TrackPublishedResponse2);
    _this9.cid = "";
    proto3.util.initPartial(data, _this9);
    return _this9;
  }
  _inherits(TrackPublishedResponse2, _Message9);
  return _createClass(TrackPublishedResponse2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new TrackPublishedResponse2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new TrackPublishedResponse2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new TrackPublishedResponse2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(TrackPublishedResponse2, a, b);
    }
  }]);
}(Message);
TrackPublishedResponse.runtime = proto3;
TrackPublishedResponse.typeName = "livekit.TrackPublishedResponse";
TrackPublishedResponse.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "cid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "track",
    kind: "message",
    T: TrackInfo
  }];
});
var TrackUnpublishedResponse = function(_Message0) {
  function TrackUnpublishedResponse2(data) {
    var _this0;
    _classCallCheck(this, TrackUnpublishedResponse2);
    _this0 = _callSuper(this, TrackUnpublishedResponse2);
    _this0.trackSid = "";
    proto3.util.initPartial(data, _this0);
    return _this0;
  }
  _inherits(TrackUnpublishedResponse2, _Message0);
  return _createClass(TrackUnpublishedResponse2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new TrackUnpublishedResponse2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new TrackUnpublishedResponse2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new TrackUnpublishedResponse2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(TrackUnpublishedResponse2, a, b);
    }
  }]);
}(Message);
TrackUnpublishedResponse.runtime = proto3;
TrackUnpublishedResponse.typeName = "livekit.TrackUnpublishedResponse";
TrackUnpublishedResponse.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "track_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }];
});
var SessionDescription = function(_Message1) {
  function SessionDescription2(data) {
    var _this1;
    _classCallCheck(this, SessionDescription2);
    _this1 = _callSuper(this, SessionDescription2);
    _this1.type = "";
    _this1.sdp = "";
    proto3.util.initPartial(data, _this1);
    return _this1;
  }
  _inherits(SessionDescription2, _Message1);
  return _createClass(SessionDescription2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new SessionDescription2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new SessionDescription2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new SessionDescription2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(SessionDescription2, a, b);
    }
  }]);
}(Message);
SessionDescription.runtime = proto3;
SessionDescription.typeName = "livekit.SessionDescription";
SessionDescription.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "type",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "sdp",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }];
});
var ParticipantUpdate = function(_Message10) {
  function ParticipantUpdate2(data) {
    var _this10;
    _classCallCheck(this, ParticipantUpdate2);
    _this10 = _callSuper(this, ParticipantUpdate2);
    _this10.participants = [];
    proto3.util.initPartial(data, _this10);
    return _this10;
  }
  _inherits(ParticipantUpdate2, _Message10);
  return _createClass(ParticipantUpdate2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new ParticipantUpdate2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new ParticipantUpdate2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new ParticipantUpdate2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(ParticipantUpdate2, a, b);
    }
  }]);
}(Message);
ParticipantUpdate.runtime = proto3;
ParticipantUpdate.typeName = "livekit.ParticipantUpdate";
ParticipantUpdate.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "participants",
    kind: "message",
    T: ParticipantInfo,
    repeated: true
  }];
});
var UpdateSubscription = function(_Message11) {
  function UpdateSubscription2(data) {
    var _this11;
    _classCallCheck(this, UpdateSubscription2);
    _this11 = _callSuper(this, UpdateSubscription2);
    _this11.trackSids = [];
    _this11.subscribe = false;
    _this11.participantTracks = [];
    proto3.util.initPartial(data, _this11);
    return _this11;
  }
  _inherits(UpdateSubscription2, _Message11);
  return _createClass(UpdateSubscription2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new UpdateSubscription2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new UpdateSubscription2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new UpdateSubscription2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(UpdateSubscription2, a, b);
    }
  }]);
}(Message);
UpdateSubscription.runtime = proto3;
UpdateSubscription.typeName = "livekit.UpdateSubscription";
UpdateSubscription.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "track_sids",
    kind: "scalar",
    T: 9,
    repeated: true
  }, {
    no: 2,
    name: "subscribe",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 3,
    name: "participant_tracks",
    kind: "message",
    T: ParticipantTracks,
    repeated: true
  }];
});
var UpdateTrackSettings = function(_Message12) {
  function UpdateTrackSettings2(data) {
    var _this12;
    _classCallCheck(this, UpdateTrackSettings2);
    _this12 = _callSuper(this, UpdateTrackSettings2);
    _this12.trackSids = [];
    _this12.disabled = false;
    _this12.quality = VideoQuality$1.LOW;
    _this12.width = 0;
    _this12.height = 0;
    _this12.fps = 0;
    _this12.priority = 0;
    proto3.util.initPartial(data, _this12);
    return _this12;
  }
  _inherits(UpdateTrackSettings2, _Message12);
  return _createClass(UpdateTrackSettings2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new UpdateTrackSettings2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new UpdateTrackSettings2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new UpdateTrackSettings2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(UpdateTrackSettings2, a, b);
    }
  }]);
}(Message);
UpdateTrackSettings.runtime = proto3;
UpdateTrackSettings.typeName = "livekit.UpdateTrackSettings";
UpdateTrackSettings.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "track_sids",
    kind: "scalar",
    T: 9,
    repeated: true
  }, {
    no: 3,
    name: "disabled",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 4,
    name: "quality",
    kind: "enum",
    T: proto3.getEnumType(VideoQuality$1)
  }, {
    no: 5,
    name: "width",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 6,
    name: "height",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 7,
    name: "fps",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 8,
    name: "priority",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }];
});
var UpdateLocalAudioTrack = function(_Message13) {
  function UpdateLocalAudioTrack2(data) {
    var _this13;
    _classCallCheck(this, UpdateLocalAudioTrack2);
    _this13 = _callSuper(this, UpdateLocalAudioTrack2);
    _this13.trackSid = "";
    _this13.features = [];
    proto3.util.initPartial(data, _this13);
    return _this13;
  }
  _inherits(UpdateLocalAudioTrack2, _Message13);
  return _createClass(UpdateLocalAudioTrack2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new UpdateLocalAudioTrack2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new UpdateLocalAudioTrack2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new UpdateLocalAudioTrack2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(UpdateLocalAudioTrack2, a, b);
    }
  }]);
}(Message);
UpdateLocalAudioTrack.runtime = proto3;
UpdateLocalAudioTrack.typeName = "livekit.UpdateLocalAudioTrack";
UpdateLocalAudioTrack.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "track_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "features",
    kind: "enum",
    T: proto3.getEnumType(AudioTrackFeature),
    repeated: true
  }];
});
var UpdateLocalVideoTrack = function(_Message14) {
  function UpdateLocalVideoTrack2(data) {
    var _this14;
    _classCallCheck(this, UpdateLocalVideoTrack2);
    _this14 = _callSuper(this, UpdateLocalVideoTrack2);
    _this14.trackSid = "";
    _this14.width = 0;
    _this14.height = 0;
    proto3.util.initPartial(data, _this14);
    return _this14;
  }
  _inherits(UpdateLocalVideoTrack2, _Message14);
  return _createClass(UpdateLocalVideoTrack2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new UpdateLocalVideoTrack2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new UpdateLocalVideoTrack2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new UpdateLocalVideoTrack2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(UpdateLocalVideoTrack2, a, b);
    }
  }]);
}(Message);
UpdateLocalVideoTrack.runtime = proto3;
UpdateLocalVideoTrack.typeName = "livekit.UpdateLocalVideoTrack";
UpdateLocalVideoTrack.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "track_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "width",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 3,
    name: "height",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }];
});
var LeaveRequest = function(_Message15) {
  function LeaveRequest2(data) {
    var _this15;
    _classCallCheck(this, LeaveRequest2);
    _this15 = _callSuper(this, LeaveRequest2);
    _this15.canReconnect = false;
    _this15.reason = DisconnectReason.UNKNOWN_REASON;
    _this15.action = LeaveRequest_Action.DISCONNECT;
    proto3.util.initPartial(data, _this15);
    return _this15;
  }
  _inherits(LeaveRequest2, _Message15);
  return _createClass(LeaveRequest2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new LeaveRequest2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new LeaveRequest2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new LeaveRequest2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(LeaveRequest2, a, b);
    }
  }]);
}(Message);
LeaveRequest.runtime = proto3;
LeaveRequest.typeName = "livekit.LeaveRequest";
LeaveRequest.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "can_reconnect",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 2,
    name: "reason",
    kind: "enum",
    T: proto3.getEnumType(DisconnectReason)
  }, {
    no: 3,
    name: "action",
    kind: "enum",
    T: proto3.getEnumType(LeaveRequest_Action)
  }, {
    no: 4,
    name: "regions",
    kind: "message",
    T: RegionSettings
  }];
});
var LeaveRequest_Action;
(function(LeaveRequest_Action2) {
  LeaveRequest_Action2[LeaveRequest_Action2["DISCONNECT"] = 0] = "DISCONNECT";
  LeaveRequest_Action2[LeaveRequest_Action2["RESUME"] = 1] = "RESUME";
  LeaveRequest_Action2[LeaveRequest_Action2["RECONNECT"] = 2] = "RECONNECT";
})(LeaveRequest_Action || (LeaveRequest_Action = {}));
proto3.util.setEnumType(LeaveRequest_Action, "livekit.LeaveRequest.Action", [{
  no: 0,
  name: "DISCONNECT"
}, {
  no: 1,
  name: "RESUME"
}, {
  no: 2,
  name: "RECONNECT"
}]);
var UpdateVideoLayers = function(_Message16) {
  function UpdateVideoLayers2(data) {
    var _this16;
    _classCallCheck(this, UpdateVideoLayers2);
    _this16 = _callSuper(this, UpdateVideoLayers2);
    _this16.trackSid = "";
    _this16.layers = [];
    proto3.util.initPartial(data, _this16);
    return _this16;
  }
  _inherits(UpdateVideoLayers2, _Message16);
  return _createClass(UpdateVideoLayers2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new UpdateVideoLayers2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new UpdateVideoLayers2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new UpdateVideoLayers2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(UpdateVideoLayers2, a, b);
    }
  }]);
}(Message);
UpdateVideoLayers.runtime = proto3;
UpdateVideoLayers.typeName = "livekit.UpdateVideoLayers";
UpdateVideoLayers.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "track_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "layers",
    kind: "message",
    T: VideoLayer,
    repeated: true
  }];
});
var UpdateParticipantMetadata = function(_Message17) {
  function UpdateParticipantMetadata2(data) {
    var _this17;
    _classCallCheck(this, UpdateParticipantMetadata2);
    _this17 = _callSuper(this, UpdateParticipantMetadata2);
    _this17.metadata = "";
    _this17.name = "";
    _this17.attributes = {};
    _this17.requestId = 0;
    proto3.util.initPartial(data, _this17);
    return _this17;
  }
  _inherits(UpdateParticipantMetadata2, _Message17);
  return _createClass(UpdateParticipantMetadata2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new UpdateParticipantMetadata2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new UpdateParticipantMetadata2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new UpdateParticipantMetadata2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(UpdateParticipantMetadata2, a, b);
    }
  }]);
}(Message);
UpdateParticipantMetadata.runtime = proto3;
UpdateParticipantMetadata.typeName = "livekit.UpdateParticipantMetadata";
UpdateParticipantMetadata.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "metadata",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "attributes",
    kind: "map",
    K: 9,
    V: {
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  }, {
    no: 4,
    name: "request_id",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }];
});
var ICEServer = function(_Message18) {
  function ICEServer2(data) {
    var _this18;
    _classCallCheck(this, ICEServer2);
    _this18 = _callSuper(this, ICEServer2);
    _this18.urls = [];
    _this18.username = "";
    _this18.credential = "";
    proto3.util.initPartial(data, _this18);
    return _this18;
  }
  _inherits(ICEServer2, _Message18);
  return _createClass(ICEServer2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new ICEServer2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new ICEServer2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new ICEServer2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(ICEServer2, a, b);
    }
  }]);
}(Message);
ICEServer.runtime = proto3;
ICEServer.typeName = "livekit.ICEServer";
ICEServer.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "urls",
    kind: "scalar",
    T: 9,
    repeated: true
  }, {
    no: 2,
    name: "username",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "credential",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }];
});
var SpeakersChanged = function(_Message19) {
  function SpeakersChanged2(data) {
    var _this19;
    _classCallCheck(this, SpeakersChanged2);
    _this19 = _callSuper(this, SpeakersChanged2);
    _this19.speakers = [];
    proto3.util.initPartial(data, _this19);
    return _this19;
  }
  _inherits(SpeakersChanged2, _Message19);
  return _createClass(SpeakersChanged2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new SpeakersChanged2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new SpeakersChanged2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new SpeakersChanged2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(SpeakersChanged2, a, b);
    }
  }]);
}(Message);
SpeakersChanged.runtime = proto3;
SpeakersChanged.typeName = "livekit.SpeakersChanged";
SpeakersChanged.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "speakers",
    kind: "message",
    T: SpeakerInfo,
    repeated: true
  }];
});
var RoomUpdate = function(_Message20) {
  function RoomUpdate2(data) {
    var _this20;
    _classCallCheck(this, RoomUpdate2);
    _this20 = _callSuper(this, RoomUpdate2);
    proto3.util.initPartial(data, _this20);
    return _this20;
  }
  _inherits(RoomUpdate2, _Message20);
  return _createClass(RoomUpdate2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new RoomUpdate2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new RoomUpdate2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new RoomUpdate2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(RoomUpdate2, a, b);
    }
  }]);
}(Message);
RoomUpdate.runtime = proto3;
RoomUpdate.typeName = "livekit.RoomUpdate";
RoomUpdate.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "room",
    kind: "message",
    T: Room$1
  }];
});
var ConnectionQualityInfo = function(_Message21) {
  function ConnectionQualityInfo2(data) {
    var _this21;
    _classCallCheck(this, ConnectionQualityInfo2);
    _this21 = _callSuper(this, ConnectionQualityInfo2);
    _this21.participantSid = "";
    _this21.quality = ConnectionQuality$1.POOR;
    _this21.score = 0;
    proto3.util.initPartial(data, _this21);
    return _this21;
  }
  _inherits(ConnectionQualityInfo2, _Message21);
  return _createClass(ConnectionQualityInfo2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new ConnectionQualityInfo2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new ConnectionQualityInfo2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new ConnectionQualityInfo2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(ConnectionQualityInfo2, a, b);
    }
  }]);
}(Message);
ConnectionQualityInfo.runtime = proto3;
ConnectionQualityInfo.typeName = "livekit.ConnectionQualityInfo";
ConnectionQualityInfo.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "participant_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "quality",
    kind: "enum",
    T: proto3.getEnumType(ConnectionQuality$1)
  }, {
    no: 3,
    name: "score",
    kind: "scalar",
    T: 2
    /* ScalarType.FLOAT */
  }];
});
var ConnectionQualityUpdate = function(_Message22) {
  function ConnectionQualityUpdate2(data) {
    var _this22;
    _classCallCheck(this, ConnectionQualityUpdate2);
    _this22 = _callSuper(this, ConnectionQualityUpdate2);
    _this22.updates = [];
    proto3.util.initPartial(data, _this22);
    return _this22;
  }
  _inherits(ConnectionQualityUpdate2, _Message22);
  return _createClass(ConnectionQualityUpdate2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new ConnectionQualityUpdate2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new ConnectionQualityUpdate2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new ConnectionQualityUpdate2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(ConnectionQualityUpdate2, a, b);
    }
  }]);
}(Message);
ConnectionQualityUpdate.runtime = proto3;
ConnectionQualityUpdate.typeName = "livekit.ConnectionQualityUpdate";
ConnectionQualityUpdate.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "updates",
    kind: "message",
    T: ConnectionQualityInfo,
    repeated: true
  }];
});
var StreamStateInfo = function(_Message23) {
  function StreamStateInfo2(data) {
    var _this23;
    _classCallCheck(this, StreamStateInfo2);
    _this23 = _callSuper(this, StreamStateInfo2);
    _this23.participantSid = "";
    _this23.trackSid = "";
    _this23.state = StreamState.ACTIVE;
    proto3.util.initPartial(data, _this23);
    return _this23;
  }
  _inherits(StreamStateInfo2, _Message23);
  return _createClass(StreamStateInfo2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new StreamStateInfo2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new StreamStateInfo2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new StreamStateInfo2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(StreamStateInfo2, a, b);
    }
  }]);
}(Message);
StreamStateInfo.runtime = proto3;
StreamStateInfo.typeName = "livekit.StreamStateInfo";
StreamStateInfo.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "participant_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "track_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "state",
    kind: "enum",
    T: proto3.getEnumType(StreamState)
  }];
});
var StreamStateUpdate = function(_Message24) {
  function StreamStateUpdate2(data) {
    var _this24;
    _classCallCheck(this, StreamStateUpdate2);
    _this24 = _callSuper(this, StreamStateUpdate2);
    _this24.streamStates = [];
    proto3.util.initPartial(data, _this24);
    return _this24;
  }
  _inherits(StreamStateUpdate2, _Message24);
  return _createClass(StreamStateUpdate2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new StreamStateUpdate2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new StreamStateUpdate2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new StreamStateUpdate2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(StreamStateUpdate2, a, b);
    }
  }]);
}(Message);
StreamStateUpdate.runtime = proto3;
StreamStateUpdate.typeName = "livekit.StreamStateUpdate";
StreamStateUpdate.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "stream_states",
    kind: "message",
    T: StreamStateInfo,
    repeated: true
  }];
});
var SubscribedQuality = function(_Message25) {
  function SubscribedQuality2(data) {
    var _this25;
    _classCallCheck(this, SubscribedQuality2);
    _this25 = _callSuper(this, SubscribedQuality2);
    _this25.quality = VideoQuality$1.LOW;
    _this25.enabled = false;
    proto3.util.initPartial(data, _this25);
    return _this25;
  }
  _inherits(SubscribedQuality2, _Message25);
  return _createClass(SubscribedQuality2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new SubscribedQuality2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new SubscribedQuality2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new SubscribedQuality2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(SubscribedQuality2, a, b);
    }
  }]);
}(Message);
SubscribedQuality.runtime = proto3;
SubscribedQuality.typeName = "livekit.SubscribedQuality";
SubscribedQuality.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "quality",
    kind: "enum",
    T: proto3.getEnumType(VideoQuality$1)
  }, {
    no: 2,
    name: "enabled",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }];
});
var SubscribedCodec = function(_Message26) {
  function SubscribedCodec2(data) {
    var _this26;
    _classCallCheck(this, SubscribedCodec2);
    _this26 = _callSuper(this, SubscribedCodec2);
    _this26.codec = "";
    _this26.qualities = [];
    proto3.util.initPartial(data, _this26);
    return _this26;
  }
  _inherits(SubscribedCodec2, _Message26);
  return _createClass(SubscribedCodec2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new SubscribedCodec2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new SubscribedCodec2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new SubscribedCodec2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(SubscribedCodec2, a, b);
    }
  }]);
}(Message);
SubscribedCodec.runtime = proto3;
SubscribedCodec.typeName = "livekit.SubscribedCodec";
SubscribedCodec.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "codec",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "qualities",
    kind: "message",
    T: SubscribedQuality,
    repeated: true
  }];
});
var SubscribedQualityUpdate = function(_Message27) {
  function SubscribedQualityUpdate2(data) {
    var _this27;
    _classCallCheck(this, SubscribedQualityUpdate2);
    _this27 = _callSuper(this, SubscribedQualityUpdate2);
    _this27.trackSid = "";
    _this27.subscribedQualities = [];
    _this27.subscribedCodecs = [];
    proto3.util.initPartial(data, _this27);
    return _this27;
  }
  _inherits(SubscribedQualityUpdate2, _Message27);
  return _createClass(SubscribedQualityUpdate2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new SubscribedQualityUpdate2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new SubscribedQualityUpdate2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new SubscribedQualityUpdate2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(SubscribedQualityUpdate2, a, b);
    }
  }]);
}(Message);
SubscribedQualityUpdate.runtime = proto3;
SubscribedQualityUpdate.typeName = "livekit.SubscribedQualityUpdate";
SubscribedQualityUpdate.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "track_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "subscribed_qualities",
    kind: "message",
    T: SubscribedQuality,
    repeated: true
  }, {
    no: 3,
    name: "subscribed_codecs",
    kind: "message",
    T: SubscribedCodec,
    repeated: true
  }];
});
var TrackPermission = function(_Message28) {
  function TrackPermission2(data) {
    var _this28;
    _classCallCheck(this, TrackPermission2);
    _this28 = _callSuper(this, TrackPermission2);
    _this28.participantSid = "";
    _this28.allTracks = false;
    _this28.trackSids = [];
    _this28.participantIdentity = "";
    proto3.util.initPartial(data, _this28);
    return _this28;
  }
  _inherits(TrackPermission2, _Message28);
  return _createClass(TrackPermission2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new TrackPermission2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new TrackPermission2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new TrackPermission2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(TrackPermission2, a, b);
    }
  }]);
}(Message);
TrackPermission.runtime = proto3;
TrackPermission.typeName = "livekit.TrackPermission";
TrackPermission.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "participant_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "all_tracks",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 3,
    name: "track_sids",
    kind: "scalar",
    T: 9,
    repeated: true
  }, {
    no: 4,
    name: "participant_identity",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }];
});
var SubscriptionPermission = function(_Message29) {
  function SubscriptionPermission2(data) {
    var _this29;
    _classCallCheck(this, SubscriptionPermission2);
    _this29 = _callSuper(this, SubscriptionPermission2);
    _this29.allParticipants = false;
    _this29.trackPermissions = [];
    proto3.util.initPartial(data, _this29);
    return _this29;
  }
  _inherits(SubscriptionPermission2, _Message29);
  return _createClass(SubscriptionPermission2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new SubscriptionPermission2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new SubscriptionPermission2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new SubscriptionPermission2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(SubscriptionPermission2, a, b);
    }
  }]);
}(Message);
SubscriptionPermission.runtime = proto3;
SubscriptionPermission.typeName = "livekit.SubscriptionPermission";
SubscriptionPermission.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "all_participants",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }, {
    no: 2,
    name: "track_permissions",
    kind: "message",
    T: TrackPermission,
    repeated: true
  }];
});
var SubscriptionPermissionUpdate = function(_Message30) {
  function SubscriptionPermissionUpdate2(data) {
    var _this30;
    _classCallCheck(this, SubscriptionPermissionUpdate2);
    _this30 = _callSuper(this, SubscriptionPermissionUpdate2);
    _this30.participantSid = "";
    _this30.trackSid = "";
    _this30.allowed = false;
    proto3.util.initPartial(data, _this30);
    return _this30;
  }
  _inherits(SubscriptionPermissionUpdate2, _Message30);
  return _createClass(SubscriptionPermissionUpdate2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new SubscriptionPermissionUpdate2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new SubscriptionPermissionUpdate2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new SubscriptionPermissionUpdate2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(SubscriptionPermissionUpdate2, a, b);
    }
  }]);
}(Message);
SubscriptionPermissionUpdate.runtime = proto3;
SubscriptionPermissionUpdate.typeName = "livekit.SubscriptionPermissionUpdate";
SubscriptionPermissionUpdate.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "participant_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "track_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "allowed",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }];
});
var SyncState = function(_Message31) {
  function SyncState2(data) {
    var _this31;
    _classCallCheck(this, SyncState2);
    _this31 = _callSuper(this, SyncState2);
    _this31.publishTracks = [];
    _this31.dataChannels = [];
    _this31.trackSidsDisabled = [];
    proto3.util.initPartial(data, _this31);
    return _this31;
  }
  _inherits(SyncState2, _Message31);
  return _createClass(SyncState2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new SyncState2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new SyncState2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new SyncState2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(SyncState2, a, b);
    }
  }]);
}(Message);
SyncState.runtime = proto3;
SyncState.typeName = "livekit.SyncState";
SyncState.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "answer",
    kind: "message",
    T: SessionDescription
  }, {
    no: 2,
    name: "subscription",
    kind: "message",
    T: UpdateSubscription
  }, {
    no: 3,
    name: "publish_tracks",
    kind: "message",
    T: TrackPublishedResponse,
    repeated: true
  }, {
    no: 4,
    name: "data_channels",
    kind: "message",
    T: DataChannelInfo,
    repeated: true
  }, {
    no: 5,
    name: "offer",
    kind: "message",
    T: SessionDescription
  }, {
    no: 6,
    name: "track_sids_disabled",
    kind: "scalar",
    T: 9,
    repeated: true
  }];
});
var DataChannelInfo = function(_Message32) {
  function DataChannelInfo2(data) {
    var _this32;
    _classCallCheck(this, DataChannelInfo2);
    _this32 = _callSuper(this, DataChannelInfo2);
    _this32.label = "";
    _this32.id = 0;
    _this32.target = SignalTarget.PUBLISHER;
    proto3.util.initPartial(data, _this32);
    return _this32;
  }
  _inherits(DataChannelInfo2, _Message32);
  return _createClass(DataChannelInfo2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new DataChannelInfo2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new DataChannelInfo2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new DataChannelInfo2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(DataChannelInfo2, a, b);
    }
  }]);
}(Message);
DataChannelInfo.runtime = proto3;
DataChannelInfo.typeName = "livekit.DataChannelInfo";
DataChannelInfo.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "label",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "id",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 3,
    name: "target",
    kind: "enum",
    T: proto3.getEnumType(SignalTarget)
  }];
});
var SimulateScenario = function(_Message33) {
  function SimulateScenario2(data) {
    var _this33;
    _classCallCheck(this, SimulateScenario2);
    _this33 = _callSuper(this, SimulateScenario2);
    _this33.scenario = {
      "case": void 0
    };
    proto3.util.initPartial(data, _this33);
    return _this33;
  }
  _inherits(SimulateScenario2, _Message33);
  return _createClass(SimulateScenario2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new SimulateScenario2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new SimulateScenario2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new SimulateScenario2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(SimulateScenario2, a, b);
    }
  }]);
}(Message);
SimulateScenario.runtime = proto3;
SimulateScenario.typeName = "livekit.SimulateScenario";
SimulateScenario.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "speaker_update",
    kind: "scalar",
    T: 5,
    oneof: "scenario"
  }, {
    no: 2,
    name: "node_failure",
    kind: "scalar",
    T: 8,
    oneof: "scenario"
  }, {
    no: 3,
    name: "migration",
    kind: "scalar",
    T: 8,
    oneof: "scenario"
  }, {
    no: 4,
    name: "server_leave",
    kind: "scalar",
    T: 8,
    oneof: "scenario"
  }, {
    no: 5,
    name: "switch_candidate_protocol",
    kind: "enum",
    T: proto3.getEnumType(CandidateProtocol),
    oneof: "scenario"
  }, {
    no: 6,
    name: "subscriber_bandwidth",
    kind: "scalar",
    T: 3,
    oneof: "scenario"
  }, {
    no: 7,
    name: "disconnect_signal_on_resume",
    kind: "scalar",
    T: 8,
    oneof: "scenario"
  }, {
    no: 8,
    name: "disconnect_signal_on_resume_no_messages",
    kind: "scalar",
    T: 8,
    oneof: "scenario"
  }, {
    no: 9,
    name: "leave_request_full_reconnect",
    kind: "scalar",
    T: 8,
    oneof: "scenario"
  }];
});
var Ping = function(_Message34) {
  function Ping2(data) {
    var _this34;
    _classCallCheck(this, Ping2);
    _this34 = _callSuper(this, Ping2);
    _this34.timestamp = protoInt64.zero;
    _this34.rtt = protoInt64.zero;
    proto3.util.initPartial(data, _this34);
    return _this34;
  }
  _inherits(Ping2, _Message34);
  return _createClass(Ping2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new Ping2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new Ping2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new Ping2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(Ping2, a, b);
    }
  }]);
}(Message);
Ping.runtime = proto3;
Ping.typeName = "livekit.Ping";
Ping.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "timestamp",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 2,
    name: "rtt",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }];
});
var Pong = function(_Message35) {
  function Pong2(data) {
    var _this35;
    _classCallCheck(this, Pong2);
    _this35 = _callSuper(this, Pong2);
    _this35.lastPingTimestamp = protoInt64.zero;
    _this35.timestamp = protoInt64.zero;
    proto3.util.initPartial(data, _this35);
    return _this35;
  }
  _inherits(Pong2, _Message35);
  return _createClass(Pong2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new Pong2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new Pong2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new Pong2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(Pong2, a, b);
    }
  }]);
}(Message);
Pong.runtime = proto3;
Pong.typeName = "livekit.Pong";
Pong.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "last_ping_timestamp",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 2,
    name: "timestamp",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }];
});
var RegionSettings = function(_Message36) {
  function RegionSettings2(data) {
    var _this36;
    _classCallCheck(this, RegionSettings2);
    _this36 = _callSuper(this, RegionSettings2);
    _this36.regions = [];
    proto3.util.initPartial(data, _this36);
    return _this36;
  }
  _inherits(RegionSettings2, _Message36);
  return _createClass(RegionSettings2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new RegionSettings2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new RegionSettings2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new RegionSettings2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(RegionSettings2, a, b);
    }
  }]);
}(Message);
RegionSettings.runtime = proto3;
RegionSettings.typeName = "livekit.RegionSettings";
RegionSettings.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "regions",
    kind: "message",
    T: RegionInfo,
    repeated: true
  }];
});
var RegionInfo = function(_Message37) {
  function RegionInfo2(data) {
    var _this37;
    _classCallCheck(this, RegionInfo2);
    _this37 = _callSuper(this, RegionInfo2);
    _this37.region = "";
    _this37.url = "";
    _this37.distance = protoInt64.zero;
    proto3.util.initPartial(data, _this37);
    return _this37;
  }
  _inherits(RegionInfo2, _Message37);
  return _createClass(RegionInfo2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new RegionInfo2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new RegionInfo2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new RegionInfo2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(RegionInfo2, a, b);
    }
  }]);
}(Message);
RegionInfo.runtime = proto3;
RegionInfo.typeName = "livekit.RegionInfo";
RegionInfo.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "region",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "distance",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }];
});
var SubscriptionResponse = function(_Message38) {
  function SubscriptionResponse2(data) {
    var _this38;
    _classCallCheck(this, SubscriptionResponse2);
    _this38 = _callSuper(this, SubscriptionResponse2);
    _this38.trackSid = "";
    _this38.err = SubscriptionError.SE_UNKNOWN;
    proto3.util.initPartial(data, _this38);
    return _this38;
  }
  _inherits(SubscriptionResponse2, _Message38);
  return _createClass(SubscriptionResponse2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new SubscriptionResponse2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new SubscriptionResponse2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new SubscriptionResponse2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(SubscriptionResponse2, a, b);
    }
  }]);
}(Message);
SubscriptionResponse.runtime = proto3;
SubscriptionResponse.typeName = "livekit.SubscriptionResponse";
SubscriptionResponse.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "track_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "err",
    kind: "enum",
    T: proto3.getEnumType(SubscriptionError)
  }];
});
var RequestResponse = function(_Message39) {
  function RequestResponse2(data) {
    var _this39;
    _classCallCheck(this, RequestResponse2);
    _this39 = _callSuper(this, RequestResponse2);
    _this39.requestId = 0;
    _this39.reason = RequestResponse_Reason.OK;
    _this39.message = "";
    proto3.util.initPartial(data, _this39);
    return _this39;
  }
  _inherits(RequestResponse2, _Message39);
  return _createClass(RequestResponse2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new RequestResponse2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new RequestResponse2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new RequestResponse2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(RequestResponse2, a, b);
    }
  }]);
}(Message);
RequestResponse.runtime = proto3;
RequestResponse.typeName = "livekit.RequestResponse";
RequestResponse.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "request_id",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }, {
    no: 2,
    name: "reason",
    kind: "enum",
    T: proto3.getEnumType(RequestResponse_Reason)
  }, {
    no: 3,
    name: "message",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }];
});
var RequestResponse_Reason;
(function(RequestResponse_Reason2) {
  RequestResponse_Reason2[RequestResponse_Reason2["OK"] = 0] = "OK";
  RequestResponse_Reason2[RequestResponse_Reason2["NOT_FOUND"] = 1] = "NOT_FOUND";
  RequestResponse_Reason2[RequestResponse_Reason2["NOT_ALLOWED"] = 2] = "NOT_ALLOWED";
  RequestResponse_Reason2[RequestResponse_Reason2["LIMIT_EXCEEDED"] = 3] = "LIMIT_EXCEEDED";
})(RequestResponse_Reason || (RequestResponse_Reason = {}));
proto3.util.setEnumType(RequestResponse_Reason, "livekit.RequestResponse.Reason", [{
  no: 0,
  name: "OK"
}, {
  no: 1,
  name: "NOT_FOUND"
}, {
  no: 2,
  name: "NOT_ALLOWED"
}, {
  no: 3,
  name: "LIMIT_EXCEEDED"
}]);
var TrackSubscribed = function(_Message40) {
  function TrackSubscribed2(data) {
    var _this40;
    _classCallCheck(this, TrackSubscribed2);
    _this40 = _callSuper(this, TrackSubscribed2);
    _this40.trackSid = "";
    proto3.util.initPartial(data, _this40);
    return _this40;
  }
  _inherits(TrackSubscribed2, _Message40);
  return _createClass(TrackSubscribed2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new TrackSubscribed2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new TrackSubscribed2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new TrackSubscribed2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(TrackSubscribed2, a, b);
    }
  }]);
}(Message);
TrackSubscribed.runtime = proto3;
TrackSubscribed.typeName = "livekit.TrackSubscribed";
TrackSubscribed.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "track_sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }];
});
var HealthCheck = function(_Message41) {
  function HealthCheck2(data) {
    var _this41;
    _classCallCheck(this, HealthCheck2);
    _this41 = _callSuper(this, HealthCheck2);
    _this41.sid = "";
    _this41.roomName = "";
    _this41.egressId = "";
    _this41.nodeId = "";
    _this41.timestamp = protoInt64.zero;
    _this41.connId = "";
    _this41.errorMessage = "";
    _this41.isNormalClosure = false;
    proto3.util.initPartial(data, _this41);
    return _this41;
  }
  _inherits(HealthCheck2, _Message41);
  return _createClass(HealthCheck2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new HealthCheck2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new HealthCheck2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new HealthCheck2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(HealthCheck2, a, b);
    }
  }]);
}(Message);
HealthCheck.runtime = proto3;
HealthCheck.typeName = "livekit.HealthCheck";
HealthCheck.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "sid",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 2,
    name: "room_name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "egress_id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 4,
    name: "node_id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 5,
    name: "timestamp",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }, {
    no: 6,
    name: "conn_id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 7,
    name: "error_message",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 8,
    name: "is_normal_closure",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }];
});
var HealthCheckResponse = function(_Message42) {
  function HealthCheckResponse2(data) {
    var _this42;
    _classCallCheck(this, HealthCheckResponse2);
    _this42 = _callSuper(this, HealthCheckResponse2);
    _this42.connId = "";
    proto3.util.initPartial(data, _this42);
    return _this42;
  }
  _inherits(HealthCheckResponse2, _Message42);
  return _createClass(HealthCheckResponse2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new HealthCheckResponse2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new HealthCheckResponse2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new HealthCheckResponse2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(HealthCheckResponse2, a, b);
    }
  }]);
}(Message);
HealthCheckResponse.runtime = proto3;
HealthCheckResponse.typeName = "livekit.HealthCheckResponse";
HealthCheckResponse.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "conn_id",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }];
});
var DeviceInfo = function(_Message43) {
  function DeviceInfo2(data) {
    var _this43;
    _classCallCheck(this, DeviceInfo2);
    _this43 = _callSuper(this, DeviceInfo2);
    _this43.sdk = DeviceInfo_SDK.UNKNOWN;
    _this43.os = "";
    _this43.deviceId = "";
    _this43.date = "";
    _this43.ipaddress = "";
    _this43.nwSignalStrength = "";
    proto3.util.initPartial(data, _this43);
    return _this43;
  }
  _inherits(DeviceInfo2, _Message43);
  return _createClass(DeviceInfo2, null, [{
    key: "fromBinary",
    value: function fromBinary(bytes, options) {
      return new DeviceInfo2().fromBinary(bytes, options);
    }
  }, {
    key: "fromJson",
    value: function fromJson(jsonValue, options) {
      return new DeviceInfo2().fromJson(jsonValue, options);
    }
  }, {
    key: "fromJsonString",
    value: function fromJsonString(jsonString, options) {
      return new DeviceInfo2().fromJsonString(jsonString, options);
    }
  }, {
    key: "equals",
    value: function equals(a, b) {
      return proto3.util.equals(DeviceInfo2, a, b);
    }
  }]);
}(Message);
DeviceInfo.runtime = proto3;
DeviceInfo.typeName = "livekit.DeviceInfo";
DeviceInfo.fields = proto3.util.newFieldList(function() {
  return [{
    no: 1,
    name: "sdk",
    kind: "enum",
    T: proto3.getEnumType(DeviceInfo_SDK)
  }, {
    no: 2,
    name: "os",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 3,
    name: "deviceId",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 4,
    name: "date",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 5,
    name: "ipaddress",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }, {
    no: 6,
    name: "nw_signal_strength",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }];
});
var DeviceInfo_SDK;
(function(DeviceInfo_SDK2) {
  DeviceInfo_SDK2[DeviceInfo_SDK2["UNKNOWN"] = 0] = "UNKNOWN";
  DeviceInfo_SDK2[DeviceInfo_SDK2["JS"] = 1] = "JS";
  DeviceInfo_SDK2[DeviceInfo_SDK2["SWIFT"] = 2] = "SWIFT";
  DeviceInfo_SDK2[DeviceInfo_SDK2["ANDROID"] = 3] = "ANDROID";
  DeviceInfo_SDK2[DeviceInfo_SDK2["FLUTTER"] = 4] = "FLUTTER";
  DeviceInfo_SDK2[DeviceInfo_SDK2["GO"] = 5] = "GO";
  DeviceInfo_SDK2[DeviceInfo_SDK2["UNITY"] = 6] = "UNITY";
  DeviceInfo_SDK2[DeviceInfo_SDK2["REACT_NATIVE"] = 7] = "REACT_NATIVE";
  DeviceInfo_SDK2[DeviceInfo_SDK2["RUST"] = 8] = "RUST";
})(DeviceInfo_SDK || (DeviceInfo_SDK = {}));
proto3.util.setEnumType(DeviceInfo_SDK, "livekit.DeviceInfo.SDK", [{
  no: 0,
  name: "UNKNOWN"
}, {
  no: 1,
  name: "JS"
}, {
  no: 2,
  name: "SWIFT"
}, {
  no: 3,
  name: "ANDROID"
}, {
  no: 4,
  name: "FLUTTER"
}, {
  no: 5,
  name: "GO"
}, {
  no: 6,
  name: "UNITY"
}, {
  no: 7,
  name: "REACT_NATIVE"
}, {
  no: 8,
  name: "RUST"
}]);
var events = { exports: {} };
var R = (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" ? Reflect : null;
var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R && typeof R.ownKeys === "function") {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target);
  };
}
function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
  return value !== value;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
events.exports = EventEmitter;
events.exports.once = once2;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(listener) {
  if (typeof listener !== "function") {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + _typeof(listener));
  }
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
  enumerable: true,
  get: function get() {
    return defaultMaxListeners;
  },
  set: function set(arg) {
    if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
    }
    defaultMaxListeners = arg;
  }
});
EventEmitter.init = function() {
  if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
  }
  this._maxListeners = n;
  return this;
};
function _getMaxListeners(that) {
  if (that._maxListeners === void 0) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = type === "error";
  var events2 = this._events;
  if (events2 !== void 0) doError = doError && events2.error === void 0;
  else if (!doError) return false;
  if (doError) {
    var er;
    if (args.length > 0) er = args[0];
    if (er instanceof Error) {
      throw er;
    }
    var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
    err.context = er;
    throw err;
  }
  var handler = events2[type];
  if (handler === void 0) return false;
  if (typeof handler === "function") {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i) ReflectApply(listeners2[i], this, args);
  }
  return true;
};
function _addListener(target, type, listener, prepend) {
  var m;
  var events2;
  var existing;
  checkListener(listener);
  events2 = target._events;
  if (events2 === void 0) {
    events2 = target._events = /* @__PURE__ */ Object.create(null);
    target._eventsCount = 0;
  } else {
    if (events2.newListener !== void 0) {
      target.emit("newListener", type, listener.listener ? listener.listener : listener);
      events2 = target._events;
    }
    existing = events2[type];
  }
  if (existing === void 0) {
    existing = events2[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      w.name = "MaxListenersExceededWarning";
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }
  return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};
function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0) return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap(target, type, listener) {
  var state = {
    fired: false,
    wrapFn: void 0,
    target,
    type,
    listener
  };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}
EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events2, position, i, originalListener;
  checkListener(listener);
  events2 = this._events;
  if (events2 === void 0) return this;
  list = events2[type];
  if (list === void 0) return this;
  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = /* @__PURE__ */ Object.create(null);
    else {
      delete events2[type];
      if (events2.removeListener) this.emit("removeListener", type, list.listener || listener);
    }
  } else if (typeof list !== "function") {
    position = -1;
    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }
    if (position < 0) return this;
    if (position === 0) list.shift();
    else {
      spliceOne(list, position);
    }
    if (list.length === 1) events2[type] = list[0];
    if (events2.removeListener !== void 0) this.emit("removeListener", type, originalListener || listener);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners2, events2, i;
  events2 = this._events;
  if (events2 === void 0) return this;
  if (events2.removeListener === void 0) {
    if (arguments.length === 0) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    } else if (events2[type] !== void 0) {
      if (--this._eventsCount === 0) this._events = /* @__PURE__ */ Object.create(null);
      else delete events2[type];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys = Object.keys(events2);
    var key;
    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === "removeListener") continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners("removeListener");
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
    return this;
  }
  listeners2 = events2[type];
  if (typeof listeners2 === "function") {
    this.removeListener(type, listeners2);
  } else if (listeners2 !== void 0) {
    for (i = listeners2.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners2[i]);
    }
  }
  return this;
};
function _listeners(target, type, unwrap) {
  var events2 = target._events;
  if (events2 === void 0) return [];
  var evlistener = events2[type];
  if (evlistener === void 0) return [];
  if (typeof evlistener === "function") return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};
EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events2 = this._events;
  if (events2 !== void 0) {
    var evlistener = events2[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener !== void 0) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i) copy[i] = arr[i];
  return copy;
}
function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) list[index] = list[index + 1];
  list.pop();
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}
function once2(emitter, name) {
  return new Promise(function(resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }
    function resolver() {
      if (typeof emitter.removeListener === "function") {
        emitter.removeListener("error", errorListener);
      }
      resolve([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(emitter, name, resolver, {
      once: true
    });
    if (name !== "error") {
      addErrorHandlerIfEventEmitter(emitter, errorListener, {
        once: true
      });
    }
  });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === "function") {
    eventTargetAgnosticAddListener(emitter, "error", handler, flags);
  }
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === "function") {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === "function") {
    emitter.addEventListener(name, function wrapListener(arg) {
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + _typeof(emitter));
  }
}
var eventsExports = events.exports;
var logDisabled_ = true;
var deprecationWarnings_ = true;
function extractVersion(uastring, expr, pos) {
  var match = uastring.match(expr);
  return match && match.length >= pos && parseFloat(match[pos], 10);
}
function wrapPeerConnectionEvent(window2, eventNameToWrap, wrapper) {
  if (!window2.RTCPeerConnection) {
    return;
  }
  var proto = window2.RTCPeerConnection.prototype;
  var nativeAddEventListener = proto.addEventListener;
  proto.addEventListener = function(nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap) {
      return nativeAddEventListener.apply(this, arguments);
    }
    var wrappedCallback = function wrappedCallback2(e) {
      var modifiedEvent = wrapper(e);
      if (modifiedEvent) {
        if (cb.handleEvent) {
          cb.handleEvent(modifiedEvent);
        } else {
          cb(modifiedEvent);
        }
      }
    };
    this._eventMap = this._eventMap || {};
    if (!this._eventMap[eventNameToWrap]) {
      this._eventMap[eventNameToWrap] = /* @__PURE__ */ new Map();
    }
    this._eventMap[eventNameToWrap].set(cb, wrappedCallback);
    return nativeAddEventListener.apply(this, [nativeEventName, wrappedCallback]);
  };
  var nativeRemoveEventListener = proto.removeEventListener;
  proto.removeEventListener = function(nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[eventNameToWrap]) {
      return nativeRemoveEventListener.apply(this, arguments);
    }
    if (!this._eventMap[eventNameToWrap].has(cb)) {
      return nativeRemoveEventListener.apply(this, arguments);
    }
    var unwrappedCb = this._eventMap[eventNameToWrap].get(cb);
    this._eventMap[eventNameToWrap]["delete"](cb);
    if (this._eventMap[eventNameToWrap].size === 0) {
      delete this._eventMap[eventNameToWrap];
    }
    if (Object.keys(this._eventMap).length === 0) {
      delete this._eventMap;
    }
    return nativeRemoveEventListener.apply(this, [nativeEventName, unwrappedCb]);
  };
  Object.defineProperty(proto, "on" + eventNameToWrap, {
    get: function get2() {
      return this["_on" + eventNameToWrap];
    },
    set: function set2(cb) {
      if (this["_on" + eventNameToWrap]) {
        this.removeEventListener(eventNameToWrap, this["_on" + eventNameToWrap]);
        delete this["_on" + eventNameToWrap];
      }
      if (cb) {
        this.addEventListener(eventNameToWrap, this["_on" + eventNameToWrap] = cb);
      }
    },
    enumerable: true,
    configurable: true
  });
}
function disableLog(bool) {
  if (typeof bool !== "boolean") {
    return new Error("Argument type: " + _typeof(bool) + ". Please use a boolean.");
  }
  logDisabled_ = bool;
  return bool ? "adapter.js logging disabled" : "adapter.js logging enabled";
}
function disableWarnings(bool) {
  if (typeof bool !== "boolean") {
    return new Error("Argument type: " + _typeof(bool) + ". Please use a boolean.");
  }
  deprecationWarnings_ = !bool;
  return "adapter.js deprecation warnings " + (bool ? "disabled" : "enabled");
}
function log() {
  if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") {
    if (logDisabled_) {
      return;
    }
    if (typeof console !== "undefined" && typeof console.log === "function") {
      console.log.apply(console, arguments);
    }
  }
}
function deprecated(oldMethod, newMethod) {
  if (!deprecationWarnings_) {
    return;
  }
  console.warn(oldMethod + " is deprecated, please use " + newMethod + " instead.");
}
function detectBrowser(window2) {
  var result = {
    browser: null,
    version: null
  };
  if (typeof window2 === "undefined" || !window2.navigator || !window2.navigator.userAgent) {
    result.browser = "Not a browser.";
    return result;
  }
  var navigator2 = window2.navigator;
  if (navigator2.mozGetUserMedia) {
    result.browser = "firefox";
    result.version = parseInt(extractVersion(navigator2.userAgent, /Firefox\/(\d+)\./, 1));
  } else if (navigator2.webkitGetUserMedia || window2.isSecureContext === false && window2.webkitRTCPeerConnection) {
    result.browser = "chrome";
    result.version = parseInt(extractVersion(navigator2.userAgent, /Chrom(e|ium)\/(\d+)\./, 2));
  } else if (window2.RTCPeerConnection && navigator2.userAgent.match(/AppleWebKit\/(\d+)\./)) {
    result.browser = "safari";
    result.version = parseInt(extractVersion(navigator2.userAgent, /AppleWebKit\/(\d+)\./, 1));
    result.supportsUnifiedPlan = window2.RTCRtpTransceiver && "currentDirection" in window2.RTCRtpTransceiver.prototype;
    result._safariVersion = extractVersion(navigator2.userAgent, /Version\/(\d+(\.?\d+))/, 1);
  } else {
    result.browser = "Not a supported browser.";
    return result;
  }
  return result;
}
function isObject(val) {
  return Object.prototype.toString.call(val) === "[object Object]";
}
function compactObject(data) {
  if (!isObject(data)) {
    return data;
  }
  return Object.keys(data).reduce(function(accumulator, key) {
    var isObj = isObject(data[key]);
    var value = isObj ? compactObject(data[key]) : data[key];
    var isEmptyObject = isObj && !Object.keys(value).length;
    if (value === void 0 || isEmptyObject) {
      return accumulator;
    }
    return Object.assign(accumulator, _defineProperty({}, key, value));
  }, {});
}
function walkStats(stats, base, resultSet) {
  if (!base || resultSet.has(base.id)) {
    return;
  }
  resultSet.set(base.id, base);
  Object.keys(base).forEach(function(name) {
    if (name.endsWith("Id")) {
      walkStats(stats, stats.get(base[name]), resultSet);
    } else if (name.endsWith("Ids")) {
      base[name].forEach(function(id) {
        walkStats(stats, stats.get(id), resultSet);
      });
    }
  });
}
function filterStats(result, track, outbound) {
  var streamStatsType = outbound ? "outbound-rtp" : "inbound-rtp";
  var filteredResult = /* @__PURE__ */ new Map();
  if (track === null) {
    return filteredResult;
  }
  var trackStats = [];
  result.forEach(function(value) {
    if (value.type === "track" && value.trackIdentifier === track.id) {
      trackStats.push(value);
    }
  });
  trackStats.forEach(function(trackStat) {
    result.forEach(function(stats) {
      if (stats.type === streamStatsType && stats.trackId === trackStat.id) {
        walkStats(result, stats, filteredResult);
      }
    });
  });
  return filteredResult;
}
var logging = log;
function shimGetUserMedia$2(window2, browserDetails2) {
  var navigator2 = window2 && window2.navigator;
  if (!navigator2.mediaDevices) {
    return;
  }
  var constraintsToChrome_ = function constraintsToChrome_2(c) {
    if (_typeof(c) !== "object" || c.mandatory || c.optional) {
      return c;
    }
    var cc = {};
    Object.keys(c).forEach(function(key) {
      if (key === "require" || key === "advanced" || key === "mediaSource") {
        return;
      }
      var r2 = _typeof(c[key]) === "object" ? c[key] : {
        ideal: c[key]
      };
      if (r2.exact !== void 0 && typeof r2.exact === "number") {
        r2.min = r2.max = r2.exact;
      }
      var oldname_ = function oldname_2(prefix, name) {
        if (prefix) {
          return prefix + name.charAt(0).toUpperCase() + name.slice(1);
        }
        return name === "deviceId" ? "sourceId" : name;
      };
      if (r2.ideal !== void 0) {
        cc.optional = cc.optional || [];
        var oc = {};
        if (typeof r2.ideal === "number") {
          oc[oldname_("min", key)] = r2.ideal;
          cc.optional.push(oc);
          oc = {};
          oc[oldname_("max", key)] = r2.ideal;
          cc.optional.push(oc);
        } else {
          oc[oldname_("", key)] = r2.ideal;
          cc.optional.push(oc);
        }
      }
      if (r2.exact !== void 0 && typeof r2.exact !== "number") {
        cc.mandatory = cc.mandatory || {};
        cc.mandatory[oldname_("", key)] = r2.exact;
      } else {
        ["min", "max"].forEach(function(mix) {
          if (r2[mix] !== void 0) {
            cc.mandatory = cc.mandatory || {};
            cc.mandatory[oldname_(mix, key)] = r2[mix];
          }
        });
      }
    });
    if (c.advanced) {
      cc.optional = (cc.optional || []).concat(c.advanced);
    }
    return cc;
  };
  var shimConstraints_ = function shimConstraints_2(constraints, func) {
    if (browserDetails2.version >= 61) {
      return func(constraints);
    }
    constraints = JSON.parse(JSON.stringify(constraints));
    if (constraints && _typeof(constraints.audio) === "object") {
      var remap = function remap2(obj, a, b) {
        if (a in obj && !(b in obj)) {
          obj[b] = obj[a];
          delete obj[a];
        }
      };
      constraints = JSON.parse(JSON.stringify(constraints));
      remap(constraints.audio, "autoGainControl", "googAutoGainControl");
      remap(constraints.audio, "noiseSuppression", "googNoiseSuppression");
      constraints.audio = constraintsToChrome_(constraints.audio);
    }
    if (constraints && _typeof(constraints.video) === "object") {
      var face = constraints.video.facingMode;
      face = face && (_typeof(face) === "object" ? face : {
        ideal: face
      });
      var getSupportedFacingModeLies = browserDetails2.version < 66;
      if (face && (face.exact === "user" || face.exact === "environment" || face.ideal === "user" || face.ideal === "environment") && !(navigator2.mediaDevices.getSupportedConstraints && navigator2.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {
        delete constraints.video.facingMode;
        var matches;
        if (face.exact === "environment" || face.ideal === "environment") {
          matches = ["back", "rear"];
        } else if (face.exact === "user" || face.ideal === "user") {
          matches = ["front"];
        }
        if (matches) {
          return navigator2.mediaDevices.enumerateDevices().then(function(devices) {
            devices = devices.filter(function(d) {
              return d.kind === "videoinput";
            });
            var dev = devices.find(function(d) {
              return matches.some(function(match) {
                return d.label.toLowerCase().includes(match);
              });
            });
            if (!dev && devices.length && matches.includes("back")) {
              dev = devices[devices.length - 1];
            }
            if (dev) {
              constraints.video.deviceId = face.exact ? {
                exact: dev.deviceId
              } : {
                ideal: dev.deviceId
              };
            }
            constraints.video = constraintsToChrome_(constraints.video);
            logging("chrome: " + JSON.stringify(constraints));
            return func(constraints);
          });
        }
      }
      constraints.video = constraintsToChrome_(constraints.video);
    }
    logging("chrome: " + JSON.stringify(constraints));
    return func(constraints);
  };
  var shimError_ = function shimError_2(e) {
    if (browserDetails2.version >= 64) {
      return e;
    }
    return {
      name: {
        PermissionDeniedError: "NotAllowedError",
        PermissionDismissedError: "NotAllowedError",
        InvalidStateError: "NotAllowedError",
        DevicesNotFoundError: "NotFoundError",
        ConstraintNotSatisfiedError: "OverconstrainedError",
        TrackStartError: "NotReadableError",
        MediaDeviceFailedDueToShutdown: "NotAllowedError",
        MediaDeviceKillSwitchOn: "NotAllowedError",
        TabCaptureError: "AbortError",
        ScreenCaptureError: "AbortError",
        DeviceCaptureError: "AbortError"
      }[e.name] || e.name,
      message: e.message,
      constraint: e.constraint || e.constraintName,
      toString: function toString() {
        return this.name + (this.message && ": ") + this.message;
      }
    };
  };
  var getUserMedia_ = function getUserMedia_2(constraints, onSuccess, onError) {
    shimConstraints_(constraints, function(c) {
      navigator2.webkitGetUserMedia(c, onSuccess, function(e) {
        if (onError) {
          onError(shimError_(e));
        }
      });
    });
  };
  navigator2.getUserMedia = getUserMedia_.bind(navigator2);
  if (navigator2.mediaDevices.getUserMedia) {
    var origGetUserMedia = navigator2.mediaDevices.getUserMedia.bind(navigator2.mediaDevices);
    navigator2.mediaDevices.getUserMedia = function(cs) {
      return shimConstraints_(cs, function(c) {
        return origGetUserMedia(c).then(function(stream) {
          if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {
            stream.getTracks().forEach(function(track) {
              track.stop();
            });
            throw new DOMException("", "NotFoundError");
          }
          return stream;
        }, function(e) {
          return Promise.reject(shimError_(e));
        });
      });
    };
  }
}
function shimGetDisplayMedia$1(window2, getSourceId) {
  if (window2.navigator.mediaDevices && "getDisplayMedia" in window2.navigator.mediaDevices) {
    return;
  }
  if (!window2.navigator.mediaDevices) {
    return;
  }
  if (typeof getSourceId !== "function") {
    console.error("shimGetDisplayMedia: getSourceId argument is not a function");
    return;
  }
  window2.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
    return getSourceId(constraints).then(function(sourceId) {
      var widthSpecified = constraints.video && constraints.video.width;
      var heightSpecified = constraints.video && constraints.video.height;
      var frameRateSpecified = constraints.video && constraints.video.frameRate;
      constraints.video = {
        mandatory: {
          chromeMediaSource: "desktop",
          chromeMediaSourceId: sourceId,
          maxFrameRate: frameRateSpecified || 3
        }
      };
      if (widthSpecified) {
        constraints.video.mandatory.maxWidth = widthSpecified;
      }
      if (heightSpecified) {
        constraints.video.mandatory.maxHeight = heightSpecified;
      }
      return window2.navigator.mediaDevices.getUserMedia(constraints);
    });
  };
}
function shimMediaStream(window2) {
  window2.MediaStream = window2.MediaStream || window2.webkitMediaStream;
}
function shimOnTrack$1(window2) {
  if (_typeof(window2) === "object" && window2.RTCPeerConnection && !("ontrack" in window2.RTCPeerConnection.prototype)) {
    Object.defineProperty(window2.RTCPeerConnection.prototype, "ontrack", {
      get: function get2() {
        return this._ontrack;
      },
      set: function set2(f) {
        if (this._ontrack) {
          this.removeEventListener("track", this._ontrack);
        }
        this.addEventListener("track", this._ontrack = f);
      },
      enumerable: true,
      configurable: true
    });
    var origSetRemoteDescription = window2.RTCPeerConnection.prototype.setRemoteDescription;
    window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
      var _this = this;
      if (!this._ontrackpoly) {
        this._ontrackpoly = function(e) {
          e.stream.addEventListener("addtrack", function(te) {
            var receiver;
            if (window2.RTCPeerConnection.prototype.getReceivers) {
              receiver = _this.getReceivers().find(function(r2) {
                return r2.track && r2.track.id === te.track.id;
              });
            } else {
              receiver = {
                track: te.track
              };
            }
            var event = new Event("track");
            event.track = te.track;
            event.receiver = receiver;
            event.transceiver = {
              receiver
            };
            event.streams = [e.stream];
            _this.dispatchEvent(event);
          });
          e.stream.getTracks().forEach(function(track) {
            var receiver;
            if (window2.RTCPeerConnection.prototype.getReceivers) {
              receiver = _this.getReceivers().find(function(r2) {
                return r2.track && r2.track.id === track.id;
              });
            } else {
              receiver = {
                track
              };
            }
            var event = new Event("track");
            event.track = track;
            event.receiver = receiver;
            event.transceiver = {
              receiver
            };
            event.streams = [e.stream];
            _this.dispatchEvent(event);
          });
        };
        this.addEventListener("addstream", this._ontrackpoly);
      }
      return origSetRemoteDescription.apply(this, arguments);
    };
  } else {
    wrapPeerConnectionEvent(window2, "track", function(e) {
      if (!e.transceiver) {
        Object.defineProperty(e, "transceiver", {
          value: {
            receiver: e.receiver
          }
        });
      }
      return e;
    });
  }
}
function shimGetSendersWithDtmf(window2) {
  if (_typeof(window2) === "object" && window2.RTCPeerConnection && !("getSenders" in window2.RTCPeerConnection.prototype) && "createDTMFSender" in window2.RTCPeerConnection.prototype) {
    var shimSenderWithDtmf = function shimSenderWithDtmf2(pc, track) {
      return {
        track,
        get dtmf() {
          if (this._dtmf === void 0) {
            if (track.kind === "audio") {
              this._dtmf = pc.createDTMFSender(track);
            } else {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        },
        _pc: pc
      };
    };
    if (!window2.RTCPeerConnection.prototype.getSenders) {
      window2.RTCPeerConnection.prototype.getSenders = function getSenders() {
        this._senders = this._senders || [];
        return this._senders.slice();
      };
      var origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
      window2.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
        var sender = origAddTrack.apply(this, arguments);
        if (!sender) {
          sender = shimSenderWithDtmf(this, track);
          this._senders.push(sender);
        }
        return sender;
      };
      var origRemoveTrack = window2.RTCPeerConnection.prototype.removeTrack;
      window2.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
        origRemoveTrack.apply(this, arguments);
        var idx = this._senders.indexOf(sender);
        if (idx !== -1) {
          this._senders.splice(idx, 1);
        }
      };
    }
    var origAddStream = window2.RTCPeerConnection.prototype.addStream;
    window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {
      var _this2 = this;
      this._senders = this._senders || [];
      origAddStream.apply(this, [stream]);
      stream.getTracks().forEach(function(track) {
        _this2._senders.push(shimSenderWithDtmf(_this2, track));
      });
    };
    var origRemoveStream = window2.RTCPeerConnection.prototype.removeStream;
    window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
      var _this3 = this;
      this._senders = this._senders || [];
      origRemoveStream.apply(this, [stream]);
      stream.getTracks().forEach(function(track) {
        var sender = _this3._senders.find(function(s) {
          return s.track === track;
        });
        if (sender) {
          _this3._senders.splice(_this3._senders.indexOf(sender), 1);
        }
      });
    };
  } else if (_typeof(window2) === "object" && window2.RTCPeerConnection && "getSenders" in window2.RTCPeerConnection.prototype && "createDTMFSender" in window2.RTCPeerConnection.prototype && window2.RTCRtpSender && !("dtmf" in window2.RTCRtpSender.prototype)) {
    var origGetSenders = window2.RTCPeerConnection.prototype.getSenders;
    window2.RTCPeerConnection.prototype.getSenders = function getSenders() {
      var _this4 = this;
      var senders = origGetSenders.apply(this, []);
      senders.forEach(function(sender) {
        return sender._pc = _this4;
      });
      return senders;
    };
    Object.defineProperty(window2.RTCRtpSender.prototype, "dtmf", {
      get: function get2() {
        if (this._dtmf === void 0) {
          if (this.track.kind === "audio") {
            this._dtmf = this._pc.createDTMFSender(this.track);
          } else {
            this._dtmf = null;
          }
        }
        return this._dtmf;
      }
    });
  }
}
function shimGetStats(window2) {
  if (!window2.RTCPeerConnection) {
    return;
  }
  var origGetStats = window2.RTCPeerConnection.prototype.getStats;
  window2.RTCPeerConnection.prototype.getStats = function getStats() {
    var _this5 = this;
    var _arguments = Array.prototype.slice.call(arguments), selector = _arguments[0], onSucc = _arguments[1], onErr = _arguments[2];
    if (arguments.length > 0 && typeof selector === "function") {
      return origGetStats.apply(this, arguments);
    }
    if (origGetStats.length === 0 && (arguments.length === 0 || typeof selector !== "function")) {
      return origGetStats.apply(this, []);
    }
    var fixChromeStats_ = function fixChromeStats_2(response) {
      var standardReport = {};
      var reports = response.result();
      reports.forEach(function(report) {
        var standardStats = {
          id: report.id,
          timestamp: report.timestamp,
          type: {
            localcandidate: "local-candidate",
            remotecandidate: "remote-candidate"
          }[report.type] || report.type
        };
        report.names().forEach(function(name) {
          standardStats[name] = report.stat(name);
        });
        standardReport[standardStats.id] = standardStats;
      });
      return standardReport;
    };
    var makeMapStats = function makeMapStats2(stats) {
      return new Map(Object.keys(stats).map(function(key) {
        return [key, stats[key]];
      }));
    };
    if (arguments.length >= 2) {
      var successCallbackWrapper_ = function successCallbackWrapper_2(response) {
        onSucc(makeMapStats(fixChromeStats_(response)));
      };
      return origGetStats.apply(this, [successCallbackWrapper_, selector]);
    }
    return new Promise(function(resolve, reject) {
      origGetStats.apply(_this5, [function(response) {
        resolve(makeMapStats(fixChromeStats_(response)));
      }, reject]);
    }).then(onSucc, onErr);
  };
}
function shimSenderReceiverGetStats(window2) {
  if (!(_typeof(window2) === "object" && window2.RTCPeerConnection && window2.RTCRtpSender && window2.RTCRtpReceiver)) {
    return;
  }
  if (!("getStats" in window2.RTCRtpSender.prototype)) {
    var origGetSenders = window2.RTCPeerConnection.prototype.getSenders;
    if (origGetSenders) {
      window2.RTCPeerConnection.prototype.getSenders = function getSenders() {
        var _this6 = this;
        var senders = origGetSenders.apply(this, []);
        senders.forEach(function(sender) {
          return sender._pc = _this6;
        });
        return senders;
      };
    }
    var origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
    if (origAddTrack) {
      window2.RTCPeerConnection.prototype.addTrack = function addTrack() {
        var sender = origAddTrack.apply(this, arguments);
        sender._pc = this;
        return sender;
      };
    }
    window2.RTCRtpSender.prototype.getStats = function getStats() {
      var sender = this;
      return this._pc.getStats().then(function(result) {
        return (
          /* Note: this will include stats of all senders that
           *   send a track with the same id as sender.track as
           *   it is not possible to identify the RTCRtpSender.
           */
          filterStats(result, sender.track, true)
        );
      });
    };
  }
  if (!("getStats" in window2.RTCRtpReceiver.prototype)) {
    var origGetReceivers = window2.RTCPeerConnection.prototype.getReceivers;
    if (origGetReceivers) {
      window2.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
        var _this7 = this;
        var receivers = origGetReceivers.apply(this, []);
        receivers.forEach(function(receiver) {
          return receiver._pc = _this7;
        });
        return receivers;
      };
    }
    wrapPeerConnectionEvent(window2, "track", function(e) {
      e.receiver._pc = e.srcElement;
      return e;
    });
    window2.RTCRtpReceiver.prototype.getStats = function getStats() {
      var receiver = this;
      return this._pc.getStats().then(function(result) {
        return filterStats(result, receiver.track, false);
      });
    };
  }
  if (!("getStats" in window2.RTCRtpSender.prototype && "getStats" in window2.RTCRtpReceiver.prototype)) {
    return;
  }
  var origGetStats = window2.RTCPeerConnection.prototype.getStats;
  window2.RTCPeerConnection.prototype.getStats = function getStats() {
    if (arguments.length > 0 && arguments[0] instanceof window2.MediaStreamTrack) {
      var track = arguments[0];
      var sender;
      var receiver;
      var err;
      this.getSenders().forEach(function(s) {
        if (s.track === track) {
          if (sender) {
            err = true;
          } else {
            sender = s;
          }
        }
      });
      this.getReceivers().forEach(function(r2) {
        if (r2.track === track) {
          if (receiver) {
            err = true;
          } else {
            receiver = r2;
          }
        }
        return r2.track === track;
      });
      if (err || sender && receiver) {
        return Promise.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError"));
      } else if (sender) {
        return sender.getStats();
      } else if (receiver) {
        return receiver.getStats();
      }
      return Promise.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError"));
    }
    return origGetStats.apply(this, arguments);
  };
}
function shimAddTrackRemoveTrackWithNative(window2) {
  window2.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
    var _this8 = this;
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    return Object.keys(this._shimmedLocalStreams).map(function(streamId) {
      return _this8._shimmedLocalStreams[streamId][0];
    });
  };
  var origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
  window2.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
    if (!stream) {
      return origAddTrack.apply(this, arguments);
    }
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    var sender = origAddTrack.apply(this, arguments);
    if (!this._shimmedLocalStreams[stream.id]) {
      this._shimmedLocalStreams[stream.id] = [stream, sender];
    } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {
      this._shimmedLocalStreams[stream.id].push(sender);
    }
    return sender;
  };
  var origAddStream = window2.RTCPeerConnection.prototype.addStream;
  window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {
    var _this9 = this;
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    stream.getTracks().forEach(function(track) {
      var alreadyExists = _this9.getSenders().find(function(s) {
        return s.track === track;
      });
      if (alreadyExists) {
        throw new DOMException("Track already exists.", "InvalidAccessError");
      }
    });
    var existingSenders = this.getSenders();
    origAddStream.apply(this, arguments);
    var newSenders = this.getSenders().filter(function(newSender) {
      return existingSenders.indexOf(newSender) === -1;
    });
    this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);
  };
  var origRemoveStream = window2.RTCPeerConnection.prototype.removeStream;
  window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    delete this._shimmedLocalStreams[stream.id];
    return origRemoveStream.apply(this, arguments);
  };
  var origRemoveTrack = window2.RTCPeerConnection.prototype.removeTrack;
  window2.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
    var _this0 = this;
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    if (sender) {
      Object.keys(this._shimmedLocalStreams).forEach(function(streamId) {
        var idx = _this0._shimmedLocalStreams[streamId].indexOf(sender);
        if (idx !== -1) {
          _this0._shimmedLocalStreams[streamId].splice(idx, 1);
        }
        if (_this0._shimmedLocalStreams[streamId].length === 1) {
          delete _this0._shimmedLocalStreams[streamId];
        }
      });
    }
    return origRemoveTrack.apply(this, arguments);
  };
}
function shimAddTrackRemoveTrack(window2, browserDetails2) {
  if (!window2.RTCPeerConnection) {
    return;
  }
  if (window2.RTCPeerConnection.prototype.addTrack && browserDetails2.version >= 65) {
    return shimAddTrackRemoveTrackWithNative(window2);
  }
  var origGetLocalStreams = window2.RTCPeerConnection.prototype.getLocalStreams;
  window2.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
    var _this1 = this;
    var nativeStreams = origGetLocalStreams.apply(this);
    this._reverseStreams = this._reverseStreams || {};
    return nativeStreams.map(function(stream) {
      return _this1._reverseStreams[stream.id];
    });
  };
  var origAddStream = window2.RTCPeerConnection.prototype.addStream;
  window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {
    var _this10 = this;
    this._streams = this._streams || {};
    this._reverseStreams = this._reverseStreams || {};
    stream.getTracks().forEach(function(track) {
      var alreadyExists = _this10.getSenders().find(function(s) {
        return s.track === track;
      });
      if (alreadyExists) {
        throw new DOMException("Track already exists.", "InvalidAccessError");
      }
    });
    if (!this._reverseStreams[stream.id]) {
      var newStream = new window2.MediaStream(stream.getTracks());
      this._streams[stream.id] = newStream;
      this._reverseStreams[newStream.id] = stream;
      stream = newStream;
    }
    origAddStream.apply(this, [stream]);
  };
  var origRemoveStream = window2.RTCPeerConnection.prototype.removeStream;
  window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
    this._streams = this._streams || {};
    this._reverseStreams = this._reverseStreams || {};
    origRemoveStream.apply(this, [this._streams[stream.id] || stream]);
    delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];
    delete this._streams[stream.id];
  };
  window2.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
    var _this11 = this;
    if (this.signalingState === "closed") {
      throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
    }
    var streams = [].slice.call(arguments, 1);
    if (streams.length !== 1 || !streams[0].getTracks().find(function(t) {
      return t === track;
    })) {
      throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError");
    }
    var alreadyExists = this.getSenders().find(function(s) {
      return s.track === track;
    });
    if (alreadyExists) {
      throw new DOMException("Track already exists.", "InvalidAccessError");
    }
    this._streams = this._streams || {};
    this._reverseStreams = this._reverseStreams || {};
    var oldStream = this._streams[stream.id];
    if (oldStream) {
      oldStream.addTrack(track);
      Promise.resolve().then(function() {
        _this11.dispatchEvent(new Event("negotiationneeded"));
      });
    } else {
      var newStream = new window2.MediaStream([track]);
      this._streams[stream.id] = newStream;
      this._reverseStreams[newStream.id] = stream;
      this.addStream(newStream);
    }
    return this.getSenders().find(function(s) {
      return s.track === track;
    });
  };
  function replaceInternalStreamId(pc, description) {
    var sdp2 = description.sdp;
    Object.keys(pc._reverseStreams || []).forEach(function(internalId) {
      var externalStream = pc._reverseStreams[internalId];
      var internalStream = pc._streams[externalStream.id];
      sdp2 = sdp2.replace(new RegExp(internalStream.id, "g"), externalStream.id);
    });
    return new RTCSessionDescription({
      type: description.type,
      sdp: sdp2
    });
  }
  function replaceExternalStreamId(pc, description) {
    var sdp2 = description.sdp;
    Object.keys(pc._reverseStreams || []).forEach(function(internalId) {
      var externalStream = pc._reverseStreams[internalId];
      var internalStream = pc._streams[externalStream.id];
      sdp2 = sdp2.replace(new RegExp(externalStream.id, "g"), internalStream.id);
    });
    return new RTCSessionDescription({
      type: description.type,
      sdp: sdp2
    });
  }
  ["createOffer", "createAnswer"].forEach(function(method) {
    var nativeMethod = window2.RTCPeerConnection.prototype[method];
    var methodObj = _defineProperty({}, method, function() {
      var _this12 = this;
      var args = arguments;
      var isLegacyCall = arguments.length && typeof arguments[0] === "function";
      if (isLegacyCall) {
        return nativeMethod.apply(this, [function(description) {
          var desc = replaceInternalStreamId(_this12, description);
          args[0].apply(null, [desc]);
        }, function(err) {
          if (args[1]) {
            args[1].apply(null, err);
          }
        }, arguments[2]]);
      }
      return nativeMethod.apply(this, arguments).then(function(description) {
        return replaceInternalStreamId(_this12, description);
      });
    });
    window2.RTCPeerConnection.prototype[method] = methodObj[method];
  });
  var origSetLocalDescription = window2.RTCPeerConnection.prototype.setLocalDescription;
  window2.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
    if (!arguments.length || !arguments[0].type) {
      return origSetLocalDescription.apply(this, arguments);
    }
    arguments[0] = replaceExternalStreamId(this, arguments[0]);
    return origSetLocalDescription.apply(this, arguments);
  };
  var origLocalDescription = Object.getOwnPropertyDescriptor(window2.RTCPeerConnection.prototype, "localDescription");
  Object.defineProperty(window2.RTCPeerConnection.prototype, "localDescription", {
    get: function get2() {
      var description = origLocalDescription.get.apply(this);
      if (description.type === "") {
        return description;
      }
      return replaceInternalStreamId(this, description);
    }
  });
  window2.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
    var _this13 = this;
    if (this.signalingState === "closed") {
      throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
    }
    if (!sender._pc) {
      throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
    }
    var isLocal = sender._pc === this;
    if (!isLocal) {
      throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");
    }
    this._streams = this._streams || {};
    var stream;
    Object.keys(this._streams).forEach(function(streamid) {
      var hasTrack = _this13._streams[streamid].getTracks().find(function(track) {
        return sender.track === track;
      });
      if (hasTrack) {
        stream = _this13._streams[streamid];
      }
    });
    if (stream) {
      if (stream.getTracks().length === 1) {
        this.removeStream(this._reverseStreams[stream.id]);
      } else {
        stream.removeTrack(sender.track);
      }
      this.dispatchEvent(new Event("negotiationneeded"));
    }
  };
}
function shimPeerConnection$1(window2, browserDetails2) {
  if (!window2.RTCPeerConnection && window2.webkitRTCPeerConnection) {
    window2.RTCPeerConnection = window2.webkitRTCPeerConnection;
  }
  if (!window2.RTCPeerConnection) {
    return;
  }
  if (browserDetails2.version < 53) {
    ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(method) {
      var nativeMethod = window2.RTCPeerConnection.prototype[method];
      var methodObj = _defineProperty({}, method, function() {
        arguments[0] = new (method === "addIceCandidate" ? window2.RTCIceCandidate : window2.RTCSessionDescription)(arguments[0]);
        return nativeMethod.apply(this, arguments);
      });
      window2.RTCPeerConnection.prototype[method] = methodObj[method];
    });
  }
}
function fixNegotiationNeeded(window2, browserDetails2) {
  wrapPeerConnectionEvent(window2, "negotiationneeded", function(e) {
    var pc = e.target;
    if (browserDetails2.version < 72 || pc.getConfiguration && pc.getConfiguration().sdpSemantics === "plan-b") {
      if (pc.signalingState !== "stable") {
        return;
      }
    }
    return e;
  });
}
var chromeShim = Object.freeze({
  __proto__: null,
  fixNegotiationNeeded,
  shimAddTrackRemoveTrack,
  shimAddTrackRemoveTrackWithNative,
  shimGetDisplayMedia: shimGetDisplayMedia$1,
  shimGetSendersWithDtmf,
  shimGetStats,
  shimGetUserMedia: shimGetUserMedia$2,
  shimMediaStream,
  shimOnTrack: shimOnTrack$1,
  shimPeerConnection: shimPeerConnection$1,
  shimSenderReceiverGetStats
});
function shimGetUserMedia$1(window2, browserDetails2) {
  var navigator2 = window2 && window2.navigator;
  var MediaStreamTrack2 = window2 && window2.MediaStreamTrack;
  navigator2.getUserMedia = function(constraints, onSuccess, onError) {
    deprecated("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia");
    navigator2.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
  };
  if (!(browserDetails2.version > 55 && "autoGainControl" in navigator2.mediaDevices.getSupportedConstraints())) {
    var remap = function remap2(obj, a, b) {
      if (a in obj && !(b in obj)) {
        obj[b] = obj[a];
        delete obj[a];
      }
    };
    var nativeGetUserMedia = navigator2.mediaDevices.getUserMedia.bind(navigator2.mediaDevices);
    navigator2.mediaDevices.getUserMedia = function(c) {
      if (_typeof(c) === "object" && _typeof(c.audio) === "object") {
        c = JSON.parse(JSON.stringify(c));
        remap(c.audio, "autoGainControl", "mozAutoGainControl");
        remap(c.audio, "noiseSuppression", "mozNoiseSuppression");
      }
      return nativeGetUserMedia(c);
    };
    if (MediaStreamTrack2 && MediaStreamTrack2.prototype.getSettings) {
      var nativeGetSettings = MediaStreamTrack2.prototype.getSettings;
      MediaStreamTrack2.prototype.getSettings = function() {
        var obj = nativeGetSettings.apply(this, arguments);
        remap(obj, "mozAutoGainControl", "autoGainControl");
        remap(obj, "mozNoiseSuppression", "noiseSuppression");
        return obj;
      };
    }
    if (MediaStreamTrack2 && MediaStreamTrack2.prototype.applyConstraints) {
      var nativeApplyConstraints = MediaStreamTrack2.prototype.applyConstraints;
      MediaStreamTrack2.prototype.applyConstraints = function(c) {
        if (this.kind === "audio" && _typeof(c) === "object") {
          c = JSON.parse(JSON.stringify(c));
          remap(c, "autoGainControl", "mozAutoGainControl");
          remap(c, "noiseSuppression", "mozNoiseSuppression");
        }
        return nativeApplyConstraints.apply(this, [c]);
      };
    }
  }
}
function shimGetDisplayMedia(window2, preferredMediaSource) {
  if (window2.navigator.mediaDevices && "getDisplayMedia" in window2.navigator.mediaDevices) {
    return;
  }
  if (!window2.navigator.mediaDevices) {
    return;
  }
  window2.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
    if (!(constraints && constraints.video)) {
      var err = new DOMException("getDisplayMedia without video constraints is undefined");
      err.name = "NotFoundError";
      err.code = 8;
      return Promise.reject(err);
    }
    if (constraints.video === true) {
      constraints.video = {
        mediaSource: preferredMediaSource
      };
    } else {
      constraints.video.mediaSource = preferredMediaSource;
    }
    return window2.navigator.mediaDevices.getUserMedia(constraints);
  };
}
function shimOnTrack(window2) {
  if (_typeof(window2) === "object" && window2.RTCTrackEvent && "receiver" in window2.RTCTrackEvent.prototype && !("transceiver" in window2.RTCTrackEvent.prototype)) {
    Object.defineProperty(window2.RTCTrackEvent.prototype, "transceiver", {
      get: function get2() {
        return {
          receiver: this.receiver
        };
      }
    });
  }
}
function shimPeerConnection(window2, browserDetails2) {
  if (_typeof(window2) !== "object" || !(window2.RTCPeerConnection || window2.mozRTCPeerConnection)) {
    return;
  }
  if (!window2.RTCPeerConnection && window2.mozRTCPeerConnection) {
    window2.RTCPeerConnection = window2.mozRTCPeerConnection;
  }
  if (browserDetails2.version < 53) {
    ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(method) {
      var nativeMethod = window2.RTCPeerConnection.prototype[method];
      var methodObj = _defineProperty({}, method, function() {
        arguments[0] = new (method === "addIceCandidate" ? window2.RTCIceCandidate : window2.RTCSessionDescription)(arguments[0]);
        return nativeMethod.apply(this, arguments);
      });
      window2.RTCPeerConnection.prototype[method] = methodObj[method];
    });
  }
  var modernStatsTypes = {
    inboundrtp: "inbound-rtp",
    outboundrtp: "outbound-rtp",
    candidatepair: "candidate-pair",
    localcandidate: "local-candidate",
    remotecandidate: "remote-candidate"
  };
  var nativeGetStats = window2.RTCPeerConnection.prototype.getStats;
  window2.RTCPeerConnection.prototype.getStats = function getStats() {
    var _arguments = Array.prototype.slice.call(arguments), selector = _arguments[0], onSucc = _arguments[1], onErr = _arguments[2];
    return nativeGetStats.apply(this, [selector || null]).then(function(stats) {
      if (browserDetails2.version < 53 && !onSucc) {
        try {
          stats.forEach(function(stat) {
            stat.type = modernStatsTypes[stat.type] || stat.type;
          });
        } catch (e) {
          if (e.name !== "TypeError") {
            throw e;
          }
          stats.forEach(function(stat, i) {
            stats.set(i, Object.assign({}, stat, {
              type: modernStatsTypes[stat.type] || stat.type
            }));
          });
        }
      }
      return stats;
    }).then(onSucc, onErr);
  };
}
function shimSenderGetStats(window2) {
  if (!(_typeof(window2) === "object" && window2.RTCPeerConnection && window2.RTCRtpSender)) {
    return;
  }
  if (window2.RTCRtpSender && "getStats" in window2.RTCRtpSender.prototype) {
    return;
  }
  var origGetSenders = window2.RTCPeerConnection.prototype.getSenders;
  if (origGetSenders) {
    window2.RTCPeerConnection.prototype.getSenders = function getSenders() {
      var _this = this;
      var senders = origGetSenders.apply(this, []);
      senders.forEach(function(sender) {
        return sender._pc = _this;
      });
      return senders;
    };
  }
  var origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
  if (origAddTrack) {
    window2.RTCPeerConnection.prototype.addTrack = function addTrack() {
      var sender = origAddTrack.apply(this, arguments);
      sender._pc = this;
      return sender;
    };
  }
  window2.RTCRtpSender.prototype.getStats = function getStats() {
    return this.track ? this._pc.getStats(this.track) : Promise.resolve(/* @__PURE__ */ new Map());
  };
}
function shimReceiverGetStats(window2) {
  if (!(_typeof(window2) === "object" && window2.RTCPeerConnection && window2.RTCRtpSender)) {
    return;
  }
  if (window2.RTCRtpSender && "getStats" in window2.RTCRtpReceiver.prototype) {
    return;
  }
  var origGetReceivers = window2.RTCPeerConnection.prototype.getReceivers;
  if (origGetReceivers) {
    window2.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
      var _this2 = this;
      var receivers = origGetReceivers.apply(this, []);
      receivers.forEach(function(receiver) {
        return receiver._pc = _this2;
      });
      return receivers;
    };
  }
  wrapPeerConnectionEvent(window2, "track", function(e) {
    e.receiver._pc = e.srcElement;
    return e;
  });
  window2.RTCRtpReceiver.prototype.getStats = function getStats() {
    return this._pc.getStats(this.track);
  };
}
function shimRemoveStream(window2) {
  if (!window2.RTCPeerConnection || "removeStream" in window2.RTCPeerConnection.prototype) {
    return;
  }
  window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
    var _this3 = this;
    deprecated("removeStream", "removeTrack");
    this.getSenders().forEach(function(sender) {
      if (sender.track && stream.getTracks().includes(sender.track)) {
        _this3.removeTrack(sender);
      }
    });
  };
}
function shimRTCDataChannel(window2) {
  if (window2.DataChannel && !window2.RTCDataChannel) {
    window2.RTCDataChannel = window2.DataChannel;
  }
}
function shimAddTransceiver(window2) {
  if (!(_typeof(window2) === "object" && window2.RTCPeerConnection)) {
    return;
  }
  var origAddTransceiver = window2.RTCPeerConnection.prototype.addTransceiver;
  if (origAddTransceiver) {
    window2.RTCPeerConnection.prototype.addTransceiver = function addTransceiver() {
      this.setParametersPromises = [];
      var sendEncodings = arguments[1] && arguments[1].sendEncodings;
      if (sendEncodings === void 0) {
        sendEncodings = [];
      }
      sendEncodings = _toConsumableArray(sendEncodings);
      var shouldPerformCheck = sendEncodings.length > 0;
      if (shouldPerformCheck) {
        sendEncodings.forEach(function(encodingParam) {
          if ("rid" in encodingParam) {
            var ridRegex = /^[a-z0-9]{0,16}$/i;
            if (!ridRegex.test(encodingParam.rid)) {
              throw new TypeError("Invalid RID value provided.");
            }
          }
          if ("scaleResolutionDownBy" in encodingParam) {
            if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1)) {
              throw new RangeError("scale_resolution_down_by must be >= 1.0");
            }
          }
          if ("maxFramerate" in encodingParam) {
            if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {
              throw new RangeError("max_framerate must be >= 0.0");
            }
          }
        });
      }
      var transceiver = origAddTransceiver.apply(this, arguments);
      if (shouldPerformCheck) {
        var sender = transceiver.sender;
        var params = sender.getParameters();
        if (!("encodings" in params) || // Avoid being fooled by patched getParameters() below.
        params.encodings.length === 1 && Object.keys(params.encodings[0]).length === 0) {
          params.encodings = sendEncodings;
          sender.sendEncodings = sendEncodings;
          this.setParametersPromises.push(sender.setParameters(params).then(function() {
            delete sender.sendEncodings;
          })["catch"](function() {
            delete sender.sendEncodings;
          }));
        }
      }
      return transceiver;
    };
  }
}
function shimGetParameters(window2) {
  if (!(_typeof(window2) === "object" && window2.RTCRtpSender)) {
    return;
  }
  var origGetParameters = window2.RTCRtpSender.prototype.getParameters;
  if (origGetParameters) {
    window2.RTCRtpSender.prototype.getParameters = function getParameters() {
      var params = origGetParameters.apply(this, arguments);
      if (!("encodings" in params)) {
        params.encodings = [].concat(this.sendEncodings || [{}]);
      }
      return params;
    };
  }
}
function shimCreateOffer(window2) {
  if (!(_typeof(window2) === "object" && window2.RTCPeerConnection)) {
    return;
  }
  var origCreateOffer = window2.RTCPeerConnection.prototype.createOffer;
  window2.RTCPeerConnection.prototype.createOffer = function createOffer() {
    var _arguments2 = arguments, _this4 = this;
    if (this.setParametersPromises && this.setParametersPromises.length) {
      return Promise.all(this.setParametersPromises).then(function() {
        return origCreateOffer.apply(_this4, _arguments2);
      })["finally"](function() {
        _this4.setParametersPromises = [];
      });
    }
    return origCreateOffer.apply(this, arguments);
  };
}
function shimCreateAnswer(window2) {
  if (!(_typeof(window2) === "object" && window2.RTCPeerConnection)) {
    return;
  }
  var origCreateAnswer = window2.RTCPeerConnection.prototype.createAnswer;
  window2.RTCPeerConnection.prototype.createAnswer = function createAnswer() {
    var _arguments3 = arguments, _this5 = this;
    if (this.setParametersPromises && this.setParametersPromises.length) {
      return Promise.all(this.setParametersPromises).then(function() {
        return origCreateAnswer.apply(_this5, _arguments3);
      })["finally"](function() {
        _this5.setParametersPromises = [];
      });
    }
    return origCreateAnswer.apply(this, arguments);
  };
}
var firefoxShim = Object.freeze({
  __proto__: null,
  shimAddTransceiver,
  shimCreateAnswer,
  shimCreateOffer,
  shimGetDisplayMedia,
  shimGetParameters,
  shimGetUserMedia: shimGetUserMedia$1,
  shimOnTrack,
  shimPeerConnection,
  shimRTCDataChannel,
  shimReceiverGetStats,
  shimRemoveStream,
  shimSenderGetStats
});
function shimLocalStreamsAPI(window2) {
  if (_typeof(window2) !== "object" || !window2.RTCPeerConnection) {
    return;
  }
  if (!("getLocalStreams" in window2.RTCPeerConnection.prototype)) {
    window2.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
      if (!this._localStreams) {
        this._localStreams = [];
      }
      return this._localStreams;
    };
  }
  if (!("addStream" in window2.RTCPeerConnection.prototype)) {
    var _addTrack = window2.RTCPeerConnection.prototype.addTrack;
    window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {
      var _this = this;
      if (!this._localStreams) {
        this._localStreams = [];
      }
      if (!this._localStreams.includes(stream)) {
        this._localStreams.push(stream);
      }
      stream.getAudioTracks().forEach(function(track) {
        return _addTrack.call(_this, track, stream);
      });
      stream.getVideoTracks().forEach(function(track) {
        return _addTrack.call(_this, track, stream);
      });
    };
    window2.RTCPeerConnection.prototype.addTrack = function addTrack(track) {
      var _this2 = this;
      for (var _len = arguments.length, streams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        streams[_key - 1] = arguments[_key];
      }
      if (streams) {
        streams.forEach(function(stream) {
          if (!_this2._localStreams) {
            _this2._localStreams = [stream];
          } else if (!_this2._localStreams.includes(stream)) {
            _this2._localStreams.push(stream);
          }
        });
      }
      return _addTrack.apply(this, arguments);
    };
  }
  if (!("removeStream" in window2.RTCPeerConnection.prototype)) {
    window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
      var _this3 = this;
      if (!this._localStreams) {
        this._localStreams = [];
      }
      var index = this._localStreams.indexOf(stream);
      if (index === -1) {
        return;
      }
      this._localStreams.splice(index, 1);
      var tracks = stream.getTracks();
      this.getSenders().forEach(function(sender) {
        if (tracks.includes(sender.track)) {
          _this3.removeTrack(sender);
        }
      });
    };
  }
}
function shimRemoteStreamsAPI(window2) {
  if (_typeof(window2) !== "object" || !window2.RTCPeerConnection) {
    return;
  }
  if (!("getRemoteStreams" in window2.RTCPeerConnection.prototype)) {
    window2.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {
      return this._remoteStreams ? this._remoteStreams : [];
    };
  }
  if (!("onaddstream" in window2.RTCPeerConnection.prototype)) {
    Object.defineProperty(window2.RTCPeerConnection.prototype, "onaddstream", {
      get: function get2() {
        return this._onaddstream;
      },
      set: function set2(f) {
        var _this4 = this;
        if (this._onaddstream) {
          this.removeEventListener("addstream", this._onaddstream);
          this.removeEventListener("track", this._onaddstreampoly);
        }
        this.addEventListener("addstream", this._onaddstream = f);
        this.addEventListener("track", this._onaddstreampoly = function(e) {
          e.streams.forEach(function(stream) {
            if (!_this4._remoteStreams) {
              _this4._remoteStreams = [];
            }
            if (_this4._remoteStreams.includes(stream)) {
              return;
            }
            _this4._remoteStreams.push(stream);
            var event = new Event("addstream");
            event.stream = stream;
            _this4.dispatchEvent(event);
          });
        });
      }
    });
    var origSetRemoteDescription = window2.RTCPeerConnection.prototype.setRemoteDescription;
    window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
      var pc = this;
      if (!this._onaddstreampoly) {
        this.addEventListener("track", this._onaddstreampoly = function(e) {
          e.streams.forEach(function(stream) {
            if (!pc._remoteStreams) {
              pc._remoteStreams = [];
            }
            if (pc._remoteStreams.indexOf(stream) >= 0) {
              return;
            }
            pc._remoteStreams.push(stream);
            var event = new Event("addstream");
            event.stream = stream;
            pc.dispatchEvent(event);
          });
        });
      }
      return origSetRemoteDescription.apply(pc, arguments);
    };
  }
}
function shimCallbacksAPI(window2) {
  if (_typeof(window2) !== "object" || !window2.RTCPeerConnection) {
    return;
  }
  var prototype = window2.RTCPeerConnection.prototype;
  var origCreateOffer = prototype.createOffer;
  var origCreateAnswer = prototype.createAnswer;
  var setLocalDescription = prototype.setLocalDescription;
  var setRemoteDescription = prototype.setRemoteDescription;
  var addIceCandidate = prototype.addIceCandidate;
  prototype.createOffer = function createOffer(successCallback, failureCallback) {
    var options = arguments.length >= 2 ? arguments[2] : arguments[0];
    var promise = origCreateOffer.apply(this, [options]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.createAnswer = function createAnswer(successCallback, failureCallback) {
    var options = arguments.length >= 2 ? arguments[2] : arguments[0];
    var promise = origCreateAnswer.apply(this, [options]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  var withCallback = function withCallback2(description, successCallback, failureCallback) {
    var promise = setLocalDescription.apply(this, [description]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.setLocalDescription = withCallback;
  withCallback = function withCallback2(description, successCallback, failureCallback) {
    var promise = setRemoteDescription.apply(this, [description]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.setRemoteDescription = withCallback;
  withCallback = function withCallback2(candidate, successCallback, failureCallback) {
    var promise = addIceCandidate.apply(this, [candidate]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.addIceCandidate = withCallback;
}
function shimGetUserMedia(window2) {
  var navigator2 = window2 && window2.navigator;
  if (navigator2.mediaDevices && navigator2.mediaDevices.getUserMedia) {
    var mediaDevices = navigator2.mediaDevices;
    var _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);
    navigator2.mediaDevices.getUserMedia = function(constraints) {
      return _getUserMedia(shimConstraints(constraints));
    };
  }
  if (!navigator2.getUserMedia && navigator2.mediaDevices && navigator2.mediaDevices.getUserMedia) {
    navigator2.getUserMedia = (function getUserMedia(constraints, cb, errcb) {
      navigator2.mediaDevices.getUserMedia(constraints).then(cb, errcb);
    }).bind(navigator2);
  }
}
function shimConstraints(constraints) {
  if (constraints && constraints.video !== void 0) {
    return Object.assign({}, constraints, {
      video: compactObject(constraints.video)
    });
  }
  return constraints;
}
function shimRTCIceServerUrls(window2) {
  if (!window2.RTCPeerConnection) {
    return;
  }
  var OrigPeerConnection = window2.RTCPeerConnection;
  window2.RTCPeerConnection = function RTCPeerConnection2(pcConfig, pcConstraints) {
    if (pcConfig && pcConfig.iceServers) {
      var newIceServers = [];
      for (var i = 0; i < pcConfig.iceServers.length; i++) {
        var server = pcConfig.iceServers[i];
        if (server.urls === void 0 && server.url) {
          deprecated("RTCIceServer.url", "RTCIceServer.urls");
          server = JSON.parse(JSON.stringify(server));
          server.urls = server.url;
          delete server.url;
          newIceServers.push(server);
        } else {
          newIceServers.push(pcConfig.iceServers[i]);
        }
      }
      pcConfig.iceServers = newIceServers;
    }
    return new OrigPeerConnection(pcConfig, pcConstraints);
  };
  window2.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
  if ("generateCertificate" in OrigPeerConnection) {
    Object.defineProperty(window2.RTCPeerConnection, "generateCertificate", {
      get: function get2() {
        return OrigPeerConnection.generateCertificate;
      }
    });
  }
}
function shimTrackEventTransceiver(window2) {
  if (_typeof(window2) === "object" && window2.RTCTrackEvent && "receiver" in window2.RTCTrackEvent.prototype && !("transceiver" in window2.RTCTrackEvent.prototype)) {
    Object.defineProperty(window2.RTCTrackEvent.prototype, "transceiver", {
      get: function get2() {
        return {
          receiver: this.receiver
        };
      }
    });
  }
}
function shimCreateOfferLegacy(window2) {
  var origCreateOffer = window2.RTCPeerConnection.prototype.createOffer;
  window2.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {
    if (offerOptions) {
      if (typeof offerOptions.offerToReceiveAudio !== "undefined") {
        offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;
      }
      var audioTransceiver = this.getTransceivers().find(function(transceiver) {
        return transceiver.receiver.track.kind === "audio";
      });
      if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
        if (audioTransceiver.direction === "sendrecv") {
          if (audioTransceiver.setDirection) {
            audioTransceiver.setDirection("sendonly");
          } else {
            audioTransceiver.direction = "sendonly";
          }
        } else if (audioTransceiver.direction === "recvonly") {
          if (audioTransceiver.setDirection) {
            audioTransceiver.setDirection("inactive");
          } else {
            audioTransceiver.direction = "inactive";
          }
        }
      } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {
        this.addTransceiver("audio", {
          direction: "recvonly"
        });
      }
      if (typeof offerOptions.offerToReceiveVideo !== "undefined") {
        offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;
      }
      var videoTransceiver = this.getTransceivers().find(function(transceiver) {
        return transceiver.receiver.track.kind === "video";
      });
      if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
        if (videoTransceiver.direction === "sendrecv") {
          if (videoTransceiver.setDirection) {
            videoTransceiver.setDirection("sendonly");
          } else {
            videoTransceiver.direction = "sendonly";
          }
        } else if (videoTransceiver.direction === "recvonly") {
          if (videoTransceiver.setDirection) {
            videoTransceiver.setDirection("inactive");
          } else {
            videoTransceiver.direction = "inactive";
          }
        }
      } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {
        this.addTransceiver("video", {
          direction: "recvonly"
        });
      }
    }
    return origCreateOffer.apply(this, arguments);
  };
}
function shimAudioContext(window2) {
  if (_typeof(window2) !== "object" || window2.AudioContext) {
    return;
  }
  window2.AudioContext = window2.webkitAudioContext;
}
var safariShim = Object.freeze({
  __proto__: null,
  shimAudioContext,
  shimCallbacksAPI,
  shimConstraints,
  shimCreateOfferLegacy,
  shimGetUserMedia,
  shimLocalStreamsAPI,
  shimRTCIceServerUrls,
  shimRemoteStreamsAPI,
  shimTrackEventTransceiver
});
var sdp$1 = { exports: {} };
(function(module) {
  var SDPUtils2 = {};
  SDPUtils2.generateIdentifier = function() {
    return Math.random().toString(36).substring(2, 12);
  };
  SDPUtils2.localCName = SDPUtils2.generateIdentifier();
  SDPUtils2.splitLines = function(blob) {
    return blob.trim().split("\n").map(function(line) {
      return line.trim();
    });
  };
  SDPUtils2.splitSections = function(blob) {
    var parts = blob.split("\nm=");
    return parts.map(function(part, index) {
      return (index > 0 ? "m=" + part : part).trim() + "\r\n";
    });
  };
  SDPUtils2.getDescription = function(blob) {
    var sections = SDPUtils2.splitSections(blob);
    return sections && sections[0];
  };
  SDPUtils2.getMediaSections = function(blob) {
    var sections = SDPUtils2.splitSections(blob);
    sections.shift();
    return sections;
  };
  SDPUtils2.matchPrefix = function(blob, prefix) {
    return SDPUtils2.splitLines(blob).filter(function(line) {
      return line.indexOf(prefix) === 0;
    });
  };
  SDPUtils2.parseCandidate = function(line) {
    var parts;
    if (line.indexOf("a=candidate:") === 0) {
      parts = line.substring(12).split(" ");
    } else {
      parts = line.substring(10).split(" ");
    }
    var candidate = {
      foundation: parts[0],
      component: {
        1: "rtp",
        2: "rtcp"
      }[parts[1]] || parts[1],
      protocol: parts[2].toLowerCase(),
      priority: parseInt(parts[3], 10),
      ip: parts[4],
      address: parts[4],
      // address is an alias for ip.
      port: parseInt(parts[5], 10),
      // skip parts[6] == 'typ'
      type: parts[7]
    };
    for (var i = 8; i < parts.length; i += 2) {
      switch (parts[i]) {
        case "raddr":
          candidate.relatedAddress = parts[i + 1];
          break;
        case "rport":
          candidate.relatedPort = parseInt(parts[i + 1], 10);
          break;
        case "tcptype":
          candidate.tcpType = parts[i + 1];
          break;
        case "ufrag":
          candidate.ufrag = parts[i + 1];
          candidate.usernameFragment = parts[i + 1];
          break;
        default:
          if (candidate[parts[i]] === void 0) {
            candidate[parts[i]] = parts[i + 1];
          }
          break;
      }
    }
    return candidate;
  };
  SDPUtils2.writeCandidate = function(candidate) {
    var sdp2 = [];
    sdp2.push(candidate.foundation);
    var component = candidate.component;
    if (component === "rtp") {
      sdp2.push(1);
    } else if (component === "rtcp") {
      sdp2.push(2);
    } else {
      sdp2.push(component);
    }
    sdp2.push(candidate.protocol.toUpperCase());
    sdp2.push(candidate.priority);
    sdp2.push(candidate.address || candidate.ip);
    sdp2.push(candidate.port);
    var type = candidate.type;
    sdp2.push("typ");
    sdp2.push(type);
    if (type !== "host" && candidate.relatedAddress && candidate.relatedPort) {
      sdp2.push("raddr");
      sdp2.push(candidate.relatedAddress);
      sdp2.push("rport");
      sdp2.push(candidate.relatedPort);
    }
    if (candidate.tcpType && candidate.protocol.toLowerCase() === "tcp") {
      sdp2.push("tcptype");
      sdp2.push(candidate.tcpType);
    }
    if (candidate.usernameFragment || candidate.ufrag) {
      sdp2.push("ufrag");
      sdp2.push(candidate.usernameFragment || candidate.ufrag);
    }
    return "candidate:" + sdp2.join(" ");
  };
  SDPUtils2.parseIceOptions = function(line) {
    return line.substring(14).split(" ");
  };
  SDPUtils2.parseRtpMap = function(line) {
    var parts = line.substring(9).split(" ");
    var parsed = {
      payloadType: parseInt(parts.shift(), 10)
      // was: id
    };
    parts = parts[0].split("/");
    parsed.name = parts[0];
    parsed.clockRate = parseInt(parts[1], 10);
    parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
    parsed.numChannels = parsed.channels;
    return parsed;
  };
  SDPUtils2.writeRtpMap = function(codec) {
    var pt = codec.payloadType;
    if (codec.preferredPayloadType !== void 0) {
      pt = codec.preferredPayloadType;
    }
    var channels = codec.channels || codec.numChannels || 1;
    return "a=rtpmap:" + pt + " " + codec.name + "/" + codec.clockRate + (channels !== 1 ? "/" + channels : "") + "\r\n";
  };
  SDPUtils2.parseExtmap = function(line) {
    var parts = line.substring(9).split(" ");
    return {
      id: parseInt(parts[0], 10),
      direction: parts[0].indexOf("/") > 0 ? parts[0].split("/")[1] : "sendrecv",
      uri: parts[1],
      attributes: parts.slice(2).join(" ")
    };
  };
  SDPUtils2.writeExtmap = function(headerExtension) {
    return "a=extmap:" + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== "sendrecv" ? "/" + headerExtension.direction : "") + " " + headerExtension.uri + (headerExtension.attributes ? " " + headerExtension.attributes : "") + "\r\n";
  };
  SDPUtils2.parseFmtp = function(line) {
    var parsed = {};
    var kv;
    var parts = line.substring(line.indexOf(" ") + 1).split(";");
    for (var j = 0; j < parts.length; j++) {
      kv = parts[j].trim().split("=");
      parsed[kv[0].trim()] = kv[1];
    }
    return parsed;
  };
  SDPUtils2.writeFmtp = function(codec) {
    var line = "";
    var pt = codec.payloadType;
    if (codec.preferredPayloadType !== void 0) {
      pt = codec.preferredPayloadType;
    }
    if (codec.parameters && Object.keys(codec.parameters).length) {
      var params = [];
      Object.keys(codec.parameters).forEach(function(param) {
        if (codec.parameters[param] !== void 0) {
          params.push(param + "=" + codec.parameters[param]);
        } else {
          params.push(param);
        }
      });
      line += "a=fmtp:" + pt + " " + params.join(";") + "\r\n";
    }
    return line;
  };
  SDPUtils2.parseRtcpFb = function(line) {
    var parts = line.substring(line.indexOf(" ") + 1).split(" ");
    return {
      type: parts.shift(),
      parameter: parts.join(" ")
    };
  };
  SDPUtils2.writeRtcpFb = function(codec) {
    var lines = "";
    var pt = codec.payloadType;
    if (codec.preferredPayloadType !== void 0) {
      pt = codec.preferredPayloadType;
    }
    if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
      codec.rtcpFeedback.forEach(function(fb) {
        lines += "a=rtcp-fb:" + pt + " " + fb.type + (fb.parameter && fb.parameter.length ? " " + fb.parameter : "") + "\r\n";
      });
    }
    return lines;
  };
  SDPUtils2.parseSsrcMedia = function(line) {
    var sp = line.indexOf(" ");
    var parts = {
      ssrc: parseInt(line.substring(7, sp), 10)
    };
    var colon = line.indexOf(":", sp);
    if (colon > -1) {
      parts.attribute = line.substring(sp + 1, colon);
      parts.value = line.substring(colon + 1);
    } else {
      parts.attribute = line.substring(sp + 1);
    }
    return parts;
  };
  SDPUtils2.parseSsrcGroup = function(line) {
    var parts = line.substring(13).split(" ");
    return {
      semantics: parts.shift(),
      ssrcs: parts.map(function(ssrc) {
        return parseInt(ssrc, 10);
      })
    };
  };
  SDPUtils2.getMid = function(mediaSection) {
    var mid = SDPUtils2.matchPrefix(mediaSection, "a=mid:")[0];
    if (mid) {
      return mid.substring(6);
    }
  };
  SDPUtils2.parseFingerprint = function(line) {
    var parts = line.substring(14).split(" ");
    return {
      algorithm: parts[0].toLowerCase(),
      // algorithm is case-sensitive in Edge.
      value: parts[1].toUpperCase()
      // the definition is upper-case in RFC 4572.
    };
  };
  SDPUtils2.getDtlsParameters = function(mediaSection, sessionpart) {
    var lines = SDPUtils2.matchPrefix(mediaSection + sessionpart, "a=fingerprint:");
    return {
      role: "auto",
      fingerprints: lines.map(SDPUtils2.parseFingerprint)
    };
  };
  SDPUtils2.writeDtlsParameters = function(params, setupType) {
    var sdp2 = "a=setup:" + setupType + "\r\n";
    params.fingerprints.forEach(function(fp) {
      sdp2 += "a=fingerprint:" + fp.algorithm + " " + fp.value + "\r\n";
    });
    return sdp2;
  };
  SDPUtils2.parseCryptoLine = function(line) {
    var parts = line.substring(9).split(" ");
    return {
      tag: parseInt(parts[0], 10),
      cryptoSuite: parts[1],
      keyParams: parts[2],
      sessionParams: parts.slice(3)
    };
  };
  SDPUtils2.writeCryptoLine = function(parameters) {
    return "a=crypto:" + parameters.tag + " " + parameters.cryptoSuite + " " + (_typeof(parameters.keyParams) === "object" ? SDPUtils2.writeCryptoKeyParams(parameters.keyParams) : parameters.keyParams) + (parameters.sessionParams ? " " + parameters.sessionParams.join(" ") : "") + "\r\n";
  };
  SDPUtils2.parseCryptoKeyParams = function(keyParams) {
    if (keyParams.indexOf("inline:") !== 0) {
      return null;
    }
    var parts = keyParams.substring(7).split("|");
    return {
      keyMethod: "inline",
      keySalt: parts[0],
      lifeTime: parts[1],
      mkiValue: parts[2] ? parts[2].split(":")[0] : void 0,
      mkiLength: parts[2] ? parts[2].split(":")[1] : void 0
    };
  };
  SDPUtils2.writeCryptoKeyParams = function(keyParams) {
    return keyParams.keyMethod + ":" + keyParams.keySalt + (keyParams.lifeTime ? "|" + keyParams.lifeTime : "") + (keyParams.mkiValue && keyParams.mkiLength ? "|" + keyParams.mkiValue + ":" + keyParams.mkiLength : "");
  };
  SDPUtils2.getCryptoParameters = function(mediaSection, sessionpart) {
    var lines = SDPUtils2.matchPrefix(mediaSection + sessionpart, "a=crypto:");
    return lines.map(SDPUtils2.parseCryptoLine);
  };
  SDPUtils2.getIceParameters = function(mediaSection, sessionpart) {
    var ufrag = SDPUtils2.matchPrefix(mediaSection + sessionpart, "a=ice-ufrag:")[0];
    var pwd = SDPUtils2.matchPrefix(mediaSection + sessionpart, "a=ice-pwd:")[0];
    if (!(ufrag && pwd)) {
      return null;
    }
    return {
      usernameFragment: ufrag.substring(12),
      password: pwd.substring(10)
    };
  };
  SDPUtils2.writeIceParameters = function(params) {
    var sdp2 = "a=ice-ufrag:" + params.usernameFragment + "\r\na=ice-pwd:" + params.password + "\r\n";
    if (params.iceLite) {
      sdp2 += "a=ice-lite\r\n";
    }
    return sdp2;
  };
  SDPUtils2.parseRtpParameters = function(mediaSection) {
    var description = {
      codecs: [],
      headerExtensions: [],
      fecMechanisms: [],
      rtcp: []
    };
    var lines = SDPUtils2.splitLines(mediaSection);
    var mline = lines[0].split(" ");
    description.profile = mline[2];
    for (var i = 3; i < mline.length; i++) {
      var pt = mline[i];
      var rtpmapline = SDPUtils2.matchPrefix(mediaSection, "a=rtpmap:" + pt + " ")[0];
      if (rtpmapline) {
        var codec = SDPUtils2.parseRtpMap(rtpmapline);
        var fmtps = SDPUtils2.matchPrefix(mediaSection, "a=fmtp:" + pt + " ");
        codec.parameters = fmtps.length ? SDPUtils2.parseFmtp(fmtps[0]) : {};
        codec.rtcpFeedback = SDPUtils2.matchPrefix(mediaSection, "a=rtcp-fb:" + pt + " ").map(SDPUtils2.parseRtcpFb);
        description.codecs.push(codec);
        switch (codec.name.toUpperCase()) {
          case "RED":
          case "ULPFEC":
            description.fecMechanisms.push(codec.name.toUpperCase());
            break;
        }
      }
    }
    SDPUtils2.matchPrefix(mediaSection, "a=extmap:").forEach(function(line) {
      description.headerExtensions.push(SDPUtils2.parseExtmap(line));
    });
    var wildcardRtcpFb = SDPUtils2.matchPrefix(mediaSection, "a=rtcp-fb:* ").map(SDPUtils2.parseRtcpFb);
    description.codecs.forEach(function(codec2) {
      wildcardRtcpFb.forEach(function(fb) {
        var duplicate = codec2.rtcpFeedback.find(function(existingFeedback) {
          return existingFeedback.type === fb.type && existingFeedback.parameter === fb.parameter;
        });
        if (!duplicate) {
          codec2.rtcpFeedback.push(fb);
        }
      });
    });
    return description;
  };
  SDPUtils2.writeRtpDescription = function(kind, caps) {
    var sdp2 = "";
    sdp2 += "m=" + kind + " ";
    sdp2 += caps.codecs.length > 0 ? "9" : "0";
    sdp2 += " " + (caps.profile || "UDP/TLS/RTP/SAVPF") + " ";
    sdp2 += caps.codecs.map(function(codec) {
      if (codec.preferredPayloadType !== void 0) {
        return codec.preferredPayloadType;
      }
      return codec.payloadType;
    }).join(" ") + "\r\n";
    sdp2 += "c=IN IP4 0.0.0.0\r\n";
    sdp2 += "a=rtcp:9 IN IP4 0.0.0.0\r\n";
    caps.codecs.forEach(function(codec) {
      sdp2 += SDPUtils2.writeRtpMap(codec);
      sdp2 += SDPUtils2.writeFmtp(codec);
      sdp2 += SDPUtils2.writeRtcpFb(codec);
    });
    var maxptime = 0;
    caps.codecs.forEach(function(codec) {
      if (codec.maxptime > maxptime) {
        maxptime = codec.maxptime;
      }
    });
    if (maxptime > 0) {
      sdp2 += "a=maxptime:" + maxptime + "\r\n";
    }
    if (caps.headerExtensions) {
      caps.headerExtensions.forEach(function(extension) {
        sdp2 += SDPUtils2.writeExtmap(extension);
      });
    }
    return sdp2;
  };
  SDPUtils2.parseRtpEncodingParameters = function(mediaSection) {
    var encodingParameters = [];
    var description = SDPUtils2.parseRtpParameters(mediaSection);
    var hasRed = description.fecMechanisms.indexOf("RED") !== -1;
    var hasUlpfec = description.fecMechanisms.indexOf("ULPFEC") !== -1;
    var ssrcs = SDPUtils2.matchPrefix(mediaSection, "a=ssrc:").map(function(line) {
      return SDPUtils2.parseSsrcMedia(line);
    }).filter(function(parts) {
      return parts.attribute === "cname";
    });
    var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
    var secondarySsrc;
    var flows = SDPUtils2.matchPrefix(mediaSection, "a=ssrc-group:FID").map(function(line) {
      var parts = line.substring(17).split(" ");
      return parts.map(function(part) {
        return parseInt(part, 10);
      });
    });
    if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
      secondarySsrc = flows[0][1];
    }
    description.codecs.forEach(function(codec) {
      if (codec.name.toUpperCase() === "RTX" && codec.parameters.apt) {
        var encParam = {
          ssrc: primarySsrc,
          codecPayloadType: parseInt(codec.parameters.apt, 10)
        };
        if (primarySsrc && secondarySsrc) {
          encParam.rtx = {
            ssrc: secondarySsrc
          };
        }
        encodingParameters.push(encParam);
        if (hasRed) {
          encParam = JSON.parse(JSON.stringify(encParam));
          encParam.fec = {
            ssrc: primarySsrc,
            mechanism: hasUlpfec ? "red+ulpfec" : "red"
          };
          encodingParameters.push(encParam);
        }
      }
    });
    if (encodingParameters.length === 0 && primarySsrc) {
      encodingParameters.push({
        ssrc: primarySsrc
      });
    }
    var bandwidth = SDPUtils2.matchPrefix(mediaSection, "b=");
    if (bandwidth.length) {
      if (bandwidth[0].indexOf("b=TIAS:") === 0) {
        bandwidth = parseInt(bandwidth[0].substring(7), 10);
      } else if (bandwidth[0].indexOf("b=AS:") === 0) {
        bandwidth = parseInt(bandwidth[0].substring(5), 10) * 1e3 * 0.95 - 50 * 40 * 8;
      } else {
        bandwidth = void 0;
      }
      encodingParameters.forEach(function(params) {
        params.maxBitrate = bandwidth;
      });
    }
    return encodingParameters;
  };
  SDPUtils2.parseRtcpParameters = function(mediaSection) {
    var rtcpParameters = {};
    var remoteSsrc = SDPUtils2.matchPrefix(mediaSection, "a=ssrc:").map(function(line) {
      return SDPUtils2.parseSsrcMedia(line);
    }).filter(function(obj) {
      return obj.attribute === "cname";
    })[0];
    if (remoteSsrc) {
      rtcpParameters.cname = remoteSsrc.value;
      rtcpParameters.ssrc = remoteSsrc.ssrc;
    }
    var rsize = SDPUtils2.matchPrefix(mediaSection, "a=rtcp-rsize");
    rtcpParameters.reducedSize = rsize.length > 0;
    rtcpParameters.compound = rsize.length === 0;
    var mux = SDPUtils2.matchPrefix(mediaSection, "a=rtcp-mux");
    rtcpParameters.mux = mux.length > 0;
    return rtcpParameters;
  };
  SDPUtils2.writeRtcpParameters = function(rtcpParameters) {
    var sdp2 = "";
    if (rtcpParameters.reducedSize) {
      sdp2 += "a=rtcp-rsize\r\n";
    }
    if (rtcpParameters.mux) {
      sdp2 += "a=rtcp-mux\r\n";
    }
    if (rtcpParameters.ssrc !== void 0 && rtcpParameters.cname) {
      sdp2 += "a=ssrc:" + rtcpParameters.ssrc + " cname:" + rtcpParameters.cname + "\r\n";
    }
    return sdp2;
  };
  SDPUtils2.parseMsid = function(mediaSection) {
    var parts;
    var spec = SDPUtils2.matchPrefix(mediaSection, "a=msid:");
    if (spec.length === 1) {
      parts = spec[0].substring(7).split(" ");
      return {
        stream: parts[0],
        track: parts[1]
      };
    }
    var planB = SDPUtils2.matchPrefix(mediaSection, "a=ssrc:").map(function(line) {
      return SDPUtils2.parseSsrcMedia(line);
    }).filter(function(msidParts) {
      return msidParts.attribute === "msid";
    });
    if (planB.length > 0) {
      parts = planB[0].value.split(" ");
      return {
        stream: parts[0],
        track: parts[1]
      };
    }
  };
  SDPUtils2.parseSctpDescription = function(mediaSection) {
    var mline = SDPUtils2.parseMLine(mediaSection);
    var maxSizeLine = SDPUtils2.matchPrefix(mediaSection, "a=max-message-size:");
    var maxMessageSize;
    if (maxSizeLine.length > 0) {
      maxMessageSize = parseInt(maxSizeLine[0].substring(19), 10);
    }
    if (isNaN(maxMessageSize)) {
      maxMessageSize = 65536;
    }
    var sctpPort = SDPUtils2.matchPrefix(mediaSection, "a=sctp-port:");
    if (sctpPort.length > 0) {
      return {
        port: parseInt(sctpPort[0].substring(12), 10),
        protocol: mline.fmt,
        maxMessageSize
      };
    }
    var sctpMapLines = SDPUtils2.matchPrefix(mediaSection, "a=sctpmap:");
    if (sctpMapLines.length > 0) {
      var parts = sctpMapLines[0].substring(10).split(" ");
      return {
        port: parseInt(parts[0], 10),
        protocol: parts[1],
        maxMessageSize
      };
    }
  };
  SDPUtils2.writeSctpDescription = function(media, sctp) {
    var output = [];
    if (media.protocol !== "DTLS/SCTP") {
      output = ["m=" + media.kind + " 9 " + media.protocol + " " + sctp.protocol + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctp-port:" + sctp.port + "\r\n"];
    } else {
      output = ["m=" + media.kind + " 9 " + media.protocol + " " + sctp.port + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctpmap:" + sctp.port + " " + sctp.protocol + " 65535\r\n"];
    }
    if (sctp.maxMessageSize !== void 0) {
      output.push("a=max-message-size:" + sctp.maxMessageSize + "\r\n");
    }
    return output.join("");
  };
  SDPUtils2.generateSessionId = function() {
    return Math.random().toString().substr(2, 22);
  };
  SDPUtils2.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {
    var sessionId;
    var version2 = sessVer !== void 0 ? sessVer : 2;
    if (sessId) {
      sessionId = sessId;
    } else {
      sessionId = SDPUtils2.generateSessionId();
    }
    var user = sessUser || "thisisadapterortc";
    return "v=0\r\no=" + user + " " + sessionId + " " + version2 + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n";
  };
  SDPUtils2.getDirection = function(mediaSection, sessionpart) {
    var lines = SDPUtils2.splitLines(mediaSection);
    for (var i = 0; i < lines.length; i++) {
      switch (lines[i]) {
        case "a=sendrecv":
        case "a=sendonly":
        case "a=recvonly":
        case "a=inactive":
          return lines[i].substring(2);
      }
    }
    if (sessionpart) {
      return SDPUtils2.getDirection(sessionpart);
    }
    return "sendrecv";
  };
  SDPUtils2.getKind = function(mediaSection) {
    var lines = SDPUtils2.splitLines(mediaSection);
    var mline = lines[0].split(" ");
    return mline[0].substring(2);
  };
  SDPUtils2.isRejected = function(mediaSection) {
    return mediaSection.split(" ", 2)[1] === "0";
  };
  SDPUtils2.parseMLine = function(mediaSection) {
    var lines = SDPUtils2.splitLines(mediaSection);
    var parts = lines[0].substring(2).split(" ");
    return {
      kind: parts[0],
      port: parseInt(parts[1], 10),
      protocol: parts[2],
      fmt: parts.slice(3).join(" ")
    };
  };
  SDPUtils2.parseOLine = function(mediaSection) {
    var line = SDPUtils2.matchPrefix(mediaSection, "o=")[0];
    var parts = line.substring(2).split(" ");
    return {
      username: parts[0],
      sessionId: parts[1],
      sessionVersion: parseInt(parts[2], 10),
      netType: parts[3],
      addressType: parts[4],
      address: parts[5]
    };
  };
  SDPUtils2.isValidSDP = function(blob) {
    if (typeof blob !== "string" || blob.length === 0) {
      return false;
    }
    var lines = SDPUtils2.splitLines(blob);
    for (var i = 0; i < lines.length; i++) {
      if (lines[i].length < 2 || lines[i].charAt(1) !== "=") {
        return false;
      }
    }
    return true;
  };
  {
    module.exports = SDPUtils2;
  }
})(sdp$1);
var sdpExports = sdp$1.exports;
var SDPUtils = getDefaultExportFromCjs(sdpExports);
var sdp = _mergeNamespaces({
  __proto__: null,
  default: SDPUtils
}, [sdpExports]);
function shimRTCIceCandidate(window2) {
  if (!window2.RTCIceCandidate || window2.RTCIceCandidate && "foundation" in window2.RTCIceCandidate.prototype) {
    return;
  }
  var NativeRTCIceCandidate = window2.RTCIceCandidate;
  window2.RTCIceCandidate = function RTCIceCandidate2(args) {
    if (_typeof(args) === "object" && args.candidate && args.candidate.indexOf("a=") === 0) {
      args = JSON.parse(JSON.stringify(args));
      args.candidate = args.candidate.substring(2);
    }
    if (args.candidate && args.candidate.length) {
      var nativeCandidate = new NativeRTCIceCandidate(args);
      var parsedCandidate = SDPUtils.parseCandidate(args.candidate);
      for (var key in parsedCandidate) {
        if (!(key in nativeCandidate)) {
          Object.defineProperty(nativeCandidate, key, {
            value: parsedCandidate[key]
          });
        }
      }
      nativeCandidate.toJSON = function toJSON() {
        return {
          candidate: nativeCandidate.candidate,
          sdpMid: nativeCandidate.sdpMid,
          sdpMLineIndex: nativeCandidate.sdpMLineIndex,
          usernameFragment: nativeCandidate.usernameFragment
        };
      };
      return nativeCandidate;
    }
    return new NativeRTCIceCandidate(args);
  };
  window2.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;
  wrapPeerConnectionEvent(window2, "icecandidate", function(e) {
    if (e.candidate) {
      Object.defineProperty(e, "candidate", {
        value: new window2.RTCIceCandidate(e.candidate),
        writable: "false"
      });
    }
    return e;
  });
}
function shimRTCIceCandidateRelayProtocol(window2) {
  if (!window2.RTCIceCandidate || window2.RTCIceCandidate && "relayProtocol" in window2.RTCIceCandidate.prototype) {
    return;
  }
  wrapPeerConnectionEvent(window2, "icecandidate", function(e) {
    if (e.candidate) {
      var parsedCandidate = SDPUtils.parseCandidate(e.candidate.candidate);
      if (parsedCandidate.type === "relay") {
        e.candidate.relayProtocol = {
          0: "tls",
          1: "tcp",
          2: "udp"
        }[parsedCandidate.priority >> 24];
      }
    }
    return e;
  });
}
function shimMaxMessageSize(window2, browserDetails2) {
  if (!window2.RTCPeerConnection) {
    return;
  }
  if (!("sctp" in window2.RTCPeerConnection.prototype)) {
    Object.defineProperty(window2.RTCPeerConnection.prototype, "sctp", {
      get: function get2() {
        return typeof this._sctp === "undefined" ? null : this._sctp;
      }
    });
  }
  var sctpInDescription = function sctpInDescription2(description) {
    if (!description || !description.sdp) {
      return false;
    }
    var sections = SDPUtils.splitSections(description.sdp);
    sections.shift();
    return sections.some(function(mediaSection) {
      var mLine = SDPUtils.parseMLine(mediaSection);
      return mLine && mLine.kind === "application" && mLine.protocol.indexOf("SCTP") !== -1;
    });
  };
  var getRemoteFirefoxVersion = function getRemoteFirefoxVersion2(description) {
    var match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
    if (match === null || match.length < 2) {
      return -1;
    }
    var version2 = parseInt(match[1], 10);
    return version2 !== version2 ? -1 : version2;
  };
  var getCanSendMaxMessageSize = function getCanSendMaxMessageSize2(remoteIsFirefox) {
    var canSendMaxMessageSize = 65536;
    if (browserDetails2.browser === "firefox") {
      if (browserDetails2.version < 57) {
        if (remoteIsFirefox === -1) {
          canSendMaxMessageSize = 16384;
        } else {
          canSendMaxMessageSize = 2147483637;
        }
      } else if (browserDetails2.version < 60) {
        canSendMaxMessageSize = browserDetails2.version === 57 ? 65535 : 65536;
      } else {
        canSendMaxMessageSize = 2147483637;
      }
    }
    return canSendMaxMessageSize;
  };
  var getMaxMessageSize = function getMaxMessageSize2(description, remoteIsFirefox) {
    var maxMessageSize = 65536;
    if (browserDetails2.browser === "firefox" && browserDetails2.version === 57) {
      maxMessageSize = 65535;
    }
    var match = SDPUtils.matchPrefix(description.sdp, "a=max-message-size:");
    if (match.length > 0) {
      maxMessageSize = parseInt(match[0].substring(19), 10);
    } else if (browserDetails2.browser === "firefox" && remoteIsFirefox !== -1) {
      maxMessageSize = 2147483637;
    }
    return maxMessageSize;
  };
  var origSetRemoteDescription = window2.RTCPeerConnection.prototype.setRemoteDescription;
  window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
    this._sctp = null;
    if (browserDetails2.browser === "chrome" && browserDetails2.version >= 76) {
      var _this$getConfiguratio = this.getConfiguration(), sdpSemantics = _this$getConfiguratio.sdpSemantics;
      if (sdpSemantics === "plan-b") {
        Object.defineProperty(this, "sctp", {
          get: function get2() {
            return typeof this._sctp === "undefined" ? null : this._sctp;
          },
          enumerable: true,
          configurable: true
        });
      }
    }
    if (sctpInDescription(arguments[0])) {
      var isFirefox = getRemoteFirefoxVersion(arguments[0]);
      var canSendMMS = getCanSendMaxMessageSize(isFirefox);
      var remoteMMS = getMaxMessageSize(arguments[0], isFirefox);
      var maxMessageSize;
      if (canSendMMS === 0 && remoteMMS === 0) {
        maxMessageSize = Number.POSITIVE_INFINITY;
      } else if (canSendMMS === 0 || remoteMMS === 0) {
        maxMessageSize = Math.max(canSendMMS, remoteMMS);
      } else {
        maxMessageSize = Math.min(canSendMMS, remoteMMS);
      }
      var sctp = {};
      Object.defineProperty(sctp, "maxMessageSize", {
        get: function get2() {
          return maxMessageSize;
        }
      });
      this._sctp = sctp;
    }
    return origSetRemoteDescription.apply(this, arguments);
  };
}
function shimSendThrowTypeError(window2) {
  if (!(window2.RTCPeerConnection && "createDataChannel" in window2.RTCPeerConnection.prototype)) {
    return;
  }
  function wrapDcSend(dc, pc) {
    var origDataChannelSend = dc.send;
    dc.send = function send() {
      var data = arguments[0];
      var length = data.length || data.size || data.byteLength;
      if (dc.readyState === "open" && pc.sctp && length > pc.sctp.maxMessageSize) {
        throw new TypeError("Message too large (can send a maximum of " + pc.sctp.maxMessageSize + " bytes)");
      }
      return origDataChannelSend.apply(dc, arguments);
    };
  }
  var origCreateDataChannel = window2.RTCPeerConnection.prototype.createDataChannel;
  window2.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {
    var dataChannel = origCreateDataChannel.apply(this, arguments);
    wrapDcSend(dataChannel, this);
    return dataChannel;
  };
  wrapPeerConnectionEvent(window2, "datachannel", function(e) {
    wrapDcSend(e.channel, e.target);
    return e;
  });
}
function shimConnectionState(window2) {
  if (!window2.RTCPeerConnection || "connectionState" in window2.RTCPeerConnection.prototype) {
    return;
  }
  var proto = window2.RTCPeerConnection.prototype;
  Object.defineProperty(proto, "connectionState", {
    get: function get2() {
      return {
        completed: "connected",
        checking: "connecting"
      }[this.iceConnectionState] || this.iceConnectionState;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(proto, "onconnectionstatechange", {
    get: function get2() {
      return this._onconnectionstatechange || null;
    },
    set: function set2(cb) {
      if (this._onconnectionstatechange) {
        this.removeEventListener("connectionstatechange", this._onconnectionstatechange);
        delete this._onconnectionstatechange;
      }
      if (cb) {
        this.addEventListener("connectionstatechange", this._onconnectionstatechange = cb);
      }
    },
    enumerable: true,
    configurable: true
  });
  ["setLocalDescription", "setRemoteDescription"].forEach(function(method) {
    var origMethod = proto[method];
    proto[method] = function() {
      if (!this._connectionstatechangepoly) {
        this._connectionstatechangepoly = function(e) {
          var pc = e.target;
          if (pc._lastConnectionState !== pc.connectionState) {
            pc._lastConnectionState = pc.connectionState;
            var newEvent = new Event("connectionstatechange", e);
            pc.dispatchEvent(newEvent);
          }
          return e;
        };
        this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly);
      }
      return origMethod.apply(this, arguments);
    };
  });
}
function removeExtmapAllowMixed(window2, browserDetails2) {
  if (!window2.RTCPeerConnection) {
    return;
  }
  if (browserDetails2.browser === "chrome" && browserDetails2.version >= 71) {
    return;
  }
  if (browserDetails2.browser === "safari" && browserDetails2._safariVersion >= 13.1) {
    return;
  }
  var nativeSRD = window2.RTCPeerConnection.prototype.setRemoteDescription;
  window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {
    if (desc && desc.sdp && desc.sdp.indexOf("\na=extmap-allow-mixed") !== -1) {
      var sdp2 = desc.sdp.split("\n").filter(function(line) {
        return line.trim() !== "a=extmap-allow-mixed";
      }).join("\n");
      if (window2.RTCSessionDescription && desc instanceof window2.RTCSessionDescription) {
        arguments[0] = new window2.RTCSessionDescription({
          type: desc.type,
          sdp: sdp2
        });
      } else {
        desc.sdp = sdp2;
      }
    }
    return nativeSRD.apply(this, arguments);
  };
}
function shimAddIceCandidateNullOrEmpty(window2, browserDetails2) {
  if (!(window2.RTCPeerConnection && window2.RTCPeerConnection.prototype)) {
    return;
  }
  var nativeAddIceCandidate = window2.RTCPeerConnection.prototype.addIceCandidate;
  if (!nativeAddIceCandidate || nativeAddIceCandidate.length === 0) {
    return;
  }
  window2.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {
    if (!arguments[0]) {
      if (arguments[1]) {
        arguments[1].apply(null);
      }
      return Promise.resolve();
    }
    if ((browserDetails2.browser === "chrome" && browserDetails2.version < 78 || browserDetails2.browser === "firefox" && browserDetails2.version < 68 || browserDetails2.browser === "safari") && arguments[0] && arguments[0].candidate === "") {
      return Promise.resolve();
    }
    return nativeAddIceCandidate.apply(this, arguments);
  };
}
function shimParameterlessSetLocalDescription(window2, browserDetails2) {
  if (!(window2.RTCPeerConnection && window2.RTCPeerConnection.prototype)) {
    return;
  }
  var nativeSetLocalDescription = window2.RTCPeerConnection.prototype.setLocalDescription;
  if (!nativeSetLocalDescription || nativeSetLocalDescription.length === 0) {
    return;
  }
  window2.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
    var _this = this;
    var desc = arguments[0] || {};
    if (_typeof(desc) !== "object" || desc.type && desc.sdp) {
      return nativeSetLocalDescription.apply(this, arguments);
    }
    desc = {
      type: desc.type,
      sdp: desc.sdp
    };
    if (!desc.type) {
      switch (this.signalingState) {
        case "stable":
        case "have-local-offer":
        case "have-remote-pranswer":
          desc.type = "offer";
          break;
        default:
          desc.type = "answer";
          break;
      }
    }
    if (desc.sdp || desc.type !== "offer" && desc.type !== "answer") {
      return nativeSetLocalDescription.apply(this, [desc]);
    }
    var func = desc.type === "offer" ? this.createOffer : this.createAnswer;
    return func.apply(this).then(function(d) {
      return nativeSetLocalDescription.apply(_this, [d]);
    });
  };
}
var commonShim = Object.freeze({
  __proto__: null,
  removeExtmapAllowMixed,
  shimAddIceCandidateNullOrEmpty,
  shimConnectionState,
  shimMaxMessageSize,
  shimParameterlessSetLocalDescription,
  shimRTCIceCandidate,
  shimRTCIceCandidateRelayProtocol,
  shimSendThrowTypeError
});
function adapterFactory() {
  var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, window2 = _ref.window;
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    shimChrome: true,
    shimFirefox: true,
    shimSafari: true
  };
  var logging2 = log;
  var browserDetails2 = detectBrowser(window2);
  var adapter = {
    browserDetails: browserDetails2,
    commonShim,
    extractVersion,
    disableLog,
    disableWarnings,
    // Expose sdp as a convenience. For production apps include directly.
    sdp
  };
  switch (browserDetails2.browser) {
    case "chrome":
      if (!chromeShim || !shimPeerConnection$1 || !options.shimChrome) {
        logging2("Chrome shim is not included in this adapter release.");
        return adapter;
      }
      if (browserDetails2.version === null) {
        logging2("Chrome shim can not determine version, not shimming.");
        return adapter;
      }
      logging2("adapter.js shimming chrome.");
      adapter.browserShim = chromeShim;
      shimAddIceCandidateNullOrEmpty(window2, browserDetails2);
      shimParameterlessSetLocalDescription(window2);
      shimGetUserMedia$2(window2, browserDetails2);
      shimMediaStream(window2);
      shimPeerConnection$1(window2, browserDetails2);
      shimOnTrack$1(window2);
      shimAddTrackRemoveTrack(window2, browserDetails2);
      shimGetSendersWithDtmf(window2);
      shimGetStats(window2);
      shimSenderReceiverGetStats(window2);
      fixNegotiationNeeded(window2, browserDetails2);
      shimRTCIceCandidate(window2);
      shimRTCIceCandidateRelayProtocol(window2);
      shimConnectionState(window2);
      shimMaxMessageSize(window2, browserDetails2);
      shimSendThrowTypeError(window2);
      removeExtmapAllowMixed(window2, browserDetails2);
      break;
    case "firefox":
      if (!firefoxShim || !shimPeerConnection || !options.shimFirefox) {
        logging2("Firefox shim is not included in this adapter release.");
        return adapter;
      }
      logging2("adapter.js shimming firefox.");
      adapter.browserShim = firefoxShim;
      shimAddIceCandidateNullOrEmpty(window2, browserDetails2);
      shimParameterlessSetLocalDescription(window2);
      shimGetUserMedia$1(window2, browserDetails2);
      shimPeerConnection(window2, browserDetails2);
      shimOnTrack(window2);
      shimRemoveStream(window2);
      shimSenderGetStats(window2);
      shimReceiverGetStats(window2);
      shimRTCDataChannel(window2);
      shimAddTransceiver(window2);
      shimGetParameters(window2);
      shimCreateOffer(window2);
      shimCreateAnswer(window2);
      shimRTCIceCandidate(window2);
      shimConnectionState(window2);
      shimMaxMessageSize(window2, browserDetails2);
      shimSendThrowTypeError(window2);
      break;
    case "safari":
      if (!safariShim || !options.shimSafari) {
        logging2("Safari shim is not included in this adapter release.");
        return adapter;
      }
      logging2("adapter.js shimming safari.");
      adapter.browserShim = safariShim;
      shimAddIceCandidateNullOrEmpty(window2, browserDetails2);
      shimParameterlessSetLocalDescription(window2);
      shimRTCIceServerUrls(window2);
      shimCreateOfferLegacy(window2);
      shimCallbacksAPI(window2);
      shimLocalStreamsAPI(window2);
      shimRemoteStreamsAPI(window2);
      shimTrackEventTransceiver(window2);
      shimGetUserMedia(window2);
      shimAudioContext(window2);
      shimRTCIceCandidate(window2);
      shimRTCIceCandidateRelayProtocol(window2);
      shimMaxMessageSize(window2, browserDetails2);
      shimSendThrowTypeError(window2);
      removeExtmapAllowMixed(window2, browserDetails2);
      break;
    default:
      logging2("Unsupported browser!");
      break;
  }
  return adapter;
}
adapterFactory({
  window: typeof window === "undefined" ? void 0 : window
});
var ENCRYPTION_ALGORITHM = "AES-GCM";
var DECRYPTION_FAILURE_TOLERANCE = 10;
var E2EE_FLAG = "lk_e2ee";
var SALT = "LKFrameEncryptionKey";
var KEY_PROVIDER_DEFAULTS = {
  sharedKey: false,
  ratchetSalt: SALT,
  ratchetWindowSize: 8,
  failureTolerance: DECRYPTION_FAILURE_TOLERANCE,
  keyringSize: 16
};
var KeyProviderEvent;
(function(KeyProviderEvent2) {
  KeyProviderEvent2["SetKey"] = "setKey";
  KeyProviderEvent2["RatchetRequest"] = "ratchetRequest";
  KeyProviderEvent2["KeyRatcheted"] = "keyRatcheted";
})(KeyProviderEvent || (KeyProviderEvent = {}));
var KeyHandlerEvent;
(function(KeyHandlerEvent2) {
  KeyHandlerEvent2["KeyRatcheted"] = "keyRatcheted";
})(KeyHandlerEvent || (KeyHandlerEvent = {}));
var EncryptionEvent;
(function(EncryptionEvent2) {
  EncryptionEvent2["ParticipantEncryptionStatusChanged"] = "participantEncryptionStatusChanged";
  EncryptionEvent2["EncryptionError"] = "encryptionError";
})(EncryptionEvent || (EncryptionEvent = {}));
var CryptorEvent;
(function(CryptorEvent2) {
  CryptorEvent2["Error"] = "cryptorError";
})(CryptorEvent || (CryptorEvent = {}));
function isE2EESupported() {
  return isInsertableStreamSupported() || isScriptTransformSupported();
}
function isScriptTransformSupported() {
  return typeof window.RTCRtpScriptTransform !== "undefined";
}
function isInsertableStreamSupported() {
  return typeof window.RTCRtpSender !== "undefined" && // @ts-ignore
  typeof window.RTCRtpSender.prototype.createEncodedStreams !== "undefined";
}
function isVideoFrame(frame) {
  return "type" in frame;
}
function importKey(keyBytes_1) {
  return __awaiter(this, arguments, void 0, function(keyBytes) {
    var algorithm = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      name: ENCRYPTION_ALGORITHM
    };
    var usage = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "encrypt";
    return _regenerator().m(function _callee() {
      return _regenerator().w(function(_context) {
        while (1) switch (_context.n) {
          case 0:
            return _context.a(2, crypto.subtle.importKey("raw", keyBytes, algorithm, false, usage === "derive" ? ["deriveBits", "deriveKey"] : ["encrypt", "decrypt"]));
        }
      }, _callee);
    })();
  });
}
function createKeyMaterialFromString(password) {
  return __awaiter(this, void 0, void 0, _regenerator().m(function _callee2() {
    var enc2, keyMaterial;
    return _regenerator().w(function(_context2) {
      while (1) switch (_context2.n) {
        case 0:
          enc2 = new TextEncoder();
          _context2.n = 1;
          return crypto.subtle.importKey("raw", enc2.encode(password), {
            name: "PBKDF2"
          }, false, ["deriveBits", "deriveKey"]);
        case 1:
          keyMaterial = _context2.v;
          return _context2.a(2, keyMaterial);
      }
    }, _callee2);
  }));
}
function createKeyMaterialFromBuffer(cryptoBuffer) {
  return __awaiter(this, void 0, void 0, _regenerator().m(function _callee3() {
    var keyMaterial;
    return _regenerator().w(function(_context3) {
      while (1) switch (_context3.n) {
        case 0:
          _context3.n = 1;
          return crypto.subtle.importKey("raw", cryptoBuffer, "HKDF", false, ["deriveBits", "deriveKey"]);
        case 1:
          keyMaterial = _context3.v;
          return _context3.a(2, keyMaterial);
      }
    }, _callee3);
  }));
}
function getAlgoOptions(algorithmName, salt) {
  var textEncoder = new TextEncoder();
  var encodedSalt = textEncoder.encode(salt);
  switch (algorithmName) {
    case "HKDF":
      return {
        name: "HKDF",
        salt: encodedSalt,
        hash: "SHA-256",
        info: new ArrayBuffer(128)
      };
    case "PBKDF2": {
      return {
        name: "PBKDF2",
        salt: encodedSalt,
        hash: "SHA-256",
        iterations: 1e5
      };
    }
    default:
      throw new Error("algorithm ".concat(algorithmName, " is currently unsupported"));
  }
}
function deriveKeys(material, salt) {
  return __awaiter(this, void 0, void 0, _regenerator().m(function _callee4() {
    var algorithmOptions, encryptionKey;
    return _regenerator().w(function(_context4) {
      while (1) switch (_context4.n) {
        case 0:
          algorithmOptions = getAlgoOptions(material.algorithm.name, salt);
          _context4.n = 1;
          return crypto.subtle.deriveKey(algorithmOptions, material, {
            name: ENCRYPTION_ALGORITHM,
            length: 128
          }, false, ["encrypt", "decrypt"]);
        case 1:
          encryptionKey = _context4.v;
          return _context4.a(2, {
            material,
            encryptionKey
          });
      }
    }, _callee4);
  }));
}
function createE2EEKey() {
  return window.crypto.getRandomValues(new Uint8Array(32));
}
function ratchet(material, salt) {
  return __awaiter(this, void 0, void 0, _regenerator().m(function _callee5() {
    var algorithmOptions;
    return _regenerator().w(function(_context5) {
      while (1) switch (_context5.n) {
        case 0:
          algorithmOptions = getAlgoOptions(material.algorithm.name, salt);
          return _context5.a(2, crypto.subtle.deriveBits(algorithmOptions, material, 256));
      }
    }, _callee5);
  }));
}
function needsRbspUnescaping(frameData) {
  for (var i = 0; i < frameData.length - 3; i++) {
    if (frameData[i] == 0 && frameData[i + 1] == 0 && frameData[i + 2] == 3) return true;
  }
  return false;
}
function parseRbsp(stream) {
  var dataOut = [];
  var length = stream.length;
  for (var i = 0; i < stream.length; ) {
    if (length - i >= 3 && !stream[i] && !stream[i + 1] && stream[i + 2] == 3) {
      dataOut.push(stream[i++]);
      dataOut.push(stream[i++]);
      i++;
    } else {
      dataOut.push(stream[i++]);
    }
  }
  return new Uint8Array(dataOut);
}
var kZerosInStartSequence = 2;
var kEmulationByte = 3;
function writeRbsp(data_in) {
  var dataOut = [];
  var numConsecutiveZeros = 0;
  for (var i = 0; i < data_in.length; ++i) {
    var _byte = data_in[i];
    if (_byte <= kEmulationByte && numConsecutiveZeros >= kZerosInStartSequence) {
      dataOut.push(kEmulationByte);
      numConsecutiveZeros = 0;
    }
    dataOut.push(_byte);
    if (_byte == 0) {
      ++numConsecutiveZeros;
    } else {
      numConsecutiveZeros = 0;
    }
  }
  return new Uint8Array(dataOut);
}
var BaseKeyProvider = function(_EventEmitter) {
  function BaseKeyProvider2() {
    var _this;
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, BaseKeyProvider2);
    _this = _callSuper(this, BaseKeyProvider2);
    _this.onKeyRatcheted = function(material, keyIndex) {
      livekitLogger.debug("key ratcheted event received", {
        material,
        keyIndex
      });
    };
    _this.keyInfoMap = /* @__PURE__ */ new Map();
    _this.options = Object.assign(Object.assign({}, KEY_PROVIDER_DEFAULTS), options);
    _this.on(KeyProviderEvent.KeyRatcheted, _this.onKeyRatcheted);
    return _this;
  }
  _inherits(BaseKeyProvider2, _EventEmitter);
  return _createClass(BaseKeyProvider2, [{
    key: "onSetEncryptionKey",
    value: function onSetEncryptionKey(key, participantIdentity, keyIndex) {
      var keyInfo = {
        key,
        participantIdentity,
        keyIndex
      };
      if (!this.options.sharedKey && !participantIdentity) {
        throw new Error("participant identity needs to be passed for encryption key if sharedKey option is false");
      }
      this.keyInfoMap.set("".concat(participantIdentity !== null && participantIdentity !== void 0 ? participantIdentity : "shared", "-").concat(keyIndex !== null && keyIndex !== void 0 ? keyIndex : 0), keyInfo);
      this.emit(KeyProviderEvent.SetKey, keyInfo);
    }
  }, {
    key: "getKeys",
    value: function getKeys() {
      return Array.from(this.keyInfoMap.values());
    }
  }, {
    key: "getOptions",
    value: function getOptions() {
      return this.options;
    }
  }, {
    key: "ratchetKey",
    value: function ratchetKey(participantIdentity, keyIndex) {
      this.emit(KeyProviderEvent.RatchetRequest, participantIdentity, keyIndex);
    }
  }]);
}(eventsExports.EventEmitter);
var ExternalE2EEKeyProvider = function(_BaseKeyProvider) {
  function ExternalE2EEKeyProvider2() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, ExternalE2EEKeyProvider2);
    var opts = Object.assign(Object.assign({}, options), {
      sharedKey: true,
      // for a shared key provider failing to decrypt for a specific participant
      // should not mark the key as invalid, so we accept wrong keys forever
      // and won't try to auto-ratchet
      ratchetWindowSize: 0,
      failureTolerance: -1
    });
    return _callSuper(this, ExternalE2EEKeyProvider2, [opts]);
  }
  _inherits(ExternalE2EEKeyProvider2, _BaseKeyProvider);
  return _createClass(ExternalE2EEKeyProvider2, [{
    key: "setKey",
    value: function setKey(key) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee() {
        var derivedKey, _t;
        return _regenerator().w(function(_context) {
          while (1) switch (_context.n) {
            case 0:
              if (!(typeof key === "string")) {
                _context.n = 2;
                break;
              }
              _context.n = 1;
              return createKeyMaterialFromString(key);
            case 1:
              _t = _context.v;
              _context.n = 4;
              break;
            case 2:
              _context.n = 3;
              return createKeyMaterialFromBuffer(key);
            case 3:
              _t = _context.v;
            case 4:
              derivedKey = _t;
              this.onSetEncryptionKey(derivedKey);
            case 5:
              return _context.a(2);
          }
        }, _callee, this);
      }));
    }
  }]);
}(BaseKeyProvider);
var LivekitError = function(_Error) {
  function LivekitError2(code, message) {
    var _this;
    _classCallCheck(this, LivekitError2);
    _this = _callSuper(this, LivekitError2, [message || "an error has occured"]);
    _this.code = code;
    return _this;
  }
  _inherits(LivekitError2, _Error);
  return _createClass(LivekitError2);
}(_wrapNativeSuper(Error));
var ConnectionError = function(_LivekitError) {
  function ConnectionError2(message, reason, status, context) {
    var _this2;
    _classCallCheck(this, ConnectionError2);
    _this2 = _callSuper(this, ConnectionError2, [1, message]);
    _this2.status = status;
    _this2.reason = reason;
    _this2.context = context;
    return _this2;
  }
  _inherits(ConnectionError2, _LivekitError);
  return _createClass(ConnectionError2);
}(LivekitError);
var DeviceUnsupportedError = function(_LivekitError2) {
  function DeviceUnsupportedError2(message) {
    _classCallCheck(this, DeviceUnsupportedError2);
    return _callSuper(this, DeviceUnsupportedError2, [21, message !== null && message !== void 0 ? message : "device is unsupported"]);
  }
  _inherits(DeviceUnsupportedError2, _LivekitError2);
  return _createClass(DeviceUnsupportedError2);
}(LivekitError);
var TrackInvalidError = function(_LivekitError3) {
  function TrackInvalidError2(message) {
    _classCallCheck(this, TrackInvalidError2);
    return _callSuper(this, TrackInvalidError2, [20, message !== null && message !== void 0 ? message : "track is invalid"]);
  }
  _inherits(TrackInvalidError2, _LivekitError3);
  return _createClass(TrackInvalidError2);
}(LivekitError);
var UnsupportedServer = function(_LivekitError4) {
  function UnsupportedServer2(message) {
    _classCallCheck(this, UnsupportedServer2);
    return _callSuper(this, UnsupportedServer2, [10, message !== null && message !== void 0 ? message : "unsupported server"]);
  }
  _inherits(UnsupportedServer2, _LivekitError4);
  return _createClass(UnsupportedServer2);
}(LivekitError);
var UnexpectedConnectionState = function(_LivekitError5) {
  function UnexpectedConnectionState2(message) {
    _classCallCheck(this, UnexpectedConnectionState2);
    return _callSuper(this, UnexpectedConnectionState2, [12, message !== null && message !== void 0 ? message : "unexpected connection state"]);
  }
  _inherits(UnexpectedConnectionState2, _LivekitError5);
  return _createClass(UnexpectedConnectionState2);
}(LivekitError);
var NegotiationError = function(_LivekitError6) {
  function NegotiationError2(message) {
    _classCallCheck(this, NegotiationError2);
    return _callSuper(this, NegotiationError2, [13, message !== null && message !== void 0 ? message : "unable to negotiate"]);
  }
  _inherits(NegotiationError2, _LivekitError6);
  return _createClass(NegotiationError2);
}(LivekitError);
var PublishDataError = function(_LivekitError7) {
  function PublishDataError2(message) {
    _classCallCheck(this, PublishDataError2);
    return _callSuper(this, PublishDataError2, [13, message !== null && message !== void 0 ? message : "unable to publish data"]);
  }
  _inherits(PublishDataError2, _LivekitError7);
  return _createClass(PublishDataError2);
}(LivekitError);
var SignalRequestError = function(_LivekitError8) {
  function SignalRequestError2(message, reason) {
    var _this3;
    _classCallCheck(this, SignalRequestError2);
    _this3 = _callSuper(this, SignalRequestError2, [15, message]);
    _this3.reason = reason;
    return _this3;
  }
  _inherits(SignalRequestError2, _LivekitError8);
  return _createClass(SignalRequestError2);
}(LivekitError);
var MediaDeviceFailure;
(function(MediaDeviceFailure2) {
  MediaDeviceFailure2["PermissionDenied"] = "PermissionDenied";
  MediaDeviceFailure2["NotFound"] = "NotFound";
  MediaDeviceFailure2["DeviceInUse"] = "DeviceInUse";
  MediaDeviceFailure2["Other"] = "Other";
})(MediaDeviceFailure || (MediaDeviceFailure = {}));
(function(MediaDeviceFailure2) {
  function getFailure(error) {
    if (error && "name" in error) {
      if (error.name === "NotFoundError" || error.name === "DevicesNotFoundError") {
        return MediaDeviceFailure2.NotFound;
      }
      if (error.name === "NotAllowedError" || error.name === "PermissionDeniedError") {
        return MediaDeviceFailure2.PermissionDenied;
      }
      if (error.name === "NotReadableError" || error.name === "TrackStartError") {
        return MediaDeviceFailure2.DeviceInUse;
      }
      return MediaDeviceFailure2.Other;
    }
  }
  MediaDeviceFailure2.getFailure = getFailure;
})(MediaDeviceFailure || (MediaDeviceFailure = {}));
var CryptorErrorReason;
(function(CryptorErrorReason2) {
  CryptorErrorReason2[CryptorErrorReason2["InvalidKey"] = 0] = "InvalidKey";
  CryptorErrorReason2[CryptorErrorReason2["MissingKey"] = 1] = "MissingKey";
  CryptorErrorReason2[CryptorErrorReason2["InternalError"] = 2] = "InternalError";
})(CryptorErrorReason || (CryptorErrorReason = {}));
var CryptorError = function(_LivekitError) {
  function CryptorError2(message) {
    var _this;
    var reason = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : CryptorErrorReason.InternalError;
    var participantIdentity = arguments.length > 2 ? arguments[2] : void 0;
    _classCallCheck(this, CryptorError2);
    _this = _callSuper(this, CryptorError2, [40, message]);
    _this.reason = reason;
    _this.participantIdentity = participantIdentity;
    return _this;
  }
  _inherits(CryptorError2, _LivekitError);
  return _createClass(CryptorError2);
}(LivekitError);
var RoomEvent;
(function(RoomEvent2) {
  RoomEvent2["Connected"] = "connected";
  RoomEvent2["Reconnecting"] = "reconnecting";
  RoomEvent2["SignalReconnecting"] = "signalReconnecting";
  RoomEvent2["Reconnected"] = "reconnected";
  RoomEvent2["Disconnected"] = "disconnected";
  RoomEvent2["ConnectionStateChanged"] = "connectionStateChanged";
  RoomEvent2["MediaDevicesChanged"] = "mediaDevicesChanged";
  RoomEvent2["ParticipantConnected"] = "participantConnected";
  RoomEvent2["ParticipantDisconnected"] = "participantDisconnected";
  RoomEvent2["TrackPublished"] = "trackPublished";
  RoomEvent2["TrackSubscribed"] = "trackSubscribed";
  RoomEvent2["TrackSubscriptionFailed"] = "trackSubscriptionFailed";
  RoomEvent2["TrackUnpublished"] = "trackUnpublished";
  RoomEvent2["TrackUnsubscribed"] = "trackUnsubscribed";
  RoomEvent2["TrackMuted"] = "trackMuted";
  RoomEvent2["TrackUnmuted"] = "trackUnmuted";
  RoomEvent2["LocalTrackPublished"] = "localTrackPublished";
  RoomEvent2["LocalTrackUnpublished"] = "localTrackUnpublished";
  RoomEvent2["LocalAudioSilenceDetected"] = "localAudioSilenceDetected";
  RoomEvent2["ActiveSpeakersChanged"] = "activeSpeakersChanged";
  RoomEvent2["ParticipantMetadataChanged"] = "participantMetadataChanged";
  RoomEvent2["ParticipantNameChanged"] = "participantNameChanged";
  RoomEvent2["ParticipantAttributesChanged"] = "participantAttributesChanged";
  RoomEvent2["RoomMetadataChanged"] = "roomMetadataChanged";
  RoomEvent2["DataReceived"] = "dataReceived";
  RoomEvent2["SipDTMFReceived"] = "sipDTMFReceived";
  RoomEvent2["TranscriptionReceived"] = "transcriptionReceived";
  RoomEvent2["ConnectionQualityChanged"] = "connectionQualityChanged";
  RoomEvent2["TrackStreamStateChanged"] = "trackStreamStateChanged";
  RoomEvent2["TrackSubscriptionPermissionChanged"] = "trackSubscriptionPermissionChanged";
  RoomEvent2["TrackSubscriptionStatusChanged"] = "trackSubscriptionStatusChanged";
  RoomEvent2["AudioPlaybackStatusChanged"] = "audioPlaybackChanged";
  RoomEvent2["VideoPlaybackStatusChanged"] = "videoPlaybackChanged";
  RoomEvent2["MediaDevicesError"] = "mediaDevicesError";
  RoomEvent2["ParticipantPermissionsChanged"] = "participantPermissionsChanged";
  RoomEvent2["SignalConnected"] = "signalConnected";
  RoomEvent2["RecordingStatusChanged"] = "recordingStatusChanged";
  RoomEvent2["ParticipantEncryptionStatusChanged"] = "participantEncryptionStatusChanged";
  RoomEvent2["EncryptionError"] = "encryptionError";
  RoomEvent2["DCBufferStatusChanged"] = "dcBufferStatusChanged";
  RoomEvent2["ActiveDeviceChanged"] = "activeDeviceChanged";
  RoomEvent2["ChatMessage"] = "chatMessage";
  RoomEvent2["ReconnectPrimaryDelay"] = "reconnectPrimaryDelay";
  RoomEvent2["ReconnectSecondaryDelay"] = "reconnectSecondaryDelay";
  RoomEvent2["ReconnectICEDelay"] = "reconnectICEDelay";
  RoomEvent2["LocalTrackSubscribed"] = "localTrackSubscribed";
  RoomEvent2["MetricsReceived"] = "metricsReceived";
})(RoomEvent || (RoomEvent = {}));
var ParticipantEvent;
(function(ParticipantEvent2) {
  ParticipantEvent2["TrackPublished"] = "trackPublished";
  ParticipantEvent2["TrackSubscribed"] = "trackSubscribed";
  ParticipantEvent2["TrackSubscriptionFailed"] = "trackSubscriptionFailed";
  ParticipantEvent2["TrackUnpublished"] = "trackUnpublished";
  ParticipantEvent2["TrackUnsubscribed"] = "trackUnsubscribed";
  ParticipantEvent2["TrackMuted"] = "trackMuted";
  ParticipantEvent2["TrackUnmuted"] = "trackUnmuted";
  ParticipantEvent2["LocalTrackPublished"] = "localTrackPublished";
  ParticipantEvent2["LocalTrackUnpublished"] = "localTrackUnpublished";
  ParticipantEvent2["ParticipantMetadataChanged"] = "participantMetadataChanged";
  ParticipantEvent2["ParticipantNameChanged"] = "participantNameChanged";
  ParticipantEvent2["DataReceived"] = "dataReceived";
  ParticipantEvent2["SipDTMFReceived"] = "sipDTMFReceived";
  ParticipantEvent2["TranscriptionReceived"] = "transcriptionReceived";
  ParticipantEvent2["IsSpeakingChanged"] = "isSpeakingChanged";
  ParticipantEvent2["ConnectionQualityChanged"] = "connectionQualityChanged";
  ParticipantEvent2["TrackStreamStateChanged"] = "trackStreamStateChanged";
  ParticipantEvent2["TrackSubscriptionPermissionChanged"] = "trackSubscriptionPermissionChanged";
  ParticipantEvent2["TrackSubscriptionStatusChanged"] = "trackSubscriptionStatusChanged";
  ParticipantEvent2["MediaDevicesError"] = "mediaDevicesError";
  ParticipantEvent2["AudioStreamAcquired"] = "audioStreamAcquired";
  ParticipantEvent2["ParticipantPermissionsChanged"] = "participantPermissionsChanged";
  ParticipantEvent2["PCTrackAdded"] = "pcTrackAdded";
  ParticipantEvent2["AttributesChanged"] = "attributesChanged";
  ParticipantEvent2["ChatMessage"] = "chatMessage";
  ParticipantEvent2["LocalTrackSubscribed"] = "localTrackSubscribed";
})(ParticipantEvent || (ParticipantEvent = {}));
var EngineEvent;
(function(EngineEvent2) {
  EngineEvent2["TransportsCreated"] = "transportsCreated";
  EngineEvent2["Connected"] = "connected";
  EngineEvent2["Disconnected"] = "disconnected";
  EngineEvent2["Resuming"] = "resuming";
  EngineEvent2["Resumed"] = "resumed";
  EngineEvent2["Restarting"] = "restarting";
  EngineEvent2["Restarted"] = "restarted";
  EngineEvent2["SignalResumed"] = "signalResumed";
  EngineEvent2["SignalRestarted"] = "signalRestarted";
  EngineEvent2["Closing"] = "closing";
  EngineEvent2["MediaTrackAdded"] = "mediaTrackAdded";
  EngineEvent2["ActiveSpeakersUpdate"] = "activeSpeakersUpdate";
  EngineEvent2["DataPacketReceived"] = "dataPacketReceived";
  EngineEvent2["PrimaryDelay"] = "primaryDelay";
  EngineEvent2["SecondaryDelay"] = "secondaryDelay";
  EngineEvent2["TranscriptionReceived"] = "transcriptionReceived";
  EngineEvent2["RTPVideoMapUpdate"] = "rtpVideoMapUpdate";
  EngineEvent2["DCBufferStatusChanged"] = "dcBufferStatusChanged";
  EngineEvent2["ParticipantUpdate"] = "participantUpdate";
  EngineEvent2["RoomUpdate"] = "roomUpdate";
  EngineEvent2["SpeakersChanged"] = "speakersChanged";
  EngineEvent2["StreamStateChanged"] = "streamStateChanged";
  EngineEvent2["ConnectionQualityUpdate"] = "connectionQualityUpdate";
  EngineEvent2["SubscriptionError"] = "subscriptionError";
  EngineEvent2["SubscriptionPermissionUpdate"] = "subscriptionPermissionUpdate";
  EngineEvent2["RemoteMute"] = "remoteMute";
  EngineEvent2["SubscribedQualityUpdate"] = "subscribedQualityUpdate";
  EngineEvent2["LocalTrackUnpublished"] = "localTrackUnpublished";
  EngineEvent2["LocalTrackSubscribed"] = "localTrackSubscribed";
  EngineEvent2["Offline"] = "offline";
  EngineEvent2["SignalRequestResponse"] = "signalRequestResponse";
})(EngineEvent || (EngineEvent = {}));
var TrackEvent;
(function(TrackEvent2) {
  TrackEvent2["Message"] = "message";
  TrackEvent2["Muted"] = "muted";
  TrackEvent2["Unmuted"] = "unmuted";
  TrackEvent2["Restarted"] = "restarted";
  TrackEvent2["Ended"] = "ended";
  TrackEvent2["Subscribed"] = "subscribed";
  TrackEvent2["Unsubscribed"] = "unsubscribed";
  TrackEvent2["UpdateSettings"] = "updateSettings";
  TrackEvent2["UpdateSubscription"] = "updateSubscription";
  TrackEvent2["AudioPlaybackStarted"] = "audioPlaybackStarted";
  TrackEvent2["AudioPlaybackFailed"] = "audioPlaybackFailed";
  TrackEvent2["AudioSilenceDetected"] = "audioSilenceDetected";
  TrackEvent2["VisibilityChanged"] = "visibilityChanged";
  TrackEvent2["VideoDimensionsChanged"] = "videoDimensionsChanged";
  TrackEvent2["VideoPlaybackStarted"] = "videoPlaybackStarted";
  TrackEvent2["VideoPlaybackFailed"] = "videoPlaybackFailed";
  TrackEvent2["ElementAttached"] = "elementAttached";
  TrackEvent2["ElementDetached"] = "elementDetached";
  TrackEvent2["UpstreamPaused"] = "upstreamPaused";
  TrackEvent2["UpstreamResumed"] = "upstreamResumed";
  TrackEvent2["SubscriptionPermissionChanged"] = "subscriptionPermissionChanged";
  TrackEvent2["SubscriptionStatusChanged"] = "subscriptionStatusChanged";
  TrackEvent2["SubscriptionFailed"] = "subscriptionFailed";
  TrackEvent2["TrackProcessorUpdate"] = "trackProcessorUpdate";
  TrackEvent2["AudioTrackFeatureUpdate"] = "audioTrackFeatureUpdate";
  TrackEvent2["TranscriptionReceived"] = "transcriptionReceived";
  TrackEvent2["TimeSyncUpdate"] = "timeSyncUpdate";
})(TrackEvent || (TrackEvent = {}));
function r(r2, e, n) {
  var i, t, o;
  void 0 === e && (e = 50), void 0 === n && (n = {});
  var a = null != (i = n.isImmediate) && i, u = null != (t = n.callback) && t, c = n.maxWait, v = Date.now(), l = [];
  function f() {
    if (void 0 !== c) {
      var r3 = Date.now() - v;
      if (r3 + e >= c) return c - r3;
    }
    return e;
  }
  var d = function d2() {
    var e2 = [].slice.call(arguments), n2 = this;
    return new Promise(function(i2, t2) {
      var c2 = a && void 0 === o;
      if (void 0 !== o && clearTimeout(o), o = setTimeout(function() {
        if (o = void 0, v = Date.now(), !a) {
          var i3 = r2.apply(n2, e2);
          u && u(i3), l.forEach(function(r3) {
            return (0, r3.resolve)(i3);
          }), l = [];
        }
      }, f()), c2) {
        var d3 = r2.apply(n2, e2);
        return u && u(d3), i2(d3);
      }
      l.push({
        resolve: i2,
        reject: t2
      });
    });
  };
  return d.cancel = function(r3) {
    void 0 !== o && clearTimeout(o), l.forEach(function(e2) {
      return (0, e2.reject)(r3);
    }), l = [];
  }, d;
}
var commonVersionIdentifier = /version\/(\d+(\.?_?\d+)+)/i;
var browserDetails;
function getBrowser(userAgent) {
  var force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  if (typeof userAgent === "undefined" && typeof navigator === "undefined") {
    return;
  }
  var ua = (userAgent !== null && userAgent !== void 0 ? userAgent : navigator.userAgent).toLowerCase();
  if (browserDetails === void 0 || force) {
    var browser = browsersList.find(function(_ref) {
      var test = _ref.test;
      return test.test(ua);
    });
    browserDetails = browser === null || browser === void 0 ? void 0 : browser.describe(ua);
  }
  return browserDetails;
}
var browsersList = [
  {
    test: /firefox|iceweasel|fxios/i,
    describe: function describe(ua) {
      var browser = {
        name: "Firefox",
        version: getMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, ua),
        os: ua.toLowerCase().includes("fxios") ? "iOS" : void 0,
        osVersion: getOSVersion(ua)
      };
      return browser;
    }
  },
  {
    test: /chrom|crios|crmo/i,
    describe: function describe2(ua) {
      var browser = {
        name: "Chrome",
        version: getMatch(/(?:chrome|chromium|crios|crmo)\/(\d+(\.?_?\d+)+)/i, ua),
        os: ua.toLowerCase().includes("crios") ? "iOS" : void 0,
        osVersion: getOSVersion(ua)
      };
      return browser;
    }
  },
  /* Safari */
  {
    test: /safari|applewebkit/i,
    describe: function describe3(ua) {
      var browser = {
        name: "Safari",
        version: getMatch(commonVersionIdentifier, ua),
        os: ua.includes("mobile/") ? "iOS" : "macOS",
        osVersion: getOSVersion(ua)
      };
      return browser;
    }
  }
];
function getMatch(exp, ua) {
  var id = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  var match = ua.match(exp);
  return match && match.length >= id && match[id] || "";
}
function getOSVersion(ua) {
  return ua.includes("mac os") ? getMatch(/\(.+?(\d+_\d+(:?_\d+)?)/, ua, 1).replace(/_/g, ".") : void 0;
}
var version$1 = "2.1.3";
var version = version$1;
var protocolVersion = 15;
var CriticalTimers = _createClass(function CriticalTimers2() {
  _classCallCheck(this, CriticalTimers2);
});
CriticalTimers.setTimeout = function() {
  return setTimeout.apply(void 0, arguments);
};
CriticalTimers.setInterval = // eslint-disable-next-line @typescript-eslint/no-implied-eval
function() {
  return setInterval.apply(void 0, arguments);
};
CriticalTimers.clearTimeout = function() {
  return clearTimeout.apply(void 0, arguments);
};
CriticalTimers.clearInterval = function() {
  return clearInterval.apply(void 0, arguments);
};
var VideoPreset = function() {
  function VideoPreset2(widthOrOptions, height, maxBitrate, maxFramerate, priority) {
    _classCallCheck(this, VideoPreset2);
    if (_typeof(widthOrOptions) === "object") {
      this.width = widthOrOptions.width;
      this.height = widthOrOptions.height;
      this.aspectRatio = widthOrOptions.aspectRatio;
      this.encoding = {
        maxBitrate: widthOrOptions.maxBitrate,
        maxFramerate: widthOrOptions.maxFramerate,
        priority: widthOrOptions.priority
      };
    } else if (height !== void 0 && maxBitrate !== void 0) {
      this.width = widthOrOptions;
      this.height = height;
      this.aspectRatio = widthOrOptions / height;
      this.encoding = {
        maxBitrate,
        maxFramerate,
        priority
      };
    } else {
      throw new TypeError("Unsupported options: provide at least width, height and maxBitrate");
    }
  }
  return _createClass(VideoPreset2, [{
    key: "resolution",
    get: function get2() {
      return {
        width: this.width,
        height: this.height,
        frameRate: this.encoding.maxFramerate,
        aspectRatio: this.aspectRatio
      };
    }
  }]);
}();
var backupCodecs = ["vp8", "h264"];
var videoCodecs = ["vp8", "h264", "vp9", "av1"];
function isBackupCodec(codec) {
  return !!backupCodecs.find(function(backup) {
    return backup === codec;
  });
}
var AudioPresets;
(function(AudioPresets2) {
  AudioPresets2.telephone = {
    maxBitrate: 12e3
  };
  AudioPresets2.speech = {
    maxBitrate: 24e3
  };
  AudioPresets2.music = {
    maxBitrate: 48e3
  };
  AudioPresets2.musicStereo = {
    maxBitrate: 64e3
  };
  AudioPresets2.musicHighQuality = {
    maxBitrate: 96e3
  };
  AudioPresets2.musicHighQualityStereo = {
    maxBitrate: 128e3
  };
})(AudioPresets || (AudioPresets = {}));
var VideoPresets = {
  // h90: new VideoPreset(160, 90, 90_000, 20),
  // h180: new VideoPreset(320, 180, 160_000, 20),
  // h216: new VideoPreset(384, 216, 180_000, 20),
  // h360: new VideoPreset(640, 360, 450_000, 20),
  h540: new VideoPreset(960, 540, 5e5, 25),
  h720: new VideoPreset(1280, 720, 125e4, 30)
  //h1080: new VideoPreset(1920, 1080, 3_000_000, 30),
  // h1440: new VideoPreset(2560, 1440, 5_000_000, 30),
  // h2160: new VideoPreset(3840, 2160, 8_000_000, 30),
};
var VideoPresets43 = {
  // h120: new VideoPreset(160, 120, 70_000, 20),
  // h180: new VideoPreset(240, 180, 125_000, 20),
  // h240: new VideoPreset(320, 240, 140_000, 20),
  // h360: new VideoPreset(480, 360, 330_000, 20),
  // h480: new VideoPreset(640, 480, 500_000, 20),
  h540: new VideoPreset(720, 540, 55e4, 25),
  h720: new VideoPreset(960, 720, 12e5, 30)
  //h1080: new VideoPreset(1440, 1080, 2_300_000, 30),
  // h1440: new VideoPreset(1920, 1440, 3_800_000, 30),
};
var ScreenSharePresets = {
  h360fps3: new VideoPreset(640, 360, 2e5, 3, "medium"),
  h360fps15: new VideoPreset(640, 360, 4e5, 15, "medium"),
  h720fps5: new VideoPreset(1280, 720, 8e5, 5, "medium"),
  h720fps15: new VideoPreset(1280, 720, 15e5, 15, "medium"),
  h720fps30: new VideoPreset(1280, 720, 2e6, 30, "medium"),
  h1080fps15: new VideoPreset(1920, 1080, 25e5, 15, "medium"),
  h1080fps30: new VideoPreset(1920, 1080, 5e6, 30, "medium"),
  // original resolution, without resizing
  original: new VideoPreset(0, 0, 7e6, 30, "medium")
};
function cloneDeep(value) {
  if (typeof value === "undefined") {
    return;
  }
  if (typeof structuredClone === "function") {
    return structuredClone(value);
  } else {
    return JSON.parse(JSON.stringify(value));
  }
}
var BACKGROUND_REACTION_DELAY = 5e3;
var recycledElements = [];
var VideoQuality;
(function(VideoQuality2) {
  VideoQuality2[VideoQuality2["LOW"] = 0] = "LOW";
  VideoQuality2[VideoQuality2["MEDIUM"] = 1] = "MEDIUM";
  VideoQuality2[VideoQuality2["HIGH"] = 2] = "HIGH";
})(VideoQuality || (VideoQuality = {}));
var Track = function(_EventEmitter) {
  function Track2(mediaTrack, kind) {
    var _this;
    var loggerOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    _classCallCheck(this, Track2);
    var _a;
    _this = _callSuper(this, Track2);
    _this.attachedElements = [];
    _this.isMuted = false;
    _this.streamState = Track2.StreamState.Active;
    _this.isInBackground = false;
    _this._currentBitrate = 0;
    _this.log = livekitLogger;
    _this.appVisibilityChangedListener = function() {
      if (_this.backgroundTimeout) {
        clearTimeout(_this.backgroundTimeout);
      }
      if (document.visibilityState === "hidden") {
        _this.backgroundTimeout = setTimeout(function() {
          return _this.handleAppVisibilityChanged();
        }, BACKGROUND_REACTION_DELAY);
      } else {
        _this.handleAppVisibilityChanged();
      }
    };
    _this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Track);
    _this.loggerContextCb = loggerOptions.loggerContextCb;
    _this.setMaxListeners(100);
    _this.kind = kind;
    _this._mediaStreamTrack = mediaTrack;
    _this._mediaStreamID = mediaTrack.id;
    _this.source = Track2.Source.Unknown;
    return _this;
  }
  _inherits(Track2, _EventEmitter);
  return _createClass(Track2, [{
    key: "logContext",
    get: function get2() {
      var _a;
      return Object.assign(Object.assign({}, (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)), getLogContextFromTrack(this));
    }
    /** current receive bits per second */
  }, {
    key: "currentBitrate",
    get: function get2() {
      return this._currentBitrate;
    }
  }, {
    key: "mediaStreamTrack",
    get: function get2() {
      return this._mediaStreamTrack;
    }
    /**
     * @internal
     * used for keep mediaStream's first id, since it's id might change
     * if we disable/enable a track
     */
  }, {
    key: "mediaStreamID",
    get: function get2() {
      return this._mediaStreamID;
    }
  }, {
    key: "attach",
    value: function attach(element) {
      var _this2 = this;
      var elementType = "audio";
      if (this.kind === Track2.Kind.Video) {
        elementType = "video";
      }
      if (this.attachedElements.length === 0 && this.kind === Track2.Kind.Video) {
        this.addAppVisibilityListener();
      }
      if (!element) {
        if (elementType === "audio") {
          recycledElements.forEach(function(e) {
            if (e.parentElement === null && !element) {
              element = e;
            }
          });
          if (element) {
            recycledElements.splice(recycledElements.indexOf(element), 1);
          }
        }
        if (!element) {
          element = document.createElement(elementType);
        }
      }
      if (!this.attachedElements.includes(element)) {
        this.attachedElements.push(element);
      }
      attachToElement(this.mediaStreamTrack, element);
      var allMediaStreamTracks = element.srcObject.getTracks();
      var hasAudio = allMediaStreamTracks.some(function(tr) {
        return tr.kind === "audio";
      });
      element.play().then(function() {
        _this2.emit(hasAudio ? TrackEvent.AudioPlaybackStarted : TrackEvent.VideoPlaybackStarted);
      })["catch"](function(e) {
        if (e.name === "NotAllowedError") {
          _this2.emit(hasAudio ? TrackEvent.AudioPlaybackFailed : TrackEvent.VideoPlaybackFailed, e);
        } else if (e.name === "AbortError") {
          livekitLogger.debug("".concat(hasAudio ? "audio" : "video", " playback aborted, likely due to new play request"));
        } else {
          livekitLogger.warn("could not playback ".concat(hasAudio ? "audio" : "video"), e);
        }
        if (hasAudio && element && allMediaStreamTracks.some(function(tr) {
          return tr.kind === "video";
        }) && e.name === "NotAllowedError") {
          element.muted = true;
          element.play()["catch"](function() {
          });
        }
      });
      this.emit(TrackEvent.ElementAttached, element);
      return element;
    }
  }, {
    key: "detach",
    value: function detach(element) {
      var _this3 = this;
      try {
        if (element) {
          detachTrack(this.mediaStreamTrack, element);
          var idx = this.attachedElements.indexOf(element);
          if (idx >= 0) {
            this.attachedElements.splice(idx, 1);
            this.recycleElement(element);
            this.emit(TrackEvent.ElementDetached, element);
          }
          return element;
        }
        var detached = [];
        this.attachedElements.forEach(function(elm) {
          detachTrack(_this3.mediaStreamTrack, elm);
          detached.push(elm);
          _this3.recycleElement(elm);
          _this3.emit(TrackEvent.ElementDetached, elm);
        });
        this.attachedElements = [];
        return detached;
      } finally {
        if (this.attachedElements.length === 0) {
          this.removeAppVisibilityListener();
        }
      }
    }
  }, {
    key: "stop",
    value: function stop() {
      this.stopMonitor();
      this._mediaStreamTrack.stop();
    }
  }, {
    key: "enable",
    value: function enable() {
      this._mediaStreamTrack.enabled = true;
    }
  }, {
    key: "disable",
    value: function disable() {
      this._mediaStreamTrack.enabled = false;
    }
    /* @internal */
  }, {
    key: "stopMonitor",
    value: function stopMonitor() {
      if (this.monitorInterval) {
        clearInterval(this.monitorInterval);
      }
      if (this.timeSyncHandle) {
        cancelAnimationFrame(this.timeSyncHandle);
      }
    }
    /** @internal */
  }, {
    key: "updateLoggerOptions",
    value: function updateLoggerOptions(loggerOptions) {
      if (loggerOptions.loggerName) {
        this.log = getLogger(loggerOptions.loggerName);
      }
      if (loggerOptions.loggerContextCb) {
        this.loggerContextCb = loggerOptions.loggerContextCb;
      }
    }
  }, {
    key: "recycleElement",
    value: function recycleElement(element) {
      if (element instanceof HTMLAudioElement) {
        var shouldCache = true;
        element.pause();
        recycledElements.forEach(function(e) {
          if (!e.parentElement) {
            shouldCache = false;
          }
        });
        if (shouldCache) {
          recycledElements.push(element);
        }
      }
    }
  }, {
    key: "handleAppVisibilityChanged",
    value: function handleAppVisibilityChanged() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee() {
        var _this4 = this;
        return _regenerator().w(function(_context) {
          while (1) switch (_context.n) {
            case 0:
              this.isInBackground = document.visibilityState === "hidden";
              if (!this.isInBackground && this.kind === Track2.Kind.Video) {
                setTimeout(function() {
                  return _this4.attachedElements.forEach(function(el) {
                    return el.play()["catch"](function() {
                    });
                  });
                }, 0);
              }
            case 1:
              return _context.a(2);
          }
        }, _callee, this);
      }));
    }
  }, {
    key: "addAppVisibilityListener",
    value: function addAppVisibilityListener() {
      if (isWeb()) {
        this.isInBackground = document.visibilityState === "hidden";
        document.addEventListener("visibilitychange", this.appVisibilityChangedListener);
      } else {
        this.isInBackground = false;
      }
    }
  }, {
    key: "removeAppVisibilityListener",
    value: function removeAppVisibilityListener() {
      if (isWeb()) {
        document.removeEventListener("visibilitychange", this.appVisibilityChangedListener);
      }
    }
  }]);
}(eventsExports.EventEmitter);
function attachToElement(track, element) {
  var mediaStream;
  if (element.srcObject instanceof MediaStream) {
    mediaStream = element.srcObject;
  } else {
    mediaStream = new MediaStream();
  }
  var existingTracks;
  if (track.kind === "audio") {
    existingTracks = mediaStream.getAudioTracks();
  } else {
    existingTracks = mediaStream.getVideoTracks();
  }
  if (!existingTracks.includes(track)) {
    existingTracks.forEach(function(et) {
      mediaStream.removeTrack(et);
    });
    mediaStream.addTrack(track);
  }
  if (!isSafari() || !(element instanceof HTMLVideoElement)) {
    element.autoplay = true;
  }
  element.muted = mediaStream.getAudioTracks().length === 0;
  if (element instanceof HTMLVideoElement) {
    element.playsInline = true;
  }
  if (element.srcObject !== mediaStream) {
    element.srcObject = mediaStream;
    if ((isSafari() || isFireFox()) && element instanceof HTMLVideoElement) {
      setTimeout(function() {
        element.srcObject = mediaStream;
        element.play()["catch"](function() {
        });
      }, 0);
    }
  }
}
function detachTrack(track, element) {
  if (element.srcObject instanceof MediaStream) {
    var mediaStream = element.srcObject;
    mediaStream.removeTrack(track);
    if (mediaStream.getTracks().length > 0) {
      element.srcObject = mediaStream;
    } else {
      element.srcObject = null;
    }
  }
}
(function(Track2) {
  var Kind;
  (function(Kind2) {
    Kind2["Audio"] = "audio";
    Kind2["Video"] = "video";
    Kind2["Unknown"] = "unknown";
  })(Kind = Track2.Kind || (Track2.Kind = {}));
  var Source;
  (function(Source2) {
    Source2["Camera"] = "camera";
    Source2["Microphone"] = "microphone";
    Source2["ScreenShare"] = "screen_share";
    Source2["ScreenShareAudio"] = "screen_share_audio";
    Source2["Unknown"] = "unknown";
  })(Source = Track2.Source || (Track2.Source = {}));
  var StreamState$1;
  (function(StreamState2) {
    StreamState2["Active"] = "active";
    StreamState2["Paused"] = "paused";
    StreamState2["Unknown"] = "unknown";
  })(StreamState$1 = Track2.StreamState || (Track2.StreamState = {}));
  function kindToProto(k) {
    switch (k) {
      case Kind.Audio:
        return TrackType.AUDIO;
      case Kind.Video:
        return TrackType.VIDEO;
      default:
        return TrackType.DATA;
    }
  }
  Track2.kindToProto = kindToProto;
  function kindFromProto(t) {
    switch (t) {
      case TrackType.AUDIO:
        return Kind.Audio;
      case TrackType.VIDEO:
        return Kind.Video;
      default:
        return Kind.Unknown;
    }
  }
  Track2.kindFromProto = kindFromProto;
  function sourceToProto(s) {
    switch (s) {
      case Source.Camera:
        return TrackSource.CAMERA;
      case Source.Microphone:
        return TrackSource.MICROPHONE;
      case Source.ScreenShare:
        return TrackSource.SCREEN_SHARE;
      case Source.ScreenShareAudio:
        return TrackSource.SCREEN_SHARE_AUDIO;
      default:
        return TrackSource.UNKNOWN;
    }
  }
  Track2.sourceToProto = sourceToProto;
  function sourceFromProto(s) {
    switch (s) {
      case TrackSource.CAMERA:
        return Source.Camera;
      case TrackSource.MICROPHONE:
        return Source.Microphone;
      case TrackSource.SCREEN_SHARE:
        return Source.ScreenShare;
      case TrackSource.SCREEN_SHARE_AUDIO:
        return Source.ScreenShareAudio;
      default:
        return Source.Unknown;
    }
  }
  Track2.sourceFromProto = sourceFromProto;
  function streamStateFromProto(s) {
    switch (s) {
      case StreamState.ACTIVE:
        return StreamState$1.Active;
      case StreamState.PAUSED:
        return StreamState$1.Paused;
      default:
        return StreamState$1.Unknown;
    }
  }
  Track2.streamStateFromProto = streamStateFromProto;
})(Track || (Track = {}));
function mergeDefaultOptions(options, audioDefaults2, videoDefaults2) {
  var _a, _b, _c;
  var _d, _e;
  var _extractProcessorsFro = extractProcessorsFromOptions(options !== null && options !== void 0 ? options : {}), optionsWithoutProcessor = _extractProcessorsFro.optionsWithoutProcessor, audioProcessor = _extractProcessorsFro.audioProcessor, videoProcessor = _extractProcessorsFro.videoProcessor;
  var clonedOptions = (_a = cloneDeep(optionsWithoutProcessor)) !== null && _a !== void 0 ? _a : {};
  if (clonedOptions.audio === true) clonedOptions.audio = {};
  if (clonedOptions.video === true) clonedOptions.video = {};
  if (clonedOptions.audio) {
    mergeObjectWithoutOverwriting(clonedOptions.audio, audioDefaults2);
    (_b = (_d = clonedOptions.audio).deviceId) !== null && _b !== void 0 ? _b : _d.deviceId = "default";
    if (audioProcessor) {
      clonedOptions.audio.processor = audioProcessor;
    }
  }
  if (clonedOptions.video) {
    mergeObjectWithoutOverwriting(clonedOptions.video, videoDefaults2);
    (_c = (_e = clonedOptions.video).deviceId) !== null && _c !== void 0 ? _c : _e.deviceId = "default";
    if (videoProcessor) {
      clonedOptions.video.processor = videoProcessor;
    }
  }
  return clonedOptions;
}
function mergeObjectWithoutOverwriting(mainObject, objectToMerge) {
  Object.keys(objectToMerge).forEach(function(key) {
    if (mainObject[key] === void 0) mainObject[key] = objectToMerge[key];
  });
  return mainObject;
}
function constraintsForOptions(options) {
  var _a, _b;
  var _c, _d;
  var constraints = {};
  if (options.video) {
    if (_typeof(options.video) === "object") {
      var videoOptions = {};
      var target = videoOptions;
      var source = options.video;
      Object.keys(source).forEach(function(key) {
        switch (key) {
          case "resolution":
            mergeObjectWithoutOverwriting(target, source.resolution);
            break;
          default:
            target[key] = source[key];
        }
      });
      constraints.video = videoOptions;
      (_a = (_c = constraints.video).deviceId) !== null && _a !== void 0 ? _a : _c.deviceId = "default";
    } else {
      constraints.video = options.video ? {
        deviceId: "default"
      } : false;
    }
  } else {
    constraints.video = false;
  }
  if (options.audio) {
    if (_typeof(options.audio) === "object") {
      constraints.audio = options.audio;
      (_b = (_d = constraints.audio).deviceId) !== null && _b !== void 0 ? _b : _d.deviceId = "default";
    } else {
      constraints.audio = {
        deviceId: "default"
      };
    }
  } else {
    constraints.audio = false;
  }
  return constraints;
}
function detectSilence(track_1) {
  return __awaiter(this, arguments, void 0, function(track) {
    var timeOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 200;
    return _regenerator().m(function _callee() {
      var ctx, analyser, bufferLength, dataArray, source, someNoise;
      return _regenerator().w(function(_context) {
        while (1) switch (_context.n) {
          case 0:
            ctx = getNewAudioContext();
            if (!ctx) {
              _context.n = 2;
              break;
            }
            analyser = ctx.createAnalyser();
            analyser.fftSize = 2048;
            bufferLength = analyser.frequencyBinCount;
            dataArray = new Uint8Array(bufferLength);
            source = ctx.createMediaStreamSource(new MediaStream([track.mediaStreamTrack]));
            source.connect(analyser);
            _context.n = 1;
            return sleep(timeOffset);
          case 1:
            analyser.getByteTimeDomainData(dataArray);
            someNoise = dataArray.some(function(sample) {
              return sample !== 128 && sample !== 0;
            });
            ctx.close();
            return _context.a(2, !someNoise);
          case 2:
            return _context.a(2, false);
        }
      }, _callee);
    })();
  });
}
function getNewAudioContext() {
  var AudioContext2 = (
    // @ts-ignore
    typeof window !== "undefined" && (window.AudioContext || window.webkitAudioContext)
  );
  if (AudioContext2) {
    return new AudioContext2({
      latencyHint: "interactive"
    });
  }
}
function sourceToKind(source) {
  if (source === Track.Source.Microphone) {
    return "audioinput";
  } else if (source === Track.Source.Camera) {
    return "videoinput";
  } else {
    return void 0;
  }
}
function screenCaptureToDisplayMediaStreamOptions(options) {
  var _a, _b;
  var videoConstraints = (_a = options.video) !== null && _a !== void 0 ? _a : true;
  if (options.resolution && options.resolution.width > 0 && options.resolution.height > 0) {
    videoConstraints = typeof videoConstraints === "boolean" ? {} : videoConstraints;
    if (isSafari()) {
      videoConstraints = Object.assign(Object.assign({}, videoConstraints), {
        width: {
          max: options.resolution.width
        },
        height: {
          max: options.resolution.height
        },
        frameRate: options.resolution.frameRate
      });
    } else {
      videoConstraints = Object.assign(Object.assign({}, videoConstraints), {
        width: {
          ideal: options.resolution.width
        },
        height: {
          ideal: options.resolution.height
        },
        frameRate: options.resolution.frameRate
      });
    }
  }
  return {
    audio: (_b = options.audio) !== null && _b !== void 0 ? _b : false,
    video: videoConstraints,
    // @ts-expect-error support for experimental display media features
    controller: options.controller,
    selfBrowserSurface: options.selfBrowserSurface,
    surfaceSwitching: options.surfaceSwitching,
    systemAudio: options.systemAudio,
    preferCurrentTab: options.preferCurrentTab
  };
}
function mimeTypeToVideoCodecString(mimeType) {
  return mimeType.split("/")[1].toLowerCase();
}
function getTrackPublicationInfo(tracks) {
  var infos = [];
  tracks.forEach(function(track) {
    if (track.track !== void 0) {
      infos.push(new TrackPublishedResponse({
        cid: track.track.mediaStreamID,
        track: track.trackInfo
      }));
    }
  });
  return infos;
}
function getLogContextFromTrack(track) {
  if (track instanceof Track) {
    return {
      trackID: track.sid,
      source: track.source,
      muted: track.isMuted,
      enabled: track.mediaStreamTrack.enabled,
      kind: track.kind,
      streamID: track.mediaStreamID,
      streamTrackID: track.mediaStreamTrack.id
    };
  } else {
    return {
      trackID: track.trackSid,
      enabled: track.isEnabled,
      muted: track.isMuted,
      trackInfo: Object.assign({
        mimeType: track.mimeType,
        name: track.trackName,
        encrypted: track.isEncrypted,
        kind: track.kind,
        source: track.source
      }, track.track ? getLogContextFromTrack(track.track) : {})
    };
  }
}
function supportsSynchronizationSources() {
  return typeof RTCRtpReceiver !== "undefined" && "getSynchronizationSources" in RTCRtpReceiver;
}
function extractProcessorsFromOptions(options) {
  var newOptions = Object.assign({}, options);
  var audioProcessor;
  var videoProcessor;
  if (_typeof(newOptions.audio) === "object" && newOptions.audio.processor) {
    audioProcessor = newOptions.audio.processor;
    newOptions.audio = Object.assign(Object.assign({}, newOptions.audio), {
      processor: void 0
    });
  }
  if (_typeof(newOptions.video) === "object" && newOptions.video.processor) {
    videoProcessor = newOptions.video.processor;
    newOptions.video = Object.assign(Object.assign({}, newOptions.video), {
      processor: void 0
    });
  }
  return {
    audioProcessor,
    videoProcessor,
    optionsWithoutProcessor: newOptions
  };
}
function diffAttributes(oldValues, newValues) {
  var _a;
  var allKeys = [].concat(_toConsumableArray(Object.keys(newValues)), _toConsumableArray(Object.keys(oldValues)));
  var diff = {};
  var _iterator = _createForOfIteratorHelper(allKeys), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var key = _step.value;
      if (oldValues[key] !== newValues[key]) {
        diff[key] = (_a = newValues[key]) !== null && _a !== void 0 ? _a : "";
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return diff;
}
var separator = "|";
var ddExtensionURI = "https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension";
function unpackStreamId(packed) {
  var parts = packed.split(separator);
  if (parts.length > 1) {
    return [parts[0], packed.substr(parts[0].length + 1)];
  }
  return [packed, ""];
}
function sleep(duration) {
  return __awaiter(this, void 0, void 0, _regenerator().m(function _callee() {
    return _regenerator().w(function(_context) {
      while (1) switch (_context.n) {
        case 0:
          return _context.a(2, new Promise(function(resolve) {
            return CriticalTimers.setTimeout(resolve, duration);
          }));
      }
    }, _callee);
  }));
}
function supportsTransceiver() {
  return "addTransceiver" in RTCPeerConnection.prototype;
}
function supportsAddTrack() {
  return "addTrack" in RTCPeerConnection.prototype;
}
function supportsAdaptiveStream() {
  return (typeof ResizeObserver === "undefined" ? "undefined" : _typeof(ResizeObserver)) !== void 0 && (typeof IntersectionObserver === "undefined" ? "undefined" : _typeof(IntersectionObserver)) !== void 0;
}
function supportsDynacast() {
  return supportsTransceiver();
}
function supportsAV1() {
  if (!("getCapabilities" in RTCRtpSender)) {
    return false;
  }
  if (isSafari()) {
    return false;
  }
  var capabilities = RTCRtpSender.getCapabilities("video");
  var hasAV1 = false;
  if (capabilities) {
    var _iterator = _createForOfIteratorHelper(capabilities.codecs), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var codec = _step.value;
        if (codec.mimeType === "video/AV1") {
          hasAV1 = true;
          break;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  return hasAV1;
}
function supportsVP9() {
  if (!("getCapabilities" in RTCRtpSender)) {
    return false;
  }
  if (isFireFox()) {
    return false;
  }
  if (isSafari()) {
    var browser = getBrowser();
    if ((browser === null || browser === void 0 ? void 0 : browser.version) && compareVersions(browser.version, "16") < 0) {
      return false;
    }
  }
  var capabilities = RTCRtpSender.getCapabilities("video");
  var hasVP9 = false;
  if (capabilities) {
    var _iterator2 = _createForOfIteratorHelper(capabilities.codecs), _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        var codec = _step2.value;
        if (codec.mimeType === "video/VP9") {
          hasVP9 = true;
          break;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
  return hasVP9;
}
function isSVCCodec(codec) {
  return codec === "av1" || codec === "vp9";
}
function supportsSetSinkId(elm) {
  if (!document) {
    return false;
  }
  if (!elm) {
    elm = document.createElement("audio");
  }
  return "setSinkId" in elm;
}
function isBrowserSupported() {
  if (typeof RTCPeerConnection === "undefined") {
    return false;
  }
  return supportsTransceiver() || supportsAddTrack();
}
function isFireFox() {
  var _a;
  return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === "Firefox";
}
function isSafari() {
  var _a;
  return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === "Safari";
}
function isSafari17() {
  var b = getBrowser();
  return (b === null || b === void 0 ? void 0 : b.name) === "Safari" && b.version.startsWith("17.");
}
function isMobile() {
  var _a, _b;
  if (!isWeb()) return false;
  return (
    // @ts-expect-error `userAgentData` is not yet part of typescript
    (_b = (_a = navigator.userAgentData) === null || _a === void 0 ? void 0 : _a.mobile) !== null && _b !== void 0 ? _b : /Tablet|iPad|Mobile|Android|BlackBerry/.test(navigator.userAgent)
  );
}
function isE2EESimulcastSupported() {
  var browser = getBrowser();
  var supportedSafariVersion = "17.2";
  if (browser) {
    if (browser.name !== "Safari" && browser.os !== "iOS") {
      return true;
    } else if (browser.os === "iOS" && browser.osVersion && compareVersions(supportedSafariVersion, browser.osVersion) >= 0) {
      return true;
    } else if (browser.name === "Safari" && compareVersions(supportedSafariVersion, browser.version) >= 0) {
      return true;
    } else {
      return false;
    }
  }
}
function isWeb() {
  return typeof document !== "undefined";
}
function isReactNative() {
  return navigator.product == "ReactNative";
}
function isCloud(serverUrl) {
  return serverUrl.hostname.endsWith(".livekit.cloud") || serverUrl.hostname.endsWith(".livekit.run");
}
function getLKReactNativeInfo() {
  if (global && global.LiveKitReactNativeGlobal) {
    return global.LiveKitReactNativeGlobal;
  }
  return void 0;
}
function getReactNativeOs() {
  if (!isReactNative()) {
    return void 0;
  }
  var info = getLKReactNativeInfo();
  if (info) {
    return info.platform;
  }
  return void 0;
}
function getDevicePixelRatio() {
  if (isWeb()) {
    return window.devicePixelRatio;
  }
  if (isReactNative()) {
    var info = getLKReactNativeInfo();
    if (info) {
      return info.devicePixelRatio;
    }
  }
  return 1;
}
function compareVersions(v1, v2) {
  var parts1 = v1.split(".");
  var parts2 = v2.split(".");
  var k = Math.min(parts1.length, parts2.length);
  for (var i = 0; i < k; ++i) {
    var p1 = parseInt(parts1[i], 10);
    var p2 = parseInt(parts2[i], 10);
    if (p1 > p2) return 1;
    if (p1 < p2) return -1;
    if (i === k - 1 && p1 === p2) return 0;
  }
  if (v1 === "" && v2 !== "") {
    return -1;
  } else if (v2 === "") {
    return 1;
  }
  return parts1.length == parts2.length ? 0 : parts1.length < parts2.length ? -1 : 1;
}
function roDispatchCallback(entries) {
  var _iterator3 = _createForOfIteratorHelper(entries), _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
      var entry = _step3.value;
      entry.target.handleResize(entry);
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
}
function ioDispatchCallback(entries) {
  var _iterator4 = _createForOfIteratorHelper(entries), _step4;
  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
      var entry = _step4.value;
      entry.target.handleVisibilityChanged(entry);
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }
}
var resizeObserver = null;
var getResizeObserver = function getResizeObserver2() {
  if (!resizeObserver) resizeObserver = new ResizeObserver(roDispatchCallback);
  return resizeObserver;
};
var intersectionObserver = null;
var getIntersectionObserver = function getIntersectionObserver2() {
  if (!intersectionObserver) {
    intersectionObserver = new IntersectionObserver(ioDispatchCallback, {
      root: null,
      rootMargin: "0px"
    });
  }
  return intersectionObserver;
};
function getClientInfo() {
  var _a;
  var info = new ClientInfo({
    sdk: ClientInfo_SDK.JS,
    protocol: protocolVersion,
    version
  });
  if (isReactNative()) {
    info.os = (_a = getReactNativeOs()) !== null && _a !== void 0 ? _a : "";
  }
  return info;
}
var emptyVideoStreamTrack;
function getEmptyVideoStreamTrack() {
  if (!emptyVideoStreamTrack) {
    emptyVideoStreamTrack = createDummyVideoStreamTrack();
  }
  return emptyVideoStreamTrack.clone();
}
function createDummyVideoStreamTrack() {
  var width = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 16;
  var height = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 16;
  var enabled = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var paintContent = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  var canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  var ctx = canvas.getContext("2d");
  ctx === null || ctx === void 0 ? void 0 : ctx.fillRect(0, 0, canvas.width, canvas.height);
  if (paintContent && ctx) {
    ctx.beginPath();
    ctx.arc(width / 2, height / 2, 50, 0, Math.PI * 2, true);
    ctx.closePath();
    ctx.fillStyle = "grey";
    ctx.fill();
  }
  var dummyStream = canvas.captureStream();
  var _dummyStream$getTrack = dummyStream.getTracks(), _dummyStream$getTrack2 = _slicedToArray(_dummyStream$getTrack, 1), dummyTrack = _dummyStream$getTrack2[0];
  if (!dummyTrack) {
    throw Error("Could not get empty media stream video track");
  }
  dummyTrack.enabled = enabled;
  return dummyTrack;
}
var emptyAudioStreamTrack;
function getEmptyAudioStreamTrack() {
  if (!emptyAudioStreamTrack) {
    var ctx = new AudioContext();
    var oscillator = ctx.createOscillator();
    var gain = ctx.createGain();
    gain.gain.setValueAtTime(0, 0);
    var dst = ctx.createMediaStreamDestination();
    oscillator.connect(gain);
    gain.connect(dst);
    oscillator.start();
    var _dst$stream$getAudioT = dst.stream.getAudioTracks();
    var _dst$stream$getAudioT2 = _slicedToArray(_dst$stream$getAudioT, 1);
    emptyAudioStreamTrack = _dst$stream$getAudioT2[0];
    if (!emptyAudioStreamTrack) {
      throw Error("Could not get empty media stream audio track");
    }
    emptyAudioStreamTrack.enabled = false;
  }
  return emptyAudioStreamTrack.clone();
}
var Future = _createClass(function Future2(futureBase, onFinally) {
  var _this = this;
  _classCallCheck(this, Future2);
  this.onFinally = onFinally;
  this.promise = new Promise(function(resolve, reject) {
    return __awaiter(_this, void 0, void 0, _regenerator().m(function _callee2() {
      return _regenerator().w(function(_context2) {
        while (1) switch (_context2.n) {
          case 0:
            this.resolve = resolve;
            this.reject = reject;
            if (!futureBase) {
              _context2.n = 1;
              break;
            }
            _context2.n = 1;
            return futureBase(resolve, reject);
          case 1:
            return _context2.a(2);
        }
      }, _callee2, this);
    }));
  })["finally"](function() {
    var _a;
    return (_a = _this.onFinally) === null || _a === void 0 ? void 0 : _a.call(_this);
  });
});
function createAudioAnalyser(track, options) {
  var _this2 = this;
  var opts = Object.assign({
    cloneTrack: false,
    fftSize: 2048,
    smoothingTimeConstant: 0.8,
    minDecibels: -100,
    maxDecibels: -80
  }, options);
  var audioContext = getNewAudioContext();
  if (!audioContext) {
    throw new Error("Audio Context not supported on this browser");
  }
  var streamTrack = opts.cloneTrack ? track.mediaStreamTrack.clone() : track.mediaStreamTrack;
  var mediaStreamSource = audioContext.createMediaStreamSource(new MediaStream([streamTrack]));
  var analyser = audioContext.createAnalyser();
  analyser.minDecibels = opts.minDecibels;
  analyser.maxDecibels = opts.maxDecibels;
  analyser.fftSize = opts.fftSize;
  analyser.smoothingTimeConstant = opts.smoothingTimeConstant;
  mediaStreamSource.connect(analyser);
  var dataArray = new Uint8Array(analyser.frequencyBinCount);
  var calculateVolume = function calculateVolume2() {
    analyser.getByteFrequencyData(dataArray);
    var sum = 0;
    var _iterator5 = _createForOfIteratorHelper(dataArray), _step5;
    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
        var amplitude = _step5.value;
        sum += Math.pow(amplitude / 255, 2);
      }
    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }
    var volume = Math.sqrt(sum / dataArray.length);
    return volume;
  };
  var cleanup = function cleanup2() {
    return __awaiter(_this2, void 0, void 0, _regenerator().m(function _callee3() {
      return _regenerator().w(function(_context3) {
        while (1) switch (_context3.n) {
          case 0:
            _context3.n = 1;
            return audioContext.close();
          case 1:
            if (opts.cloneTrack) {
              streamTrack.stop();
            }
          case 2:
            return _context3.a(2);
        }
      }, _callee3);
    }));
  };
  return {
    calculateVolume,
    analyser,
    cleanup
  };
}
var Mutex = function() {
  function Mutex2() {
    _classCallCheck(this, Mutex2);
    this._locking = Promise.resolve();
    this._locks = 0;
  }
  return _createClass(Mutex2, [{
    key: "isLocked",
    value: function isLocked() {
      return this._locks > 0;
    }
  }, {
    key: "lock",
    value: function lock() {
      var _this3 = this;
      this._locks += 1;
      var unlockNext;
      var willLock = new Promise(function(resolve) {
        return unlockNext = function unlockNext2() {
          _this3._locks -= 1;
          resolve();
        };
      });
      var willUnlock = this._locking.then(function() {
        return unlockNext;
      });
      this._locking = this._locking.then(function() {
        return willLock;
      });
      return willUnlock;
    }
  }]);
}();
function isVideoCodec(maybeCodec) {
  return videoCodecs.includes(maybeCodec);
}
function unwrapConstraint(constraint) {
  if (typeof constraint === "string" || typeof constraint === "number") {
    return constraint;
  }
  if (Array.isArray(constraint)) {
    return constraint[0];
  }
  if (constraint.exact) {
    if (Array.isArray(constraint.exact)) {
      return constraint.exact[0];
    }
    return constraint.exact;
  }
  if (constraint.ideal) {
    if (Array.isArray(constraint.ideal)) {
      return constraint.ideal[0];
    }
    return constraint.ideal;
  }
  throw Error("could not unwrap constraint");
}
function toWebsocketUrl(url) {
  if (url.startsWith("http")) {
    return url.replace(/^(http)/, "ws");
  }
  return url;
}
function toHttpUrl(url) {
  if (url.startsWith("ws")) {
    return url.replace(/^(ws)/, "http");
  }
  return url;
}
function extractTranscriptionSegments(transcription, firstReceivedTimesMap) {
  return transcription.segments.map(function(_ref) {
    var id = _ref.id, text = _ref.text, startTime = _ref.startTime, endTime = _ref.endTime, _final = _ref["final"], language = _ref.language, error = _ref.error, failureReason = _ref.failureReason;
    var _a;
    var firstReceivedTime = (_a = firstReceivedTimesMap.get(id)) !== null && _a !== void 0 ? _a : Date.now();
    var lastReceivedTime = Date.now();
    if (_final) {
      firstReceivedTimesMap["delete"](id);
    } else {
      firstReceivedTimesMap.set(id, firstReceivedTime);
    }
    return {
      id,
      text,
      startTime: Number.parseInt(startTime.toString()),
      endTime: Number.parseInt(endTime.toString()),
      "final": _final,
      language,
      firstReceivedTime,
      lastReceivedTime,
      error,
      failureReason
    };
  });
}
function extractChatMessage(msg) {
  var id = msg.id, timestamp = msg.timestamp, message = msg.message, editTimestamp = msg.editTimestamp;
  return {
    id,
    timestamp: Number.parseInt(timestamp.toString()),
    editTimestamp: editTimestamp ? Number.parseInt(editTimestamp.toString()) : void 0,
    message
  };
}
function getDisconnectReasonFromConnectionError(e) {
  switch (e.reason) {
    case 4:
      return e.context;
    case 3:
      return DisconnectReason.CLIENT_INITIATED;
    case 0:
      return DisconnectReason.USER_REJECTED;
    case 1:
      return DisconnectReason.JOIN_FAILURE;
    default:
      return DisconnectReason.UNKNOWN_REASON;
  }
}
var defaultId = "default";
var DeviceManager = function() {
  function DeviceManager2() {
    _classCallCheck(this, DeviceManager2);
    this._previousDevices = [];
  }
  return _createClass(DeviceManager2, [{
    key: "previousDevices",
    get: function get2() {
      return this._previousDevices;
    }
  }, {
    key: "getDevices",
    value: function getDevices(kind_1) {
      return __awaiter(this, arguments, void 0, function(kind) {
        var _this = this;
        var requestPermissions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        return _regenerator().m(function _callee() {
          var _a, devices, isDummyDeviceOrEmpty, permissionsToAcquire, stream;
          return _regenerator().w(function(_context) {
            while (1) switch (_context.n) {
              case 0:
                if (!(((_a = DeviceManager2.userMediaPromiseMap) === null || _a === void 0 ? void 0 : _a.size) > 0)) {
                  _context.n = 6;
                  break;
                }
                livekitLogger.debug("awaiting getUserMedia promise");
                _context.p = 1;
                if (!kind) {
                  _context.n = 3;
                  break;
                }
                _context.n = 2;
                return DeviceManager2.userMediaPromiseMap.get(kind);
              case 2:
                _context.n = 4;
                break;
              case 3:
                _context.n = 4;
                return Promise.all(DeviceManager2.userMediaPromiseMap.values());
              case 4:
                _context.n = 6;
                break;
              case 5:
                _context.p = 5;
                _context.v;
                livekitLogger.warn("error waiting for media permissons");
              case 6:
                _context.n = 7;
                return navigator.mediaDevices.enumerateDevices();
              case 7:
                devices = _context.v;
                if (!(requestPermissions && // for safari we need to skip this check, as otherwise it will re-acquire user media and fail on iOS https://bugs.webkit.org/show_bug.cgi?id=179363
                !(isSafari() && _this.hasDeviceInUse(kind)))) {
                  _context.n = 10;
                  break;
                }
                isDummyDeviceOrEmpty = devices.filter(function(d) {
                  return d.kind === kind;
                }).length === 0 || devices.some(function(device) {
                  var noLabel = device.label === "";
                  var isRelevant = kind ? device.kind === kind : true;
                  return noLabel && isRelevant;
                });
                if (!isDummyDeviceOrEmpty) {
                  _context.n = 10;
                  break;
                }
                permissionsToAcquire = {
                  video: kind !== "audioinput" && kind !== "audiooutput",
                  audio: kind !== "videoinput" && {
                    deviceId: "default"
                  }
                };
                _context.n = 8;
                return navigator.mediaDevices.getUserMedia(permissionsToAcquire);
              case 8:
                stream = _context.v;
                _context.n = 9;
                return navigator.mediaDevices.enumerateDevices();
              case 9:
                devices = _context.v;
                stream.getTracks().forEach(function(track) {
                  track.stop();
                });
              case 10:
                _this._previousDevices = devices;
                if (kind) {
                  devices = devices.filter(function(device) {
                    return device.kind === kind;
                  });
                }
                return _context.a(2, devices);
            }
          }, _callee, null, [[1, 5]]);
        })();
      });
    }
  }, {
    key: "normalizeDeviceId",
    value: function normalizeDeviceId(kind, deviceId, groupId) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee2() {
        var devices, defaultDevice, device;
        return _regenerator().w(function(_context2) {
          while (1) switch (_context2.n) {
            case 0:
              if (!(deviceId !== defaultId)) {
                _context2.n = 1;
                break;
              }
              return _context2.a(2, deviceId);
            case 1:
              _context2.n = 2;
              return this.getDevices(kind);
            case 2:
              devices = _context2.v;
              defaultDevice = devices.find(function(d) {
                return d.deviceId === defaultId;
              });
              if (defaultDevice) {
                _context2.n = 3;
                break;
              }
              livekitLogger.warn("could not reliably determine default device");
              return _context2.a(2, void 0);
            case 3:
              device = devices.find(function(d) {
                return d.deviceId !== defaultId && d.groupId === (groupId !== null && groupId !== void 0 ? groupId : defaultDevice.groupId);
              });
              if (device) {
                _context2.n = 4;
                break;
              }
              livekitLogger.warn("could not reliably determine default device");
              return _context2.a(2, void 0);
            case 4:
              return _context2.a(2, device === null || device === void 0 ? void 0 : device.deviceId);
          }
        }, _callee2, this);
      }));
    }
  }, {
    key: "hasDeviceInUse",
    value: function hasDeviceInUse(kind) {
      return kind ? DeviceManager2.userMediaPromiseMap.has(kind) : DeviceManager2.userMediaPromiseMap.size > 0;
    }
  }], [{
    key: "getInstance",
    value: function getInstance() {
      if (this.instance === void 0) {
        this.instance = new DeviceManager2();
      }
      return this.instance;
    }
  }]);
}();
DeviceManager.mediaDeviceKinds = ["audioinput", "audiooutput", "videoinput"];
DeviceManager.userMediaPromiseMap = /* @__PURE__ */ new Map();
var defaultDimensionsTimeout = 1e3;
var LocalTrack = function(_Track) {
  function LocalTrack2(mediaTrack, kind, constraints) {
    var _this;
    var userProvidedTrack = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    var loggerOptions = arguments.length > 4 ? arguments[4] : void 0;
    _classCallCheck(this, LocalTrack2);
    _this = _callSuper(this, LocalTrack2, [mediaTrack, kind, loggerOptions]);
    _this.manuallyStopped = false;
    _this._isUpstreamPaused = false;
    _this.handleTrackMuteEvent = function() {
      return _this.debouncedTrackMuteHandler()["catch"](function() {
        return _this.log.debug("track mute bounce got cancelled by an unmute event", _this.logContext);
      });
    };
    _this.debouncedTrackMuteHandler = r(function() {
      return __awaiter(_this, void 0, void 0, _regenerator().m(function _callee() {
        return _regenerator().w(function(_context) {
          while (1) switch (_context.n) {
            case 0:
              _context.n = 1;
              return this.pauseUpstream();
            case 1:
              return _context.a(2);
          }
        }, _callee, this);
      }));
    }, 5e3);
    _this.handleTrackUnmuteEvent = function() {
      return __awaiter(_this, void 0, void 0, _regenerator().m(function _callee2() {
        return _regenerator().w(function(_context2) {
          while (1) switch (_context2.n) {
            case 0:
              this.debouncedTrackMuteHandler.cancel("unmute");
              _context2.n = 1;
              return this.resumeUpstream();
            case 1:
              return _context2.a(2);
          }
        }, _callee2, this);
      }));
    };
    _this.handleEnded = function() {
      if (_this.isInBackground) {
        _this.reacquireTrack = true;
      }
      _this._mediaStreamTrack.removeEventListener("mute", _this.handleTrackMuteEvent);
      _this._mediaStreamTrack.removeEventListener("unmute", _this.handleTrackUnmuteEvent);
      _this.emit(TrackEvent.Ended, _this);
    };
    _this.reacquireTrack = false;
    _this.providedByUser = userProvidedTrack;
    _this.muteLock = new Mutex();
    _this.pauseUpstreamLock = new Mutex();
    _this.processorLock = new Mutex();
    _this.restartLock = new Mutex();
    _this.setMediaStreamTrack(mediaTrack, true);
    _this._constraints = mediaTrack.getConstraints();
    if (constraints) {
      _this._constraints = constraints;
    }
    return _this;
  }
  _inherits(LocalTrack2, _Track);
  return _createClass(LocalTrack2, [{
    key: "sender",
    get: (
      /** @internal */
      function get2() {
        return this._sender;
      }
    ),
    set: function set2(sender) {
      this._sender = sender;
    }
  }, {
    key: "constraints",
    get: function get2() {
      return this._constraints;
    }
  }, {
    key: "id",
    get: function get2() {
      return this._mediaStreamTrack.id;
    }
  }, {
    key: "dimensions",
    get: function get2() {
      if (this.kind !== Track.Kind.Video) {
        return void 0;
      }
      var _this$_mediaStreamTra = this._mediaStreamTrack.getSettings(), width = _this$_mediaStreamTra.width, height = _this$_mediaStreamTra.height;
      if (width && height) {
        return {
          width,
          height
        };
      }
      return void 0;
    }
  }, {
    key: "isUpstreamPaused",
    get: function get2() {
      return this._isUpstreamPaused;
    }
  }, {
    key: "isUserProvided",
    get: function get2() {
      return this.providedByUser;
    }
  }, {
    key: "mediaStreamTrack",
    get: function get2() {
      var _a, _b;
      return (_b = (_a = this.processor) === null || _a === void 0 ? void 0 : _a.processedTrack) !== null && _b !== void 0 ? _b : this._mediaStreamTrack;
    }
    /**
    * @internal
    * returns mediaStreamTrack settings of the capturing mediastreamtrack source - ignoring processors
    */
  }, {
    key: "getSourceTrackSettings",
    value: function getSourceTrackSettings() {
      return this._mediaStreamTrack.getSettings();
    }
  }, {
    key: "setMediaStreamTrack",
    value: function setMediaStreamTrack(newTrack, force) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee3() {
        var _this2 = this;
        var processedTrack, unlock;
        return _regenerator().w(function(_context3) {
          while (1) switch (_context3.n) {
            case 0:
              if (!(newTrack === this._mediaStreamTrack && !force)) {
                _context3.n = 1;
                break;
              }
              return _context3.a(2);
            case 1:
              if (this._mediaStreamTrack) {
                this.attachedElements.forEach(function(el) {
                  detachTrack(_this2._mediaStreamTrack, el);
                });
                this.debouncedTrackMuteHandler.cancel("new-track");
                this._mediaStreamTrack.removeEventListener("ended", this.handleEnded);
                this._mediaStreamTrack.removeEventListener("mute", this.handleTrackMuteEvent);
                this._mediaStreamTrack.removeEventListener("unmute", this.handleTrackUnmuteEvent);
              }
              this.mediaStream = new MediaStream([newTrack]);
              if (newTrack) {
                newTrack.addEventListener("ended", this.handleEnded);
                newTrack.addEventListener("mute", this.handleTrackMuteEvent);
                newTrack.addEventListener("unmute", this.handleTrackUnmuteEvent);
                this._constraints = newTrack.getConstraints();
              }
              if (!(this.processor && newTrack)) {
                _context3.n = 7;
                break;
              }
              _context3.n = 2;
              return this.processorLock.lock();
            case 2:
              unlock = _context3.v;
              _context3.p = 3;
              this.log.debug("restarting processor", this.logContext);
              if (!(this.kind === "unknown")) {
                _context3.n = 4;
                break;
              }
              throw TypeError("cannot set processor on track of unknown kind");
            case 4:
              if (this.processorElement) {
                attachToElement(newTrack, this.processorElement);
                this.processorElement.muted = true;
              }
              _context3.n = 5;
              return this.processor.restart({
                track: newTrack,
                kind: this.kind,
                element: this.processorElement
              });
            case 5:
              processedTrack = this.processor.processedTrack;
            case 6:
              _context3.p = 6;
              unlock();
              return _context3.f(6);
            case 7:
              if (!this.sender) {
                _context3.n = 8;
                break;
              }
              _context3.n = 8;
              return this.sender.replaceTrack(processedTrack !== null && processedTrack !== void 0 ? processedTrack : newTrack);
            case 8:
              if (!this.providedByUser && this._mediaStreamTrack !== newTrack) {
                this._mediaStreamTrack.stop();
              }
              this._mediaStreamTrack = newTrack;
              if (!newTrack) {
                _context3.n = 10;
                break;
              }
              this._mediaStreamTrack.enabled = !this.isMuted;
              _context3.n = 9;
              return this.resumeUpstream();
            case 9:
              this.attachedElements.forEach(function(el) {
                attachToElement(processedTrack !== null && processedTrack !== void 0 ? processedTrack : newTrack, el);
              });
            case 10:
              return _context3.a(2);
          }
        }, _callee3, this, [[3, , 6, 7]]);
      }));
    }
  }, {
    key: "waitForDimensions",
    value: function waitForDimensions() {
      return __awaiter(this, arguments, void 0, function() {
        var _this3 = this;
        var timeout = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultDimensionsTimeout;
        return _regenerator().m(function _callee4() {
          var _a, started, dims;
          return _regenerator().w(function(_context4) {
            while (1) switch (_context4.n) {
              case 0:
                if (!(_this3.kind === Track.Kind.Audio)) {
                  _context4.n = 1;
                  break;
                }
                throw new Error("cannot get dimensions for audio tracks");
              case 1:
                if (!(((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.os) === "iOS")) {
                  _context4.n = 2;
                  break;
                }
                _context4.n = 2;
                return sleep(10);
              case 2:
                started = Date.now();
              case 3:
                if (!(Date.now() - started < timeout)) {
                  _context4.n = 6;
                  break;
                }
                dims = _this3.dimensions;
                if (!dims) {
                  _context4.n = 4;
                  break;
                }
                return _context4.a(2, dims);
              case 4:
                _context4.n = 5;
                return sleep(50);
              case 5:
                _context4.n = 3;
                break;
              case 6:
                throw new TrackInvalidError("unable to get track dimensions after timeout");
              case 7:
                return _context4.a(2);
            }
          }, _callee4);
        })();
      });
    }
  }, {
    key: "setDeviceId",
    value: function setDeviceId(deviceId) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee5() {
        return _regenerator().w(function(_context5) {
          while (1) switch (_context5.n) {
            case 0:
              if (!(this._constraints.deviceId === deviceId && this._mediaStreamTrack.getSettings().deviceId === unwrapConstraint(deviceId))) {
                _context5.n = 1;
                break;
              }
              return _context5.a(2, true);
            case 1:
              this._constraints.deviceId = deviceId;
              if (!this.isMuted) {
                _context5.n = 2;
                break;
              }
              return _context5.a(2, true);
            case 2:
              _context5.n = 3;
              return this.restartTrack();
            case 3:
              return _context5.a(2, unwrapConstraint(deviceId) === this._mediaStreamTrack.getSettings().deviceId);
          }
        }, _callee5, this);
      }));
    }
    /**
      * @returns DeviceID of the device that is currently being used for this track
      */
  }, {
    key: "getDeviceId",
    value: function getDeviceId() {
      return __awaiter(this, arguments, void 0, function() {
        var _this4 = this;
        var normalize = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        return _regenerator().m(function _callee6() {
          var _this4$_mediaStreamTr, deviceId, groupId, kind;
          return _regenerator().w(function(_context6) {
            while (1) switch (_context6.n) {
              case 0:
                if (!(_this4.source === Track.Source.ScreenShare)) {
                  _context6.n = 1;
                  break;
                }
                return _context6.a(2);
              case 1:
                _this4$_mediaStreamTr = _this4._mediaStreamTrack.getSettings(), deviceId = _this4$_mediaStreamTr.deviceId, groupId = _this4$_mediaStreamTr.groupId;
                kind = _this4.kind === Track.Kind.Audio ? "audioinput" : "videoinput";
                return _context6.a(2, normalize ? DeviceManager.getInstance().normalizeDeviceId(kind, deviceId, groupId) : deviceId);
            }
          }, _callee6);
        })();
      });
    }
  }, {
    key: "mute",
    value: function mute() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee7() {
        return _regenerator().w(function(_context7) {
          while (1) switch (_context7.n) {
            case 0:
              this.setTrackMuted(true);
              return _context7.a(2, this);
          }
        }, _callee7, this);
      }));
    }
  }, {
    key: "unmute",
    value: function unmute() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee8() {
        return _regenerator().w(function(_context8) {
          while (1) switch (_context8.n) {
            case 0:
              this.setTrackMuted(false);
              return _context8.a(2, this);
          }
        }, _callee8, this);
      }));
    }
  }, {
    key: "replaceTrack",
    value: function replaceTrack(track, userProvidedOrOptions) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee9() {
        var userProvidedTrack, stopProcessor;
        return _regenerator().w(function(_context9) {
          while (1) switch (_context9.n) {
            case 0:
              if (this.sender) {
                _context9.n = 1;
                break;
              }
              throw new TrackInvalidError("unable to replace an unpublished track");
            case 1:
              if (typeof userProvidedOrOptions === "boolean") {
                userProvidedTrack = userProvidedOrOptions;
              } else if (userProvidedOrOptions !== void 0) {
                userProvidedTrack = userProvidedOrOptions.userProvidedTrack;
                stopProcessor = userProvidedOrOptions.stopProcessor;
              }
              this.providedByUser = userProvidedTrack !== null && userProvidedTrack !== void 0 ? userProvidedTrack : true;
              this.log.debug("replace MediaStreamTrack", this.logContext);
              _context9.n = 2;
              return this.setMediaStreamTrack(track);
            case 2:
              if (!(stopProcessor && this.processor)) {
                _context9.n = 3;
                break;
              }
              _context9.n = 3;
              return this.stopProcessor();
            case 3:
              return _context9.a(2, this);
          }
        }, _callee9, this);
      }));
    }
  }, {
    key: "restart",
    value: function restart(constraints) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee0() {
        var _this5 = this;
        var unlock, streamConstraints, mediaStream, newTrack;
        return _regenerator().w(function(_context0) {
          while (1) switch (_context0.n) {
            case 0:
              this.manuallyStopped = false;
              _context0.n = 1;
              return this.restartLock.lock();
            case 1:
              unlock = _context0.v;
              _context0.p = 2;
              if (!constraints) {
                constraints = this._constraints;
              }
              this.log.debug("restarting track with constraints", Object.assign(Object.assign({}, this.logContext), {
                constraints
              }));
              streamConstraints = {
                audio: false,
                video: false
              };
              if (this.kind === Track.Kind.Video) {
                streamConstraints.video = constraints;
              } else {
                streamConstraints.audio = constraints;
              }
              this.attachedElements.forEach(function(el) {
                detachTrack(_this5.mediaStreamTrack, el);
              });
              this._mediaStreamTrack.removeEventListener("ended", this.handleEnded);
              this._mediaStreamTrack.stop();
              _context0.n = 3;
              return navigator.mediaDevices.getUserMedia(streamConstraints);
            case 3:
              mediaStream = _context0.v;
              newTrack = mediaStream.getTracks()[0];
              newTrack.addEventListener("ended", this.handleEnded);
              this.log.debug("re-acquired MediaStreamTrack", this.logContext);
              _context0.n = 4;
              return this.setMediaStreamTrack(newTrack);
            case 4:
              this._constraints = constraints;
              this.emit(TrackEvent.Restarted, this);
              if (this.manuallyStopped) {
                this.log.warn("track was stopped during a restart, stopping restarted track", this.logContext);
                this.stop();
              }
              return _context0.a(2, this);
            case 5:
              _context0.p = 5;
              unlock();
              return _context0.f(5);
            case 6:
              return _context0.a(2);
          }
        }, _callee0, this, [[2, , 5, 6]]);
      }));
    }
  }, {
    key: "setTrackMuted",
    value: function setTrackMuted(muted) {
      this.log.debug("setting ".concat(this.kind, " track ").concat(muted ? "muted" : "unmuted"), this.logContext);
      if (this.isMuted === muted && this._mediaStreamTrack.enabled !== muted) {
        return;
      }
      this.isMuted = muted;
      this._mediaStreamTrack.enabled = !muted;
      this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);
    }
  }, {
    key: "needsReAcquisition",
    get: function get2() {
      return this._mediaStreamTrack.readyState !== "live" || this._mediaStreamTrack.muted || !this._mediaStreamTrack.enabled || this.reacquireTrack;
    }
  }, {
    key: "handleAppVisibilityChanged",
    value: function handleAppVisibilityChanged() {
      var _this6 = this;
      var _super = Object.create(null, {
        handleAppVisibilityChanged: {
          get: function get2() {
            return _superPropGet(LocalTrack2, "handleAppVisibilityChanged", _this6, 1);
          }
        }
      });
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee1() {
        return _regenerator().w(function(_context1) {
          while (1) switch (_context1.n) {
            case 0:
              _context1.n = 1;
              return _super.handleAppVisibilityChanged.call(this);
            case 1:
              if (isMobile()) {
                _context1.n = 2;
                break;
              }
              return _context1.a(2);
            case 2:
              this.log.debug("visibility changed, is in Background: ".concat(this.isInBackground), this.logContext);
              if (!(!this.isInBackground && this.needsReAcquisition && !this.isUserProvided && !this.isMuted)) {
                _context1.n = 4;
                break;
              }
              this.log.debug("track needs to be reacquired, restarting ".concat(this.source), this.logContext);
              _context1.n = 3;
              return this.restart();
            case 3:
              this.reacquireTrack = false;
            case 4:
              return _context1.a(2);
          }
        }, _callee1, this);
      }));
    }
  }, {
    key: "stop",
    value: function stop() {
      var _a;
      this.manuallyStopped = true;
      _superPropGet(LocalTrack2, "stop", this, 3)([]);
      this._mediaStreamTrack.removeEventListener("ended", this.handleEnded);
      this._mediaStreamTrack.removeEventListener("mute", this.handleTrackMuteEvent);
      this._mediaStreamTrack.removeEventListener("unmute", this.handleTrackUnmuteEvent);
      (_a = this.processor) === null || _a === void 0 ? void 0 : _a.destroy();
      this.processor = void 0;
    }
    /**
     * pauses publishing to the server without disabling the local MediaStreamTrack
     * this is used to display a user's own video locally while pausing publishing to
     * the server.
     * this API is unsupported on Safari < 12 due to a bug
     **/
  }, {
    key: "pauseUpstream",
    value: function pauseUpstream() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee10() {
        var unlock, browser;
        return _regenerator().w(function(_context10) {
          while (1) switch (_context10.n) {
            case 0:
              _context10.n = 1;
              return this.pauseUpstreamLock.lock();
            case 1:
              unlock = _context10.v;
              _context10.p = 2;
              if (!(this._isUpstreamPaused === true)) {
                _context10.n = 3;
                break;
              }
              return _context10.a(2);
            case 3:
              if (this.sender) {
                _context10.n = 4;
                break;
              }
              this.log.warn("unable to pause upstream for an unpublished track", this.logContext);
              return _context10.a(2);
            case 4:
              this._isUpstreamPaused = true;
              this.emit(TrackEvent.UpstreamPaused, this);
              browser = getBrowser();
              if (!((browser === null || browser === void 0 ? void 0 : browser.name) === "Safari" && compareVersions(browser.version, "12.0") < 0)) {
                _context10.n = 5;
                break;
              }
              throw new DeviceUnsupportedError("pauseUpstream is not supported on Safari < 12.");
            case 5:
              _context10.n = 6;
              return this.sender.replaceTrack(null);
            case 6:
              _context10.p = 6;
              unlock();
              return _context10.f(6);
            case 7:
              return _context10.a(2);
          }
        }, _callee10, this, [[2, , 6, 7]]);
      }));
    }
  }, {
    key: "resumeUpstream",
    value: function resumeUpstream() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee11() {
        var unlock;
        return _regenerator().w(function(_context11) {
          while (1) switch (_context11.n) {
            case 0:
              _context11.n = 1;
              return this.pauseUpstreamLock.lock();
            case 1:
              unlock = _context11.v;
              _context11.p = 2;
              if (!(this._isUpstreamPaused === false)) {
                _context11.n = 3;
                break;
              }
              return _context11.a(2);
            case 3:
              if (this.sender) {
                _context11.n = 4;
                break;
              }
              this.log.warn("unable to resume upstream for an unpublished track", this.logContext);
              return _context11.a(2);
            case 4:
              this._isUpstreamPaused = false;
              this.emit(TrackEvent.UpstreamResumed, this);
              _context11.n = 5;
              return this.sender.replaceTrack(this.mediaStreamTrack);
            case 5:
              _context11.p = 5;
              unlock();
              return _context11.f(5);
            case 6:
              return _context11.a(2);
          }
        }, _callee11, this, [[2, , 5, 6]]);
      }));
    }
    /**
     * Gets the RTCStatsReport for the LocalTrack's underlying RTCRtpSender
     * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport
     *
     * @returns Promise<RTCStatsReport> | undefined
     */
  }, {
    key: "getRTCStatsReport",
    value: function getRTCStatsReport() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee12() {
        var _a, statsReport;
        return _regenerator().w(function(_context12) {
          while (1) switch (_context12.n) {
            case 0:
              if ((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats) {
                _context12.n = 1;
                break;
              }
              return _context12.a(2);
            case 1:
              _context12.n = 2;
              return this.sender.getStats();
            case 2:
              statsReport = _context12.v;
              return _context12.a(2, statsReport);
          }
        }, _callee12, this);
      }));
    }
    /**
     * Sets a processor on this track.
     * See https://github.com/livekit/track-processors-js for example usage
     *
     * @experimental
     *
     * @param processor
     * @param showProcessedStreamLocally
     * @returns
     */
  }, {
    key: "setProcessor",
    value: function setProcessor(processor_1) {
      return __awaiter(this, arguments, void 0, function(processor) {
        var _this7 = this;
        var showProcessedStreamLocally = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        return _regenerator().m(function _callee13() {
          var _a, _b, unlock, processorOptions, _iterator, _step, el;
          return _regenerator().w(function(_context13) {
            while (1) switch (_context13.n) {
              case 0:
                _context13.n = 1;
                return _this7.processorLock.lock();
              case 1:
                unlock = _context13.v;
                _context13.p = 2;
                _this7.log.debug("setting up processor", _this7.logContext);
                _this7.processorElement = (_a = _this7.processorElement) !== null && _a !== void 0 ? _a : document.createElement(_this7.kind);
                processorOptions = {
                  kind: _this7.kind,
                  track: _this7._mediaStreamTrack,
                  element: _this7.processorElement,
                  audioContext: _this7.audioContext
                };
                _context13.n = 3;
                return processor.init(processorOptions);
              case 3:
                if (!_this7.processor) {
                  _context13.n = 4;
                  break;
                }
                _context13.n = 4;
                return _this7.stopProcessor();
              case 4:
                if (!(_this7.kind === "unknown")) {
                  _context13.n = 5;
                  break;
                }
                throw TypeError("cannot set processor on track of unknown kind");
              case 5:
                attachToElement(_this7._mediaStreamTrack, _this7.processorElement);
                _this7.processorElement.muted = true;
                _this7.processorElement.play()["catch"](function(error) {
                  return _this7.log.error("failed to play processor element", Object.assign(Object.assign({}, _this7.logContext), {
                    error
                  }));
                });
                _this7.processor = processor;
                if (!_this7.processor.processedTrack) {
                  _context13.n = 6;
                  break;
                }
                _iterator = _createForOfIteratorHelper(_this7.attachedElements);
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                    el = _step.value;
                    if (el !== _this7.processorElement && showProcessedStreamLocally) {
                      detachTrack(_this7._mediaStreamTrack, el);
                      attachToElement(_this7.processor.processedTrack, el);
                    }
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
                _context13.n = 6;
                return (_b = _this7.sender) === null || _b === void 0 ? void 0 : _b.replaceTrack(_this7.processor.processedTrack);
              case 6:
                _this7.emit(TrackEvent.TrackProcessorUpdate, _this7.processor);
              case 7:
                _context13.p = 7;
                unlock();
                return _context13.f(7);
              case 8:
                return _context13.a(2);
            }
          }, _callee13, null, [[2, , 7, 8]]);
        })();
      });
    }
  }, {
    key: "getProcessor",
    value: function getProcessor() {
      return this.processor;
    }
    /**
     * Stops the track processor
     * See https://github.com/livekit/track-processors-js for example usage
     *
     * @experimental
     * @returns
     */
  }, {
    key: "stopProcessor",
    value: function stopProcessor() {
      return __awaiter(this, arguments, void 0, function() {
        var _this8 = this;
        var keepElement = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        return _regenerator().m(function _callee14() {
          var _a, _b;
          return _regenerator().w(function(_context14) {
            while (1) switch (_context14.n) {
              case 0:
                if (_this8.processor) {
                  _context14.n = 1;
                  break;
                }
                return _context14.a(2);
              case 1:
                _this8.log.debug("stopping processor", _this8.logContext);
                (_a = _this8.processor.processedTrack) === null || _a === void 0 ? void 0 : _a.stop();
                _context14.n = 2;
                return _this8.processor.destroy();
              case 2:
                _this8.processor = void 0;
                if (!keepElement) {
                  (_b = _this8.processorElement) === null || _b === void 0 ? void 0 : _b.remove();
                  _this8.processorElement = void 0;
                }
                _context14.n = 3;
                return _this8._mediaStreamTrack.applyConstraints(_this8._constraints);
              case 3:
                _context14.n = 4;
                return _this8.setMediaStreamTrack(_this8._mediaStreamTrack, true);
              case 4:
                _this8.emit(TrackEvent.TrackProcessorUpdate);
              case 5:
                return _context14.a(2);
            }
          }, _callee14);
        })();
      });
    }
  }]);
}(Track);
var E2EEManager = function(_EventEmitter) {
  function E2EEManager2(options) {
    var _this;
    _classCallCheck(this, E2EEManager2);
    _this = _callSuper(this, E2EEManager2);
    _this.onWorkerMessage = function(ev) {
      var _a, _b;
      var _ev$data = ev.data, kind = _ev$data.kind, data = _ev$data.data;
      switch (kind) {
        case "error":
          livekitLogger.error(data.error.message);
          _this.emit(EncryptionEvent.EncryptionError, data.error);
          break;
        case "initAck":
          if (data.enabled) {
            _this.keyProvider.getKeys().forEach(function(keyInfo) {
              _this.postKey(keyInfo);
            });
          }
          break;
        case "enable":
          if (data.enabled) {
            _this.keyProvider.getKeys().forEach(function(keyInfo) {
              _this.postKey(keyInfo);
            });
          }
          if (_this.encryptionEnabled !== data.enabled && data.participantIdentity === ((_a = _this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity)) {
            _this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, data.enabled, _this.room.localParticipant);
            _this.encryptionEnabled = data.enabled;
          } else if (data.participantIdentity) {
            var participant = (_b = _this.room) === null || _b === void 0 ? void 0 : _b.getParticipantByIdentity(data.participantIdentity);
            if (!participant) {
              throw TypeError("couldn't set encryption status, participant not found".concat(data.participantIdentity));
            }
            _this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, data.enabled, participant);
          }
          break;
        case "ratchetKey":
          _this.keyProvider.emit(KeyProviderEvent.KeyRatcheted, data.material, data.keyIndex);
          break;
      }
    };
    _this.onWorkerError = function(ev) {
      livekitLogger.error("e2ee worker encountered an error:", {
        error: ev.error
      });
      _this.emit(EncryptionEvent.EncryptionError, ev.error);
    };
    _this.keyProvider = options.keyProvider;
    _this.worker = options.worker;
    _this.encryptionEnabled = false;
    return _this;
  }
  _inherits(E2EEManager2, _EventEmitter);
  return _createClass(E2EEManager2, [{
    key: "setup",
    value: function setup(room) {
      if (!isE2EESupported()) {
        throw new DeviceUnsupportedError("tried to setup end-to-end encryption on an unsupported browser");
      }
      livekitLogger.info("setting up e2ee");
      if (room !== this.room) {
        this.room = room;
        this.setupEventListeners(room, this.keyProvider);
        var msg = {
          kind: "init",
          data: {
            keyProviderOptions: this.keyProvider.getOptions(),
            loglevel: workerLogger.getLevel()
          }
        };
        if (this.worker) {
          livekitLogger.info("initializing worker", {
            worker: this.worker
          });
          this.worker.onmessage = this.onWorkerMessage;
          this.worker.onerror = this.onWorkerError;
          this.worker.postMessage(msg);
        }
      }
    }
    /**
     * @internal
     */
  }, {
    key: "setParticipantCryptorEnabled",
    value: function setParticipantCryptorEnabled(enabled, participantIdentity) {
      livekitLogger.debug("set e2ee to ".concat(enabled, " for participant ").concat(participantIdentity));
      this.postEnable(enabled, participantIdentity);
    }
    /**
     * @internal
     */
  }, {
    key: "setSifTrailer",
    value: function setSifTrailer(trailer) {
      if (!trailer || trailer.length === 0) {
        livekitLogger.warn("ignoring server sent trailer as it's empty");
      } else {
        this.postSifTrailer(trailer);
      }
    }
  }, {
    key: "setupEngine",
    value: function setupEngine(engine) {
      var _this2 = this;
      engine.on(EngineEvent.RTPVideoMapUpdate, function(rtpMap) {
        _this2.postRTPMap(rtpMap);
      });
    }
  }, {
    key: "setupEventListeners",
    value: function setupEventListeners(room, keyProvider) {
      var _this3 = this;
      room.on(RoomEvent.TrackPublished, function(pub, participant) {
        return _this3.setParticipantCryptorEnabled(pub.trackInfo.encryption !== Encryption_Type.NONE, participant.identity);
      });
      room.on(RoomEvent.ConnectionStateChanged, function(state) {
        if (state === ConnectionState.Connected) {
          room.remoteParticipants.forEach(function(participant) {
            participant.trackPublications.forEach(function(pub) {
              _this3.setParticipantCryptorEnabled(pub.trackInfo.encryption !== Encryption_Type.NONE, participant.identity);
            });
          });
        }
      }).on(RoomEvent.TrackUnsubscribed, function(track, _, participant) {
        var _a;
        var msg = {
          kind: "removeTransform",
          data: {
            participantIdentity: participant.identity,
            trackId: track.mediaStreamID
          }
        };
        (_a = _this3.worker) === null || _a === void 0 ? void 0 : _a.postMessage(msg);
      }).on(RoomEvent.TrackSubscribed, function(track, pub, participant) {
        _this3.setupE2EEReceiver(track, participant.identity, pub.trackInfo);
      }).on(RoomEvent.SignalConnected, function() {
        if (!_this3.room) {
          throw new TypeError("expected room to be present on signal connect");
        }
        keyProvider.getKeys().forEach(function(keyInfo) {
          _this3.postKey(keyInfo);
        });
        _this3.setParticipantCryptorEnabled(_this3.room.localParticipant.isE2EEEnabled, _this3.room.localParticipant.identity);
      });
      room.localParticipant.on(ParticipantEvent.LocalTrackPublished, function(publication) {
        return __awaiter(_this3, void 0, void 0, _regenerator().m(function _callee() {
          return _regenerator().w(function(_context) {
            while (1) switch (_context.n) {
              case 0:
                this.setupE2EESender(publication.track, publication.track.sender);
              case 1:
                return _context.a(2);
            }
          }, _callee, this);
        }));
      });
      keyProvider.on(KeyProviderEvent.SetKey, function(keyInfo) {
        return _this3.postKey(keyInfo);
      }).on(KeyProviderEvent.RatchetRequest, function(participantId, keyIndex) {
        return _this3.postRatchetRequest(participantId, keyIndex);
      });
    }
  }, {
    key: "postRatchetRequest",
    value: function postRatchetRequest(participantIdentity, keyIndex) {
      if (!this.worker) {
        throw Error("could not ratchet key, worker is missing");
      }
      var msg = {
        kind: "ratchetRequest",
        data: {
          participantIdentity,
          keyIndex
        }
      };
      this.worker.postMessage(msg);
    }
  }, {
    key: "postKey",
    value: function postKey(_ref) {
      var key = _ref.key, participantIdentity = _ref.participantIdentity, keyIndex = _ref.keyIndex;
      var _a;
      if (!this.worker) {
        throw Error("could not set key, worker is missing");
      }
      var msg = {
        kind: "setKey",
        data: {
          participantIdentity,
          isPublisher: participantIdentity === ((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity),
          key,
          keyIndex
        }
      };
      this.worker.postMessage(msg);
    }
  }, {
    key: "postEnable",
    value: function postEnable(enabled, participantIdentity) {
      if (this.worker) {
        var enableMsg = {
          kind: "enable",
          data: {
            enabled,
            participantIdentity
          }
        };
        this.worker.postMessage(enableMsg);
      } else {
        throw new ReferenceError("failed to enable e2ee, worker is not ready");
      }
    }
  }, {
    key: "postRTPMap",
    value: function postRTPMap(map) {
      var _a;
      if (!this.worker) {
        throw TypeError("could not post rtp map, worker is missing");
      }
      if (!((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity)) {
        throw TypeError("could not post rtp map, local participant identity is missing");
      }
      var msg = {
        kind: "setRTPMap",
        data: {
          map,
          participantIdentity: this.room.localParticipant.identity
        }
      };
      this.worker.postMessage(msg);
    }
  }, {
    key: "postSifTrailer",
    value: function postSifTrailer(trailer) {
      if (!this.worker) {
        throw Error("could not post SIF trailer, worker is missing");
      }
      var msg = {
        kind: "setSifTrailer",
        data: {
          trailer
        }
      };
      this.worker.postMessage(msg);
    }
  }, {
    key: "setupE2EEReceiver",
    value: function setupE2EEReceiver(track, remoteId, trackInfo) {
      if (!track.receiver) {
        return;
      }
      if (!(trackInfo === null || trackInfo === void 0 ? void 0 : trackInfo.mimeType) || trackInfo.mimeType === "") {
        throw new TypeError("MimeType missing from trackInfo, cannot set up E2EE cryptor");
      }
      this.handleReceiver(track.receiver, track.mediaStreamID, remoteId, track.kind === "video" ? mimeTypeToVideoCodecString(trackInfo.mimeType) : void 0);
    }
  }, {
    key: "setupE2EESender",
    value: function setupE2EESender(track, sender) {
      if (!(track instanceof LocalTrack) || !sender) {
        if (!sender) livekitLogger.warn("early return because sender is not ready");
        return;
      }
      this.handleSender(sender, track.mediaStreamID, void 0);
    }
    /**
     * Handles the given {@code RTCRtpReceiver} by creating a {@code TransformStream} which will inject
     * a frame decoder.
     *
     */
  }, {
    key: "handleReceiver",
    value: function handleReceiver(receiver, trackId, participantIdentity, codec) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee2() {
        var options, _msg, writable, readable, receiverStreams, msg;
        return _regenerator().w(function(_context2) {
          while (1) switch (_context2.n) {
            case 0:
              if (this.worker) {
                _context2.n = 1;
                break;
              }
              return _context2.a(2);
            case 1:
              if (!isScriptTransformSupported()) {
                _context2.n = 2;
                break;
              }
              options = {
                kind: "decode",
                participantIdentity,
                trackId,
                codec
              };
              receiver.transform = new RTCRtpScriptTransform(this.worker, options);
              _context2.n = 4;
              break;
            case 2:
              if (!(E2EE_FLAG in receiver && codec)) {
                _context2.n = 3;
                break;
              }
              _msg = {
                kind: "updateCodec",
                data: {
                  trackId,
                  codec,
                  participantIdentity
                }
              };
              this.worker.postMessage(_msg);
              return _context2.a(2);
            case 3:
              writable = receiver.writableStream;
              readable = receiver.readableStream;
              if (!writable || !readable) {
                receiverStreams = receiver.createEncodedStreams();
                receiver.writableStream = receiverStreams.writable;
                writable = receiverStreams.writable;
                receiver.readableStream = receiverStreams.readable;
                readable = receiverStreams.readable;
              }
              msg = {
                kind: "decode",
                data: {
                  readableStream: readable,
                  writableStream: writable,
                  trackId,
                  codec,
                  participantIdentity
                }
              };
              this.worker.postMessage(msg, [readable, writable]);
            case 4:
              receiver[E2EE_FLAG] = true;
            case 5:
              return _context2.a(2);
          }
        }, _callee2, this);
      }));
    }
    /**
     * Handles the given {@code RTCRtpSender} by creating a {@code TransformStream} which will inject
     * a frame encoder.
     *
     */
  }, {
    key: "handleSender",
    value: function handleSender(sender, trackId, codec) {
      var _a;
      if (E2EE_FLAG in sender || !this.worker) {
        return;
      }
      if (!((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity) || this.room.localParticipant.identity === "") {
        throw TypeError("local identity needs to be known in order to set up encrypted sender");
      }
      if (isScriptTransformSupported()) {
        livekitLogger.info("initialize script transform");
        var options = {
          kind: "encode",
          participantIdentity: this.room.localParticipant.identity,
          trackId,
          codec
        };
        sender.transform = new RTCRtpScriptTransform(this.worker, options);
      } else {
        livekitLogger.info("initialize encoded streams");
        var senderStreams = sender.createEncodedStreams();
        var msg = {
          kind: "encode",
          data: {
            readableStream: senderStreams.readable,
            writableStream: senderStreams.writable,
            codec,
            trackId,
            participantIdentity: this.room.localParticipant.identity
          }
        };
        this.worker.postMessage(msg, [senderStreams.readable, senderStreams.writable]);
      }
      sender[E2EE_FLAG] = true;
    }
  }]);
}(eventsExports.EventEmitter);
var QueueTaskStatus;
(function(QueueTaskStatus2) {
  QueueTaskStatus2[QueueTaskStatus2["WAITING"] = 0] = "WAITING";
  QueueTaskStatus2[QueueTaskStatus2["RUNNING"] = 1] = "RUNNING";
  QueueTaskStatus2[QueueTaskStatus2["COMPLETED"] = 2] = "COMPLETED";
})(QueueTaskStatus || (QueueTaskStatus = {}));
var AsyncQueue = function() {
  function AsyncQueue2() {
    _classCallCheck(this, AsyncQueue2);
    this.pendingTasks = /* @__PURE__ */ new Map();
    this.taskMutex = new Mutex();
    this.nextTaskIndex = 0;
  }
  return _createClass(AsyncQueue2, [{
    key: "run",
    value: function run(task) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee() {
        var taskInfo, unlock;
        return _regenerator().w(function(_context) {
          while (1) switch (_context.n) {
            case 0:
              taskInfo = {
                id: this.nextTaskIndex++,
                enqueuedAt: Date.now(),
                status: QueueTaskStatus.WAITING
              };
              this.pendingTasks.set(taskInfo.id, taskInfo);
              _context.n = 1;
              return this.taskMutex.lock();
            case 1:
              unlock = _context.v;
              _context.p = 2;
              taskInfo.executedAt = Date.now();
              taskInfo.status = QueueTaskStatus.RUNNING;
              _context.n = 3;
              return task();
            case 3:
              return _context.a(2, _context.v);
            case 4:
              _context.p = 4;
              taskInfo.status = QueueTaskStatus.COMPLETED;
              this.pendingTasks["delete"](taskInfo.id);
              unlock();
              return _context.f(4);
            case 5:
              return _context.a(2);
          }
        }, _callee, this, [[2, , 4, 5]]);
      }));
    }
  }, {
    key: "flush",
    value: function flush() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee3() {
        var _this = this;
        return _regenerator().w(function(_context3) {
          while (1) switch (_context3.n) {
            case 0:
              return _context3.a(2, this.run(function() {
                return __awaiter(_this, void 0, void 0, _regenerator().m(function _callee2() {
                  return _regenerator().w(function(_context2) {
                    while (1) switch (_context2.n) {
                      case 0:
                        return _context2.a(2);
                    }
                  }, _callee2);
                }));
              }));
          }
        }, _callee3, this);
      }));
    }
  }, {
    key: "snapshot",
    value: function snapshot() {
      return Array.from(this.pendingTasks.values());
    }
  }]);
}();
var passThroughQueueSignals = ["syncState", "trickle", "offer", "answer", "simulate", "leave"];
function canPassThroughQueue(req) {
  var canPass = passThroughQueueSignals.indexOf(req["case"]) >= 0;
  livekitLogger.trace("request allowed to bypass queue:", {
    canPass,
    req
  });
  return canPass;
}
var SignalConnectionState;
(function(SignalConnectionState2) {
  SignalConnectionState2[SignalConnectionState2["CONNECTING"] = 0] = "CONNECTING";
  SignalConnectionState2[SignalConnectionState2["CONNECTED"] = 1] = "CONNECTED";
  SignalConnectionState2[SignalConnectionState2["RECONNECTING"] = 2] = "RECONNECTING";
  SignalConnectionState2[SignalConnectionState2["DISCONNECTING"] = 3] = "DISCONNECTING";
  SignalConnectionState2[SignalConnectionState2["DISCONNECTED"] = 4] = "DISCONNECTED";
})(SignalConnectionState || (SignalConnectionState = {}));
var SignalClient = function() {
  function SignalClient2() {
    var _this = this;
    var useJSON = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    var loggerOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, SignalClient2);
    var _a;
    this.rtt = 0;
    this.state = SignalConnectionState.DISCONNECTED;
    this.log = livekitLogger;
    this._requestId = 0;
    this.resetCallbacks = function() {
      _this.onAnswer = void 0;
      _this.onLeave = void 0;
      _this.onLocalTrackPublished = void 0;
      _this.onLocalTrackUnpublished = void 0;
      _this.onNegotiateRequested = void 0;
      _this.onOffer = void 0;
      _this.onRemoteMuteChanged = void 0;
      _this.onSubscribedQualityUpdate = void 0;
      _this.onTokenRefresh = void 0;
      _this.onTrickle = void 0;
      _this.onClose = void 0;
    };
    this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Signal);
    this.loggerContextCb = loggerOptions.loggerContextCb;
    this.useJSON = useJSON;
    this.requestQueue = new AsyncQueue();
    this.queuedRequests = [];
    this.closingLock = new Mutex();
    this.connectionLock = new Mutex();
    this.state = SignalConnectionState.DISCONNECTED;
  }
  return _createClass(SignalClient2, [{
    key: "currentState",
    get: function get2() {
      return this.state;
    }
  }, {
    key: "isDisconnected",
    get: function get2() {
      return this.state === SignalConnectionState.DISCONNECTING || this.state === SignalConnectionState.DISCONNECTED;
    }
  }, {
    key: "isEstablishingConnection",
    get: function get2() {
      return this.state === SignalConnectionState.CONNECTING || this.state === SignalConnectionState.RECONNECTING;
    }
  }, {
    key: "getNextRequestId",
    value: function getNextRequestId() {
      this._requestId += 1;
      return this._requestId;
    }
  }, {
    key: "logContext",
    get: function get2() {
      var _a, _b;
      return (_b = (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)) !== null && _b !== void 0 ? _b : {};
    }
  }, {
    key: "join",
    value: function join(url, token, opts, abortSignal) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee() {
        var res;
        return _regenerator().w(function(_context) {
          while (1) switch (_context.n) {
            case 0:
              this.state = SignalConnectionState.CONNECTING;
              this.options = opts;
              _context.n = 1;
              return this.connect(url, token, opts, abortSignal);
            case 1:
              res = _context.v;
              return _context.a(2, res);
          }
        }, _callee, this);
      }));
    }
  }, {
    key: "reconnect",
    value: function reconnect(url, token, sid, reason) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee2() {
        var res;
        return _regenerator().w(function(_context2) {
          while (1) switch (_context2.n) {
            case 0:
              if (this.options) {
                _context2.n = 1;
                break;
              }
              this.log.warn("attempted to reconnect without signal options being set, ignoring", this.logContext);
              return _context2.a(2);
            case 1:
              this.state = SignalConnectionState.RECONNECTING;
              this.clearPingInterval();
              _context2.n = 2;
              return this.connect(url, token, Object.assign(Object.assign({}, this.options), {
                reconnect: true,
                sid,
                reconnectReason: reason
              }));
            case 2:
              res = _context2.v;
              return _context2.a(2, res);
          }
        }, _callee2, this);
      }));
    }
  }, {
    key: "connect",
    value: function connect(url, token, opts, abortSignal) {
      var _this2 = this;
      this.connectOptions = opts;
      url = toWebsocketUrl(url);
      url = url.replace(/\/$/, "");
      url += "/rtc";
      var clientInfo = getClientInfo();
      var params = createConnectionParams(token, clientInfo, opts);
      return new Promise(function(resolve, reject) {
        return __awaiter(_this2, void 0, void 0, _regenerator().m(function _callee6() {
          var _this3 = this;
          var unlock, abortHandler, wsTimeout;
          return _regenerator().w(function(_context6) {
            while (1) switch (_context6.n) {
              case 0:
                _context6.n = 1;
                return this.connectionLock.lock();
              case 1:
                unlock = _context6.v;
                _context6.p = 2;
                abortHandler = function abortHandler2() {
                  return __awaiter(_this3, void 0, void 0, _regenerator().m(function _callee3() {
                    return _regenerator().w(function(_context3) {
                      while (1) switch (_context3.n) {
                        case 0:
                          this.close();
                          clearTimeout(wsTimeout);
                          reject(new ConnectionError(
                            "room connection has been cancelled (signal)",
                            3
                            /* ConnectionErrorReason.Cancelled */
                          ));
                        case 1:
                          return _context3.a(2);
                      }
                    }, _callee3, this);
                  }));
                };
                wsTimeout = setTimeout(function() {
                  _this3.close();
                  reject(new ConnectionError(
                    "room connection has timed out (signal)",
                    1
                    /* ConnectionErrorReason.ServerUnreachable */
                  ));
                }, opts.websocketTimeout);
                if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {
                  abortHandler();
                }
                abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.addEventListener("abort", abortHandler);
                this.log.debug("connecting to ".concat(url + params), this.logContext);
                if (!this.ws) {
                  _context6.n = 3;
                  break;
                }
                _context6.n = 3;
                return this.close(false);
              case 3:
                this.ws = new WebSocket(url + params);
                this.ws.binaryType = "arraybuffer";
                this.ws.onopen = function() {
                  clearTimeout(wsTimeout);
                };
                this.ws.onerror = function(ev) {
                  return __awaiter(_this3, void 0, void 0, _regenerator().m(function _callee4() {
                    var resp, msg;
                    return _regenerator().w(function(_context4) {
                      while (1) switch (_context4.n) {
                        case 0:
                          if (!(this.state !== SignalConnectionState.CONNECTED)) {
                            _context4.n = 8;
                            break;
                          }
                          this.state = SignalConnectionState.DISCONNECTED;
                          clearTimeout(wsTimeout);
                          _context4.p = 1;
                          _context4.n = 2;
                          return fetch("http".concat(url.substring(2), "/validate").concat(params));
                        case 2:
                          resp = _context4.v;
                          if (!resp.status.toFixed(0).startsWith("4")) {
                            _context4.n = 4;
                            break;
                          }
                          _context4.n = 3;
                          return resp.text();
                        case 3:
                          msg = _context4.v;
                          reject(new ConnectionError(msg, 0, resp.status));
                          _context4.n = 5;
                          break;
                        case 4:
                          reject(new ConnectionError("Internal error", 2, resp.status));
                        case 5:
                          _context4.n = 7;
                          break;
                        case 6:
                          _context4.p = 6;
                          _context4.v;
                          reject(new ConnectionError(
                            "server was not reachable",
                            1
                            /* ConnectionErrorReason.ServerUnreachable */
                          ));
                        case 7:
                          return _context4.a(2);
                        case 8:
                          this.handleWSError(ev);
                        case 9:
                          return _context4.a(2);
                      }
                    }, _callee4, this, [[1, 6]]);
                  }));
                };
                this.ws.onmessage = function(ev) {
                  return __awaiter(_this3, void 0, void 0, _regenerator().m(function _callee5() {
                    var _a, _b, _c, resp, json, shouldProcessMessage;
                    return _regenerator().w(function(_context5) {
                      while (1) switch (_context5.n) {
                        case 0:
                          if (!(typeof ev.data === "string")) {
                            _context5.n = 1;
                            break;
                          }
                          json = JSON.parse(ev.data);
                          resp = SignalResponse.fromJson(json, {
                            ignoreUnknownFields: true
                          });
                          _context5.n = 3;
                          break;
                        case 1:
                          if (!(ev.data instanceof ArrayBuffer)) {
                            _context5.n = 2;
                            break;
                          }
                          resp = SignalResponse.fromBinary(new Uint8Array(ev.data));
                          _context5.n = 3;
                          break;
                        case 2:
                          this.log.error("could not decode websocket message: ".concat(_typeof(ev.data)), this.logContext);
                          return _context5.a(2);
                        case 3:
                          if (!(this.state !== SignalConnectionState.CONNECTED)) {
                            _context5.n = 4;
                            break;
                          }
                          shouldProcessMessage = false;
                          if (((_a = resp.message) === null || _a === void 0 ? void 0 : _a["case"]) === "join") {
                            this.state = SignalConnectionState.CONNECTED;
                            abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener("abort", abortHandler);
                            this.pingTimeoutDuration = resp.message.value.pingTimeout;
                            this.pingIntervalDuration = resp.message.value.pingInterval;
                            if (this.pingTimeoutDuration && this.pingTimeoutDuration > 0) {
                              this.log.debug("ping config", Object.assign(Object.assign({}, this.logContext), {
                                timeout: this.pingTimeoutDuration,
                                interval: this.pingIntervalDuration
                              }));
                              this.startPingInterval();
                            }
                            resolve(resp.message.value);
                          } else if (this.state === SignalConnectionState.RECONNECTING && resp.message["case"] !== "leave") {
                            this.state = SignalConnectionState.CONNECTED;
                            abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener("abort", abortHandler);
                            this.startPingInterval();
                            if (((_b = resp.message) === null || _b === void 0 ? void 0 : _b["case"]) === "reconnect") {
                              resolve(resp.message.value);
                            } else {
                              this.log.debug("declaring signal reconnected without reconnect response received", this.logContext);
                              resolve(void 0);
                              shouldProcessMessage = true;
                            }
                          } else if (this.isEstablishingConnection && resp.message["case"] === "leave") {
                            reject(new ConnectionError("Received leave request while trying to (re)connect", 4, void 0, resp.message.value.reason));
                          } else if (!opts.reconnect) {
                            reject(new ConnectionError(
                              "did not receive join response, got ".concat((_c = resp.message) === null || _c === void 0 ? void 0 : _c["case"], " instead"),
                              2
                              /* ConnectionErrorReason.InternalError */
                            ));
                          }
                          if (shouldProcessMessage) {
                            _context5.n = 4;
                            break;
                          }
                          return _context5.a(2);
                        case 4:
                          if (!this.signalLatency) {
                            _context5.n = 5;
                            break;
                          }
                          _context5.n = 5;
                          return sleep(this.signalLatency);
                        case 5:
                          this.handleSignalResponse(resp);
                        case 6:
                          return _context5.a(2);
                      }
                    }, _callee5, this);
                  }));
                };
                this.ws.onclose = function(ev) {
                  if (_this3.isEstablishingConnection) {
                    reject(new ConnectionError(
                      "Websocket got closed during a (re)connection attempt",
                      2
                      /* ConnectionErrorReason.InternalError */
                    ));
                  }
                  _this3.log.warn("websocket closed", Object.assign(Object.assign({}, _this3.logContext), {
                    reason: ev.reason,
                    code: ev.code,
                    wasClean: ev.wasClean,
                    state: _this3.state
                  }));
                  _this3.handleOnClose(ev.reason);
                };
              case 4:
                _context6.p = 4;
                unlock();
                return _context6.f(4);
              case 5:
                return _context6.a(2);
            }
          }, _callee6, this, [[2, , 4, 5]]);
        }));
      });
    }
  }, {
    key: "close",
    value: function close() {
      return __awaiter(this, arguments, void 0, function() {
        var _this4 = this;
        var updateState = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        return _regenerator().m(function _callee7() {
          var unlock, closePromise;
          return _regenerator().w(function(_context7) {
            while (1) switch (_context7.n) {
              case 0:
                _context7.n = 1;
                return _this4.closingLock.lock();
              case 1:
                unlock = _context7.v;
                _context7.p = 2;
                _this4.clearPingInterval();
                if (updateState) {
                  _this4.state = SignalConnectionState.DISCONNECTING;
                }
                if (!_this4.ws) {
                  _context7.n = 4;
                  break;
                }
                _this4.ws.onmessage = null;
                _this4.ws.onopen = null;
                _this4.ws.onclose = null;
                closePromise = new Promise(function(resolve) {
                  if (_this4.ws) {
                    _this4.ws.onclose = function() {
                      resolve();
                    };
                  } else {
                    resolve();
                  }
                });
                if (!(_this4.ws.readyState < _this4.ws.CLOSING)) {
                  _context7.n = 3;
                  break;
                }
                _this4.ws.close();
                _context7.n = 3;
                return Promise.race([closePromise, sleep(250)]);
              case 3:
                _this4.ws = void 0;
              case 4:
                _context7.p = 4;
                if (updateState) {
                  _this4.state = SignalConnectionState.DISCONNECTED;
                }
                unlock();
                return _context7.f(4);
              case 5:
                return _context7.a(2);
            }
          }, _callee7, null, [[2, , 4, 5]]);
        })();
      });
    }
    // initial offer after joining
  }, {
    key: "sendOffer",
    value: function sendOffer(offer) {
      this.log.debug("sending offer", Object.assign(Object.assign({}, this.logContext), {
        offerSdp: offer.sdp
      }));
      this.sendRequest({
        "case": "offer",
        value: toProtoSessionDescription(offer)
      });
    }
    // answer a server-initiated offer
  }, {
    key: "sendAnswer",
    value: function sendAnswer(answer) {
      this.log.debug("sending answer", Object.assign(Object.assign({}, this.logContext), {
        answerSdp: answer.sdp
      }));
      return this.sendRequest({
        "case": "answer",
        value: toProtoSessionDescription(answer)
      });
    }
  }, {
    key: "sendIceCandidate",
    value: function sendIceCandidate(candidate, target) {
      this.log.trace("sending ice candidate", Object.assign(Object.assign({}, this.logContext), {
        candidate
      }));
      return this.sendRequest({
        "case": "trickle",
        value: new TrickleRequest({
          candidateInit: JSON.stringify(candidate),
          target
        })
      });
    }
  }, {
    key: "sendMuteTrack",
    value: function sendMuteTrack(trackSid, muted) {
      this.log.debug("sending Mute Track req to server", Object.assign(Object.assign({}, this.logContext), {
        trackSid,
        muted
      }));
      return this.sendRequest({
        "case": "mute",
        value: new MuteTrackRequest({
          sid: trackSid,
          muted
        })
      });
    }
  }, {
    key: "sendAddTrack",
    value: function sendAddTrack(req) {
      this.log.debug("sending Add Track req to server", Object.assign(Object.assign({}, this.logContext), {
        req
      }));
      return this.sendRequest({
        "case": "addTrack",
        value: req
      });
    }
  }, {
    key: "sendUpdateLocalMetadata",
    value: function sendUpdateLocalMetadata(metadata_1, name_1) {
      return __awaiter(this, arguments, void 0, function(metadata, name) {
        var _this5 = this;
        var attributes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return _regenerator().m(function _callee8() {
          var requestId;
          return _regenerator().w(function(_context8) {
            while (1) switch (_context8.n) {
              case 0:
                requestId = _this5.getNextRequestId();
                _context8.n = 1;
                return _this5.sendRequest({
                  "case": "updateMetadata",
                  value: new UpdateParticipantMetadata({
                    requestId,
                    metadata,
                    name,
                    attributes
                  })
                });
              case 1:
                return _context8.a(2, requestId);
            }
          }, _callee8);
        })();
      });
    }
  }, {
    key: "sendUpdateTrackSettings",
    value: function sendUpdateTrackSettings(settings) {
      this.log.debug("sending Update Track setting req to server", Object.assign(Object.assign({}, this.logContext), {
        settings
      }));
      this.sendRequest({
        "case": "trackSetting",
        value: settings
      });
    }
  }, {
    key: "sendUpdateSubscription",
    value: function sendUpdateSubscription(sub) {
      this.log.debug("sending Update Subscription req to server", Object.assign(Object.assign({}, this.logContext), {
        sub
      }));
      return this.sendRequest({
        "case": "subscription",
        value: sub
      });
    }
  }, {
    key: "sendSyncState",
    value: function sendSyncState(sync) {
      this.log.debug("sending sync state req to server", Object.assign(Object.assign({}, this.logContext), {
        sync
      }));
      return this.sendRequest({
        "case": "syncState",
        value: sync
      });
    }
  }, {
    key: "sendUpdateVideoLayers",
    value: function sendUpdateVideoLayers(trackSid, layers) {
      this.log.debug("sending update video layer req to server", Object.assign(Object.assign({}, this.logContext), {
        trackSid,
        layers
      }));
      return this.sendRequest({
        "case": "updateLayers",
        value: new UpdateVideoLayers({
          trackSid,
          layers
        })
      });
    }
  }, {
    key: "sendUpdateSubscriptionPermissions",
    value: function sendUpdateSubscriptionPermissions(allParticipants, trackPermissions) {
      this.log.debug("sending update subscription permission req to server", Object.assign(Object.assign({}, this.logContext), {
        allParticipants,
        trackPermissions
      }));
      return this.sendRequest({
        "case": "subscriptionPermission",
        value: new SubscriptionPermission({
          allParticipants,
          trackPermissions
        })
      });
    }
  }, {
    key: "sendSimulateScenario",
    value: function sendSimulateScenario(scenario) {
      this.log.debug("sending simulate scenario req to server", Object.assign(Object.assign({}, this.logContext), {
        scenario
      }));
      return this.sendRequest({
        "case": "simulate",
        value: scenario
      });
    }
  }, {
    key: "sendPing",
    value: function sendPing() {
      this.log.debug("sending ping req to server", this.logContext);
      return Promise.all([this.sendRequest({
        "case": "ping",
        value: protoInt64.parse(Date.now())
      }), this.sendRequest({
        "case": "pingReq",
        value: new Ping({
          timestamp: protoInt64.parse(Date.now()),
          rtt: protoInt64.parse(this.rtt)
        })
      })]);
    }
  }, {
    key: "sendUpdateLocalAudioTrack",
    value: function sendUpdateLocalAudioTrack(trackSid, features) {
      return this.sendRequest({
        "case": "updateAudioTrack",
        value: new UpdateLocalAudioTrack({
          trackSid,
          features
        })
      });
    }
  }, {
    key: "sendLeave",
    value: function sendLeave() {
      this.log.debug("sending leave req to server", this.logContext);
      return this.sendRequest({
        "case": "leave",
        value: new LeaveRequest({
          canReconnect: false,
          reason: DisconnectReason.CLIENT_INITIATED,
          // server doesn't process this field, keeping it here to indicate the intent of a full disconnect
          action: LeaveRequest_Action.DISCONNECT
        })
      });
    }
  }, {
    key: "sendRequest",
    value: function sendRequest(message_1) {
      return __awaiter(this, arguments, void 0, function(message) {
        var _this6 = this;
        var fromQueue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        return _regenerator().m(function _callee0() {
          var canQueue, req;
          return _regenerator().w(function(_context0) {
            while (1) switch (_context0.n) {
              case 0:
                _this6.log.debug("sending request  to server ", Object.assign(Object.assign({}, _this6.logContext), {
                  message
                }));
                canQueue = !fromQueue && !canPassThroughQueue(message);
                if (!(canQueue && _this6.state === SignalConnectionState.RECONNECTING)) {
                  _context0.n = 1;
                  break;
                }
                _this6.queuedRequests.push(function() {
                  return __awaiter(_this6, void 0, void 0, _regenerator().m(function _callee9() {
                    return _regenerator().w(function(_context9) {
                      while (1) switch (_context9.n) {
                        case 0:
                          _context9.n = 1;
                          return this.sendRequest(message, true);
                        case 1:
                          return _context9.a(2);
                      }
                    }, _callee9, this);
                  }));
                });
                return _context0.a(2);
              case 1:
                if (fromQueue) {
                  _context0.n = 2;
                  break;
                }
                _context0.n = 2;
                return _this6.requestQueue.flush();
              case 2:
                if (!_this6.signalLatency) {
                  _context0.n = 3;
                  break;
                }
                _context0.n = 3;
                return sleep(_this6.signalLatency);
              case 3:
                if (!(!_this6.ws || _this6.ws.readyState !== _this6.ws.OPEN)) {
                  _context0.n = 4;
                  break;
                }
                _this6.log.error("cannot send signal request before connected, type: ".concat(message === null || message === void 0 ? void 0 : message["case"]), _this6.logContext);
                return _context0.a(2);
              case 4:
                req = new SignalRequest({
                  message
                });
                try {
                  if (_this6.useJSON) {
                    _this6.ws.send(req.toJsonString());
                  } else {
                    _this6.ws.send(req.toBinary());
                  }
                } catch (e) {
                  _this6.log.error("error sending signal message", Object.assign(Object.assign({}, _this6.logContext), {
                    error: e
                  }));
                }
              case 5:
                return _context0.a(2);
            }
          }, _callee0);
        })();
      });
    }
  }, {
    key: "handleSignalResponse",
    value: function handleSignalResponse(res) {
      var _a, _b;
      var msg = res.message;
      if (msg == void 0) {
        this.log.debug("received unsupported message", this.logContext);
        return;
      }
      var pingHandled = false;
      if (msg["case"] === "answer") {
        this.log.debug("the answer response from server is: ", Object.assign(Object.assign({}, this.logContext), {
          response: res
        }));
        var sd = fromProtoSessionDescription(msg.value);
        if (this.onAnswer) {
          this.onAnswer(sd);
        }
      } else if (msg["case"] === "offer") {
        this.log.debug("the offer response from server is: ", Object.assign(Object.assign({}, this.logContext), {
          response: res
        }));
        var _sd = fromProtoSessionDescription(msg.value);
        if (this.onOffer) {
          this.onOffer(_sd);
        }
      } else if (msg["case"] === "trickle") {
        this.log.debug("the trickle response from server is: ", Object.assign(Object.assign({}, this.logContext), {
          response: res
        }));
        var candidate = JSON.parse(msg.value.candidateInit);
        if (this.onTrickle) {
          this.onTrickle(candidate, msg.value.target);
        }
      } else if (msg["case"] === "update") {
        this.log.debug("the update response from server is: ", Object.assign(Object.assign({}, this.logContext), {
          response: res
        }));
        if (this.onParticipantUpdate) {
          this.onParticipantUpdate((_a = msg.value.participants) !== null && _a !== void 0 ? _a : []);
        }
      } else if (msg["case"] === "trackPublished") {
        this.log.debug("the trackPublished response from server is: ", Object.assign(Object.assign({}, this.logContext), {
          response: res
        }));
        if (this.onLocalTrackPublished) {
          this.onLocalTrackPublished(msg.value);
        }
      } else if (msg["case"] === "speakersChanged") {
        this.log.debug("the speakersChanged response from server is: ", Object.assign(Object.assign({}, this.logContext), {
          response: res
        }));
        if (this.onSpeakersChanged) {
          this.onSpeakersChanged((_b = msg.value.speakers) !== null && _b !== void 0 ? _b : []);
        }
      } else if (msg["case"] === "leave") {
        this.log.debug("the leave response from server is: ", Object.assign(Object.assign({}, this.logContext), {
          response: res
        }));
        if (this.onLeave) {
          this.onLeave(msg.value);
        }
      } else if (msg["case"] === "mute") {
        this.log.debug("the mute response from server is: ", Object.assign(Object.assign({}, this.logContext), {
          response: res
        }));
        if (this.onRemoteMuteChanged) {
          this.onRemoteMuteChanged(msg.value.sid, msg.value.muted);
        }
      } else if (msg["case"] === "roomUpdate") {
        this.log.debug("the roomUpdate response from server is: ", Object.assign(Object.assign({}, this.logContext), {
          response: res
        }));
        if (this.onRoomUpdate && msg.value.room) {
          this.onRoomUpdate(msg.value.room);
        }
      } else if (msg["case"] === "connectionQuality") {
        this.log.debug("the connectionQuality response from server is: ", Object.assign(Object.assign({}, this.logContext), {
          response: res
        }));
        if (this.onConnectionQuality) {
          this.onConnectionQuality(msg.value);
        }
      } else if (msg["case"] === "streamStateUpdate") {
        this.log.debug("the streamStateUpdate response from server is: ", Object.assign(Object.assign({}, this.logContext), {
          response: res
        }));
        if (this.onStreamStateUpdate) {
          this.onStreamStateUpdate(msg.value);
        }
      } else if (msg["case"] === "subscribedQualityUpdate") {
        this.log.debug("the subscribedQualityUpdate response from server is: ", Object.assign(Object.assign({}, this.logContext), {
          response: res
        }));
        if (this.onSubscribedQualityUpdate) {
          this.onSubscribedQualityUpdate(msg.value);
        }
      } else if (msg["case"] === "subscriptionPermissionUpdate") {
        this.log.debug("the subscriptionPermissionUpdate response from server is: ", Object.assign(Object.assign({}, this.logContext), {
          response: res
        }));
        if (this.onSubscriptionPermissionUpdate) {
          this.onSubscriptionPermissionUpdate(msg.value);
        }
      } else if (msg["case"] === "refreshToken") {
        this.log.debug("the refreshToken response from server is: ", Object.assign(Object.assign({}, this.logContext), {
          response: res
        }));
        if (this.onTokenRefresh) {
          this.onTokenRefresh(msg.value);
        }
      } else if (msg["case"] === "trackUnpublished") {
        this.log.debug("the trackUnpublished response from server is:", Object.assign(Object.assign({}, this.logContext), {
          response: res
        }));
        if (this.onLocalTrackUnpublished) {
          this.onLocalTrackUnpublished(msg.value);
        }
      } else if (msg["case"] === "subscriptionResponse") {
        if (this.onSubscriptionError) {
          this.onSubscriptionError(msg.value);
        }
      } else if (msg["case"] === "pong") ;
      else if (msg["case"] === "pongResp") {
        this.rtt = Date.now() - Number.parseInt(msg.value.lastPingTimestamp.toString());
        this.resetPingTimeout();
        pingHandled = true;
      } else if (msg["case"] === "requestResponse") {
        if (this.onRequestResponse) {
          this.onRequestResponse(msg.value);
        }
      } else if (msg["case"] === "trackSubscribed") {
        if (this.onLocalTrackSubscribed) {
          this.onLocalTrackSubscribed(msg.value.trackSid);
        }
      } else {
        this.log.debug("unsupported message", Object.assign(Object.assign({}, this.logContext), {
          msgCase: msg["case"]
        }));
      }
      if (!pingHandled) {
        this.resetPingTimeout();
      }
    }
  }, {
    key: "setReconnected",
    value: function setReconnected() {
      while (this.queuedRequests.length > 0) {
        var req = this.queuedRequests.shift();
        if (req) {
          this.requestQueue.run(req);
        }
      }
    }
  }, {
    key: "handleOnClose",
    value: function handleOnClose(reason) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee1() {
        var onCloseCallback;
        return _regenerator().w(function(_context1) {
          while (1) switch (_context1.n) {
            case 0:
              if (!(this.state === SignalConnectionState.DISCONNECTED)) {
                _context1.n = 1;
                break;
              }
              return _context1.a(2);
            case 1:
              onCloseCallback = this.onClose;
              _context1.n = 2;
              return this.close();
            case 2:
              this.log.debug("websocket connection closed: ".concat(reason), Object.assign(Object.assign({}, this.logContext), {
                reason
              }));
              if (onCloseCallback) {
                onCloseCallback(reason);
              }
            case 3:
              return _context1.a(2);
          }
        }, _callee1, this);
      }));
    }
  }, {
    key: "handleWSError",
    value: function handleWSError(ev) {
      this.log.error("websocket error", Object.assign(Object.assign({}, this.logContext), {
        error: ev
      }));
    }
    /**
     * Resets the ping timeout and starts a new timeout.
     * Call this after receiving a pong message
     */
  }, {
    key: "resetPingTimeout",
    value: function resetPingTimeout() {
      var _this7 = this;
      this.clearPingTimeout();
      if (!this.pingTimeoutDuration) {
        this.log.warn("ping timeout duration not set", this.logContext);
        return;
      }
      this.pingTimeout = CriticalTimers.setTimeout(function() {
        _this7.log.warn("ping timeout triggered. last pong received at: ".concat(new Date(Date.now() - _this7.pingTimeoutDuration * 1e3).toUTCString()), _this7.logContext);
        _this7.handleOnClose("ping timeout");
      }, this.pingTimeoutDuration * 1e3);
    }
    /**
     * Clears ping timeout (does not start a new timeout)
     */
  }, {
    key: "clearPingTimeout",
    value: function clearPingTimeout() {
      if (this.pingTimeout) {
        CriticalTimers.clearTimeout(this.pingTimeout);
      }
    }
  }, {
    key: "startPingInterval",
    value: function startPingInterval() {
      var _this8 = this;
      this.clearPingInterval();
      this.resetPingTimeout();
      if (!this.pingIntervalDuration) {
        this.log.warn("ping interval duration not set", this.logContext);
        return;
      }
      this.log.debug("start ping interval", this.logContext);
      this.pingInterval = CriticalTimers.setInterval(function() {
        _this8.sendPing();
      }, this.pingIntervalDuration * 1e3);
    }
  }, {
    key: "clearPingInterval",
    value: function clearPingInterval() {
      this.log.debug("clearing ping interval", this.logContext);
      this.clearPingTimeout();
      if (this.pingInterval) {
        CriticalTimers.clearInterval(this.pingInterval);
      }
    }
  }]);
}();
function fromProtoSessionDescription(sd) {
  var rsd = {
    type: "offer",
    sdp: sd.sdp
  };
  switch (sd.type) {
    case "answer":
    case "offer":
    case "pranswer":
    case "rollback":
      rsd.type = sd.type;
      break;
  }
  return rsd;
}
function toProtoSessionDescription(rsd) {
  var sd = new SessionDescription({
    sdp: rsd.sdp,
    type: rsd.type
  });
  return sd;
}
function createConnectionParams(token, info, opts) {
  var _a;
  var params = new URLSearchParams();
  params.set("access_token", token);
  if (opts.reconnect) {
    params.set("reconnect", "1");
    if (opts.sid) {
      params.set("sid", opts.sid);
    }
  }
  params.set("auto_subscribe", opts.autoSubscribe ? "1" : "0");
  params.set("sdk", isReactNative() ? "reactnative" : "js");
  params.set("version", info.version);
  params.set("protocol", info.protocol.toString());
  if (info.deviceModel) {
    params.set("device_model", info.deviceModel);
  }
  if (info.os) {
    params.set("os", info.os);
  }
  if (info.osVersion) {
    params.set("os_version", info.osVersion);
  }
  if (info.browser) {
    params.set("browser", info.browser);
  }
  if (info.browserVersion) {
    params.set("browser_version", info.browserVersion);
  }
  if (opts.adaptiveStream) {
    params.set("adaptive_stream", "1");
  }
  if (opts.reconnectReason) {
    params.set("reconnect_reason", opts.reconnectReason.toString());
  }
  if ((_a = navigator.connection) === null || _a === void 0 ? void 0 : _a.type) {
    params.set("network", navigator.connection.type);
  }
  return "?".concat(params.toString());
}
var parser$1 = {};
var grammar$2 = { exports: {} };
var grammar$1 = grammar$2.exports = {
  v: [{
    name: "version",
    reg: /^(\d*)$/
  }],
  o: [{
    // o=- 20518 0 IN IP4 203.0.113.1
    // NB: sessionId will be a String in most cases because it is huge
    name: "origin",
    reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
    names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"],
    format: "%s %s %d %s IP%d %s"
  }],
  // default parsing of these only (though some of these feel outdated)
  s: [{
    name: "name"
  }],
  i: [{
    name: "description"
  }],
  u: [{
    name: "uri"
  }],
  e: [{
    name: "email"
  }],
  p: [{
    name: "phone"
  }],
  z: [{
    name: "timezones"
  }],
  // TODO: this one can actually be parsed properly...
  r: [{
    name: "repeats"
  }],
  // TODO: this one can also be parsed properly
  // k: [{}], // outdated thing ignored
  t: [{
    // t=0 0
    name: "timing",
    reg: /^(\d*) (\d*)/,
    names: ["start", "stop"],
    format: "%d %d"
  }],
  c: [{
    // c=IN IP4 10.47.197.26
    name: "connection",
    reg: /^IN IP(\d) (\S*)/,
    names: ["version", "ip"],
    format: "IN IP%d %s"
  }],
  b: [{
    // b=AS:4000
    push: "bandwidth",
    reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
    names: ["type", "limit"],
    format: "%s:%s"
  }],
  m: [{
    // m=video 51744 RTP/AVP 126 97 98 34 31
    // NB: special - pushes to session
    // TODO: rtp/fmtp should be filtered by the payloads found here?
    reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
    names: ["type", "port", "protocol", "payloads"],
    format: "%s %d %s %s"
  }],
  a: [
    {
      // a=rtpmap:110 opus/48000/2
      push: "rtp",
      reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
      names: ["payload", "codec", "rate", "encoding"],
      format: function format(o) {
        return o.encoding ? "rtpmap:%d %s/%s/%s" : o.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s";
      }
    },
    {
      // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
      // a=fmtp:111 minptime=10; useinbandfec=1
      push: "fmtp",
      reg: /^fmtp:(\d*) ([\S| ]*)/,
      names: ["payload", "config"],
      format: "fmtp:%d %s"
    },
    {
      // a=control:streamid=0
      name: "control",
      reg: /^control:(.*)/,
      format: "control:%s"
    },
    {
      // a=rtcp:65179 IN IP4 193.84.77.194
      name: "rtcp",
      reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
      names: ["port", "netType", "ipVer", "address"],
      format: function format2(o) {
        return o.address != null ? "rtcp:%d %s IP%d %s" : "rtcp:%d";
      }
    },
    {
      // a=rtcp-fb:98 trr-int 100
      push: "rtcpFbTrrInt",
      reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
      names: ["payload", "value"],
      format: "rtcp-fb:%s trr-int %d"
    },
    {
      // a=rtcp-fb:98 nack rpsi
      push: "rtcpFb",
      reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
      names: ["payload", "type", "subtype"],
      format: function format3(o) {
        return o.subtype != null ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s";
      }
    },
    {
      // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
      // a=extmap:1/recvonly URI-gps-string
      // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24
      push: "ext",
      reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
      names: ["value", "direction", "encrypt-uri", "uri", "config"],
      format: function format4(o) {
        return "extmap:%d" + (o.direction ? "/%s" : "%v") + (o["encrypt-uri"] ? " %s" : "%v") + " %s" + (o.config ? " %s" : "");
      }
    },
    {
      // a=extmap-allow-mixed
      name: "extmapAllowMixed",
      reg: /^(extmap-allow-mixed)/
    },
    {
      // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
      push: "crypto",
      reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
      names: ["id", "suite", "config", "sessionConfig"],
      format: function format5(o) {
        return o.sessionConfig != null ? "crypto:%d %s %s %s" : "crypto:%d %s %s";
      }
    },
    {
      // a=setup:actpass
      name: "setup",
      reg: /^setup:(\w*)/,
      format: "setup:%s"
    },
    {
      // a=connection:new
      name: "connectionType",
      reg: /^connection:(new|existing)/,
      format: "connection:%s"
    },
    {
      // a=mid:1
      name: "mid",
      reg: /^mid:([^\s]*)/,
      format: "mid:%s"
    },
    {
      // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
      name: "msid",
      reg: /^msid:(.*)/,
      format: "msid:%s"
    },
    {
      // a=ptime:20
      name: "ptime",
      reg: /^ptime:(\d*(?:\.\d*)*)/,
      format: "ptime:%d"
    },
    {
      // a=maxptime:60
      name: "maxptime",
      reg: /^maxptime:(\d*(?:\.\d*)*)/,
      format: "maxptime:%d"
    },
    {
      // a=sendrecv
      name: "direction",
      reg: /^(sendrecv|recvonly|sendonly|inactive)/
    },
    {
      // a=ice-lite
      name: "icelite",
      reg: /^(ice-lite)/
    },
    {
      // a=ice-ufrag:F7gI
      name: "iceUfrag",
      reg: /^ice-ufrag:(\S*)/,
      format: "ice-ufrag:%s"
    },
    {
      // a=ice-pwd:x9cml/YzichV2+XlhiMu8g
      name: "icePwd",
      reg: /^ice-pwd:(\S*)/,
      format: "ice-pwd:%s"
    },
    {
      // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
      name: "fingerprint",
      reg: /^fingerprint:(\S*) (\S*)/,
      names: ["type", "hash"],
      format: "fingerprint:%s %s"
    },
    {
      // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
      // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
      // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
      // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
      // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
      push: "candidates",
      reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
      names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"],
      format: function format6(o) {
        var str = "candidate:%s %d %s %d %s %d typ %s";
        str += o.raddr != null ? " raddr %s rport %d" : "%v%v";
        str += o.tcptype != null ? " tcptype %s" : "%v";
        if (o.generation != null) {
          str += " generation %d";
        }
        str += o["network-id"] != null ? " network-id %d" : "%v";
        str += o["network-cost"] != null ? " network-cost %d" : "%v";
        return str;
      }
    },
    {
      // a=end-of-candidates (keep after the candidates line for readability)
      name: "endOfCandidates",
      reg: /^(end-of-candidates)/
    },
    {
      // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
      name: "remoteCandidates",
      reg: /^remote-candidates:(.*)/,
      format: "remote-candidates:%s"
    },
    {
      // a=ice-options:google-ice
      name: "iceOptions",
      reg: /^ice-options:(\S*)/,
      format: "ice-options:%s"
    },
    {
      // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
      push: "ssrcs",
      reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
      names: ["id", "attribute", "value"],
      format: function format7(o) {
        var str = "ssrc:%d";
        if (o.attribute != null) {
          str += " %s";
          if (o.value != null) {
            str += ":%s";
          }
        }
        return str;
      }
    },
    {
      // a=ssrc-group:FEC 1 2
      // a=ssrc-group:FEC-FR 3004364195 1080772241
      push: "ssrcGroups",
      // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
      reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
      names: ["semantics", "ssrcs"],
      format: "ssrc-group:%s %s"
    },
    {
      // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
      name: "msidSemantic",
      reg: /^msid-semantic:\s?(\w*) (\S*)/,
      names: ["semantic", "token"],
      format: "msid-semantic: %s %s"
      // space after ':' is not accidental
    },
    {
      // a=group:BUNDLE audio video
      push: "groups",
      reg: /^group:(\w*) (.*)/,
      names: ["type", "mids"],
      format: "group:%s %s"
    },
    {
      // a=rtcp-mux
      name: "rtcpMux",
      reg: /^(rtcp-mux)/
    },
    {
      // a=rtcp-rsize
      name: "rtcpRsize",
      reg: /^(rtcp-rsize)/
    },
    {
      // a=sctpmap:5000 webrtc-datachannel 1024
      name: "sctpmap",
      reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
      names: ["sctpmapNumber", "app", "maxMessageSize"],
      format: function format8(o) {
        return o.maxMessageSize != null ? "sctpmap:%s %s %s" : "sctpmap:%s %s";
      }
    },
    {
      // a=x-google-flag:conference
      name: "xGoogleFlag",
      reg: /^x-google-flag:([^\s]*)/,
      format: "x-google-flag:%s"
    },
    {
      // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
      push: "rids",
      reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
      names: ["id", "direction", "params"],
      format: function format9(o) {
        return o.params ? "rid:%s %s %s" : "rid:%s %s";
      }
    },
    {
      // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
      // a=imageattr:* send [x=800,y=640] recv *
      // a=imageattr:100 recv [x=320,y=240]
      push: "imageattrs",
      reg: new RegExp(
        // a=imageattr:97
        "^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"
      ),
      names: ["pt", "dir1", "attrs1", "dir2", "attrs2"],
      format: function format10(o) {
        return "imageattr:%s %s %s" + (o.dir2 ? " %s %s" : "");
      }
    },
    {
      // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
      // a=simulcast:recv 1;4,5 send 6;7
      name: "simulcast",
      reg: new RegExp(
        // a=simulcast:
        "^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"
      ),
      names: ["dir1", "list1", "dir2", "list2"],
      format: function format11(o) {
        return "simulcast:%s %s" + (o.dir2 ? " %s %s" : "");
      }
    },
    {
      // old simulcast draft 03 (implemented by Firefox)
      //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
      // a=simulcast: recv pt=97;98 send pt=97
      // a=simulcast: send rid=5;6;7 paused=6,7
      name: "simulcast_03",
      reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
      names: ["value"],
      format: "simulcast: %s"
    },
    {
      // a=framerate:25
      // a=framerate:29.97
      name: "framerate",
      reg: /^framerate:(\d+(?:$|\.\d+))/,
      format: "framerate:%s"
    },
    {
      // RFC4570
      // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
      name: "sourceFilter",
      reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
      names: ["filterMode", "netType", "addressTypes", "destAddress", "srcList"],
      format: "source-filter: %s %s %s %s %s"
    },
    {
      // a=bundle-only
      name: "bundleOnly",
      reg: /^(bundle-only)/
    },
    {
      // a=label:1
      name: "label",
      reg: /^label:(.+)/,
      format: "label:%s"
    },
    {
      // RFC version 26 for SCTP over DTLS
      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5
      name: "sctpPort",
      reg: /^sctp-port:(\d+)$/,
      format: "sctp-port:%s"
    },
    {
      // RFC version 26 for SCTP over DTLS
      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6
      name: "maxMessageSize",
      reg: /^max-message-size:(\d+)$/,
      format: "max-message-size:%s"
    },
    {
      // RFC7273
      // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37
      push: "tsRefClocks",
      reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
      names: ["clksrc", "clksrcExt"],
      format: function format12(o) {
        return "ts-refclk:%s" + (o.clksrcExt != null ? "=%s" : "");
      }
    },
    {
      // RFC7273
      // a=mediaclk:direct=963214424
      name: "mediaClk",
      reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
      names: ["id", "mediaClockName", "mediaClockValue", "rateNumerator", "rateDenominator"],
      format: function format13(o) {
        var str = "mediaclk:";
        str += o.id != null ? "id=%s %s" : "%v%s";
        str += o.mediaClockValue != null ? "=%s" : "";
        str += o.rateNumerator != null ? " rate=%s" : "";
        str += o.rateDenominator != null ? "/%s" : "";
        return str;
      }
    },
    {
      // a=keywds:keywords
      name: "keywords",
      reg: /^keywds:(.+)$/,
      format: "keywds:%s"
    },
    {
      // a=content:main
      name: "content",
      reg: /^content:(.+)/,
      format: "content:%s"
    },
    // BFCP https://tools.ietf.org/html/rfc4583
    {
      // a=floorctrl:c-s
      name: "bfcpFloorCtrl",
      reg: /^floorctrl:(c-only|s-only|c-s)/,
      format: "floorctrl:%s"
    },
    {
      // a=confid:1
      name: "bfcpConfId",
      reg: /^confid:(\d+)/,
      format: "confid:%s"
    },
    {
      // a=userid:1
      name: "bfcpUserId",
      reg: /^userid:(\d+)/,
      format: "userid:%s"
    },
    {
      // a=floorid:1
      name: "bfcpFloorId",
      reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
      names: ["id", "mStream"],
      format: "floorid:%s mstrm:%s"
    },
    {
      // any a= that we don't understand is kept verbatim on media.invalid
      push: "invalid",
      names: ["value"]
    }
  ]
};
Object.keys(grammar$1).forEach(function(key) {
  var objs = grammar$1[key];
  objs.forEach(function(obj) {
    if (!obj.reg) {
      obj.reg = /(.*)/;
    }
    if (!obj.format) {
      obj.format = "%s";
    }
  });
});
var grammarExports = grammar$2.exports;
(function(exports) {
  var toIntIfInt = function toIntIfInt2(v) {
    return String(Number(v)) === v ? Number(v) : v;
  };
  var attachProperties = function attachProperties2(match, location, names, rawName) {
    if (rawName && !names) {
      location[rawName] = toIntIfInt(match[1]);
    } else {
      for (var i = 0; i < names.length; i += 1) {
        if (match[i + 1] != null) {
          location[names[i]] = toIntIfInt(match[i + 1]);
        }
      }
    }
  };
  var parseReg = function parseReg2(obj, location, content) {
    var needsBlank = obj.name && obj.names;
    if (obj.push && !location[obj.push]) {
      location[obj.push] = [];
    } else if (needsBlank && !location[obj.name]) {
      location[obj.name] = {};
    }
    var keyLocation = obj.push ? {} : (
      // blank object that will be pushed
      needsBlank ? location[obj.name] : location
    );
    attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);
    if (obj.push) {
      location[obj.push].push(keyLocation);
    }
  };
  var grammar2 = grammarExports;
  var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
  exports.parse = function(sdp2) {
    var session = {}, media = [], location = session;
    sdp2.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function(l) {
      var type = l[0];
      var content = l.slice(2);
      if (type === "m") {
        media.push({
          rtp: [],
          fmtp: []
        });
        location = media[media.length - 1];
      }
      for (var j = 0; j < (grammar2[type] || []).length; j += 1) {
        var obj = grammar2[type][j];
        if (obj.reg.test(content)) {
          return parseReg(obj, location, content);
        }
      }
    });
    session.media = media;
    return session;
  };
  var paramReducer = function paramReducer2(acc, expr) {
    var s = expr.split(/=(.+)/, 2);
    if (s.length === 2) {
      acc[s[0]] = toIntIfInt(s[1]);
    } else if (s.length === 1 && expr.length > 1) {
      acc[s[0]] = void 0;
    }
    return acc;
  };
  exports.parseParams = function(str) {
    return str.split(/;\s?/).reduce(paramReducer, {});
  };
  exports.parseFmtpConfig = exports.parseParams;
  exports.parsePayloads = function(str) {
    return str.toString().split(" ").map(Number);
  };
  exports.parseRemoteCandidates = function(str) {
    var candidates = [];
    var parts = str.split(" ").map(toIntIfInt);
    for (var i = 0; i < parts.length; i += 3) {
      candidates.push({
        component: parts[i],
        ip: parts[i + 1],
        port: parts[i + 2]
      });
    }
    return candidates;
  };
  exports.parseImageAttributes = function(str) {
    return str.split(" ").map(function(item) {
      return item.substring(1, item.length - 1).split(",").reduce(paramReducer, {});
    });
  };
  exports.parseSimulcastStreamList = function(str) {
    return str.split(";").map(function(stream) {
      return stream.split(",").map(function(format16) {
        var scid, paused = false;
        if (format16[0] !== "~") {
          scid = toIntIfInt(format16);
        } else {
          scid = toIntIfInt(format16.substring(1, format16.length));
          paused = true;
        }
        return {
          scid,
          paused
        };
      });
    });
  };
})(parser$1);
var grammar = grammarExports;
var formatRegExp = /%[sdv%]/g;
var format14 = function format15(formatStr) {
  var i = 1;
  var args = arguments;
  var len = args.length;
  return formatStr.replace(formatRegExp, function(x) {
    if (i >= len) {
      return x;
    }
    var arg = args[i];
    i += 1;
    switch (x) {
      case "%%":
        return "%";
      case "%s":
        return String(arg);
      case "%d":
        return Number(arg);
      case "%v":
        return "";
    }
  });
};
var makeLine = function makeLine2(type, obj, location) {
  var str = obj.format instanceof Function ? obj.format(obj.push ? location : location[obj.name]) : obj.format;
  var args = [type + "=" + str];
  if (obj.names) {
    for (var i = 0; i < obj.names.length; i += 1) {
      var n = obj.names[i];
      if (obj.name) {
        args.push(location[obj.name][n]);
      } else {
        args.push(location[obj.names[i]]);
      }
    }
  } else {
    args.push(location[obj.name]);
  }
  return format14.apply(null, args);
};
var defaultOuterOrder = ["v", "o", "s", "i", "u", "e", "p", "c", "b", "t", "r", "z", "a"];
var defaultInnerOrder = ["i", "c", "b", "a"];
var writer$1 = function writer(session, opts) {
  opts = opts || {};
  if (session.version == null) {
    session.version = 0;
  }
  if (session.name == null) {
    session.name = " ";
  }
  session.media.forEach(function(mLine) {
    if (mLine.payloads == null) {
      mLine.payloads = "";
    }
  });
  var outerOrder = opts.outerOrder || defaultOuterOrder;
  var innerOrder = opts.innerOrder || defaultInnerOrder;
  var sdp2 = [];
  outerOrder.forEach(function(type) {
    grammar[type].forEach(function(obj) {
      if (obj.name in session && session[obj.name] != null) {
        sdp2.push(makeLine(type, obj, session));
      } else if (obj.push in session && session[obj.push] != null) {
        session[obj.push].forEach(function(el) {
          sdp2.push(makeLine(type, obj, el));
        });
      }
    });
  });
  session.media.forEach(function(mLine) {
    sdp2.push(makeLine("m", grammar.m[0], mLine));
    innerOrder.forEach(function(type) {
      grammar[type].forEach(function(obj) {
        if (obj.name in mLine && mLine[obj.name] != null) {
          sdp2.push(makeLine(type, obj, mLine));
        } else if (obj.push in mLine && mLine[obj.push] != null) {
          mLine[obj.push].forEach(function(el) {
            sdp2.push(makeLine(type, obj, el));
          });
        }
      });
    });
  });
  return sdp2.join("\r\n") + "\r\n";
};
var parser = parser$1;
var writer2 = writer$1;
var write = writer2;
var parse = parser.parse;
parser.parseParams;
parser.parseFmtpConfig;
parser.parsePayloads;
parser.parseRemoteCandidates;
parser.parseImageAttributes;
parser.parseSimulcastStreamList;
var startBitrateForSVC = 0.7;
var debounceInterval = 20;
var PCEvents = {
  NegotiationStarted: "negotiationStarted",
  NegotiationComplete: "negotiationComplete",
  RTPVideoPayloadTypes: "rtpVideoPayloadTypes"
};
var PCTransport = function(_EventEmitter) {
  function PCTransport2(config) {
    var _this;
    var loggerOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, PCTransport2);
    var _a;
    _this = _callSuper(this, PCTransport2);
    _this.log = livekitLogger;
    _this.ddExtID = 0;
    _this.pendingCandidates = [];
    _this.restartingIce = false;
    _this.renegotiate = false;
    _this.trackBitrates = [];
    _this.remoteStereoMids = [];
    _this.remoteNackMids = [];
    _this.negotiate = r(function(onError) {
      return __awaiter(_this, void 0, void 0, _regenerator().m(function _callee() {
        var _t;
        return _regenerator().w(function(_context) {
          while (1) switch (_context.n) {
            case 0:
              this.emit(PCEvents.NegotiationStarted);
              _context.p = 1;
              _context.n = 2;
              return this.createAndSendOffer();
            case 2:
              _context.n = 5;
              break;
            case 3:
              _context.p = 3;
              _t = _context.v;
              if (!onError) {
                _context.n = 4;
                break;
              }
              onError(_t);
              _context.n = 5;
              break;
            case 4:
              throw _t;
            case 5:
              return _context.a(2);
          }
        }, _callee, this, [[1, 3]]);
      }));
    }, debounceInterval);
    _this.close = function() {
      if (!_this._pc) {
        return;
      }
      _this._pc.close();
      _this._pc.onconnectionstatechange = null;
      _this._pc.oniceconnectionstatechange = null;
      _this._pc.onicegatheringstatechange = null;
      _this._pc.ondatachannel = null;
      _this._pc.onnegotiationneeded = null;
      _this._pc.onsignalingstatechange = null;
      _this._pc.onicecandidate = null;
      _this._pc.ondatachannel = null;
      _this._pc.ontrack = null;
      _this._pc.onconnectionstatechange = null;
      _this._pc.oniceconnectionstatechange = null;
      _this._pc = null;
    };
    _this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.PCTransport);
    _this.loggerOptions = loggerOptions;
    _this.config = config;
    _this._pc = _this.createPC();
    return _this;
  }
  _inherits(PCTransport2, _EventEmitter);
  return _createClass(PCTransport2, [{
    key: "pc",
    get: function get2() {
      if (!this._pc) {
        this._pc = this.createPC();
      }
      return this._pc;
    }
  }, {
    key: "createPC",
    value: function createPC() {
      var _this2 = this;
      var pc = new RTCPeerConnection(this.config);
      pc.onicecandidate = function(ev) {
        var _a;
        if (!ev.candidate) return;
        (_a = _this2.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(_this2, ev.candidate);
      };
      pc.onicecandidateerror = function(ev) {
        var _a;
        (_a = _this2.onIceCandidateError) === null || _a === void 0 ? void 0 : _a.call(_this2, ev);
      };
      pc.oniceconnectionstatechange = function() {
        var _a;
        (_a = _this2.onIceConnectionStateChange) === null || _a === void 0 ? void 0 : _a.call(_this2, pc.iceConnectionState);
      };
      pc.onsignalingstatechange = function() {
        var _a;
        (_a = _this2.onSignalingStatechange) === null || _a === void 0 ? void 0 : _a.call(_this2, pc.signalingState);
      };
      pc.onconnectionstatechange = function() {
        var _a;
        (_a = _this2.onConnectionStateChange) === null || _a === void 0 ? void 0 : _a.call(_this2, pc.connectionState);
      };
      pc.ondatachannel = function(ev) {
        var _a;
        (_a = _this2.onDataChannel) === null || _a === void 0 ? void 0 : _a.call(_this2, ev);
      };
      pc.ontrack = function(ev) {
        var _a;
        (_a = _this2.onTrack) === null || _a === void 0 ? void 0 : _a.call(_this2, ev);
      };
      return pc;
    }
  }, {
    key: "logContext",
    get: function get2() {
      var _a, _b;
      return Object.assign({}, (_b = (_a = this.loggerOptions).loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));
    }
  }, {
    key: "isICEConnected",
    get: function get2() {
      return this._pc !== null && (this.pc.iceConnectionState === "connected" || this.pc.iceConnectionState === "completed");
    }
  }, {
    key: "addIceCandidate",
    value: function addIceCandidate(candidate) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee2() {
        return _regenerator().w(function(_context2) {
          while (1) switch (_context2.n) {
            case 0:
              if (!(this.pc.remoteDescription && !this.restartingIce)) {
                _context2.n = 1;
                break;
              }
              return _context2.a(2, this.pc.addIceCandidate(candidate));
            case 1:
              this.pendingCandidates.push(candidate);
            case 2:
              return _context2.a(2);
          }
        }, _callee2, this);
      }));
    }
  }, {
    key: "setRemoteDescription",
    value: function setRemoteDescription(sd) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee3() {
        var _this3 = this;
        var _a, mungedSDP, _extractStereoAndNack, stereoMids, nackMids, sdpParsed, _sdpParsed;
        return _regenerator().w(function(_context3) {
          while (1) switch (_context3.n) {
            case 0:
              mungedSDP = void 0;
              if (sd.type === "offer") {
                _extractStereoAndNack = extractStereoAndNackAudioFromOffer(sd), stereoMids = _extractStereoAndNack.stereoMids, nackMids = _extractStereoAndNack.nackMids;
                this.remoteStereoMids = stereoMids;
                this.remoteNackMids = nackMids;
              } else if (sd.type === "answer") {
                sdpParsed = parse((_a = sd.sdp) !== null && _a !== void 0 ? _a : "");
                sdpParsed.media.forEach(function(media) {
                  if (media.type === "audio") {
                    _this3.trackBitrates.some(function(trackbr) {
                      if (!trackbr.transceiver || media.mid != trackbr.transceiver.mid) {
                        return false;
                      }
                      var codecPayload = 0;
                      media.rtp.some(function(rtp) {
                        if (rtp.codec.toUpperCase() === trackbr.codec.toUpperCase()) {
                          codecPayload = rtp.payload;
                          return true;
                        }
                        return false;
                      });
                      if (codecPayload === 0) {
                        return true;
                      }
                      var fmtpFound = false;
                      var _iterator = _createForOfIteratorHelper(media.fmtp), _step;
                      try {
                        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                          var fmtp = _step.value;
                          if (fmtp.payload === codecPayload) {
                            fmtp.config = fmtp.config.split(";").filter(function(attr) {
                              return !attr.includes("maxaveragebitrate");
                            }).join(";");
                            if (trackbr.maxbr > 0) {
                              fmtp.config += ";maxaveragebitrate=".concat(trackbr.maxbr * 1e3);
                            }
                            fmtpFound = true;
                            break;
                          }
                        }
                      } catch (err) {
                        _iterator.e(err);
                      } finally {
                        _iterator.f();
                      }
                      if (!fmtpFound) {
                        if (trackbr.maxbr > 0) {
                          media.fmtp.push({
                            payload: codecPayload,
                            config: "maxaveragebitrate=".concat(trackbr.maxbr * 1e3)
                          });
                        }
                      }
                      return true;
                    });
                  }
                });
                mungedSDP = write(sdpParsed);
              }
              _context3.n = 1;
              return this.setMungedSDP(sd, mungedSDP, true);
            case 1:
              this.pendingCandidates.forEach(function(candidate) {
                _this3.pc.addIceCandidate(candidate);
              });
              this.pendingCandidates = [];
              this.restartingIce = false;
              if (!this.renegotiate) {
                _context3.n = 3;
                break;
              }
              this.renegotiate = false;
              _context3.n = 2;
              return this.createAndSendOffer();
            case 2:
              _context3.n = 4;
              break;
            case 3:
              if (sd.type === "answer") {
                this.emit(PCEvents.NegotiationComplete);
                if (sd.sdp) {
                  _sdpParsed = parse(sd.sdp);
                  _sdpParsed.media.forEach(function(media) {
                    if (media.type === "video") {
                      _this3.emit(PCEvents.RTPVideoPayloadTypes, media.rtp);
                    }
                  });
                }
              }
            case 4:
              return _context3.a(2);
          }
        }, _callee3, this);
      }));
    }
  }, {
    key: "createAndSendOffer",
    value: function createAndSendOffer(options) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee4() {
        var _this4 = this;
        var _a, currentSD, offer, sdpParsed;
        return _regenerator().w(function(_context4) {
          while (1) switch (_context4.n) {
            case 0:
              if (!(this.onOffer === void 0)) {
                _context4.n = 1;
                break;
              }
              return _context4.a(2);
            case 1:
              if (options === null || options === void 0 ? void 0 : options.iceRestart) {
                this.log.debug("restarting ICE", this.logContext);
                this.restartingIce = true;
              }
              if (!(this._pc && this._pc.signalingState === "have-local-offer")) {
                _context4.n = 5;
                break;
              }
              currentSD = this._pc.remoteDescription;
              if (!((options === null || options === void 0 ? void 0 : options.iceRestart) && currentSD)) {
                _context4.n = 3;
                break;
              }
              _context4.n = 2;
              return this._pc.setRemoteDescription(currentSD);
            case 2:
              _context4.n = 4;
              break;
            case 3:
              this.renegotiate = true;
              return _context4.a(2);
            case 4:
              _context4.n = 6;
              break;
            case 5:
              if (!(!this._pc || this._pc.signalingState === "closed")) {
                _context4.n = 6;
                break;
              }
              this.log.warn("could not createOffer with closed peer connection", this.logContext);
              return _context4.a(2);
            case 6:
              this.log.debug("starting to negotiate", this.logContext);
              _context4.n = 7;
              return this.pc.createOffer(options);
            case 7:
              offer = _context4.v;
              this.log.debug("original offer", Object.assign({
                sdp: offer.sdp
              }, this.logContext));
              sdpParsed = parse((_a = offer.sdp) !== null && _a !== void 0 ? _a : "");
              sdpParsed.media.forEach(function(media) {
                ensureIPAddrMatchVersion(media);
                if (media.type === "audio") {
                  ensureAudioNackAndStereo(media, [], []);
                } else if (media.type === "video") {
                  _this4.trackBitrates.some(function(trackbr) {
                    if (!media.msid || !trackbr.cid || !media.msid.includes(trackbr.cid)) {
                      return false;
                    }
                    var codecPayload = 0;
                    media.rtp.some(function(rtp) {
                      if (rtp.codec.toUpperCase() === trackbr.codec.toUpperCase()) {
                        codecPayload = rtp.payload;
                        return true;
                      }
                      return false;
                    });
                    if (codecPayload === 0) {
                      return true;
                    }
                    if (isSVCCodec(trackbr.codec)) {
                      _this4.ensureVideoDDExtensionForSVC(media, sdpParsed);
                    }
                    if (trackbr.codec !== "av1") {
                      return true;
                    }
                    var startBitrate = Math.round(trackbr.maxbr * startBitrateForSVC);
                    var _iterator2 = _createForOfIteratorHelper(media.fmtp), _step2;
                    try {
                      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                        var fmtp = _step2.value;
                        if (fmtp.payload === codecPayload) {
                          if (!fmtp.config.includes("x-google-start-bitrate")) {
                            fmtp.config += ";x-google-start-bitrate=".concat(startBitrate);
                          }
                          break;
                        }
                      }
                    } catch (err) {
                      _iterator2.e(err);
                    } finally {
                      _iterator2.f();
                    }
                    return true;
                  });
                }
              });
              _context4.n = 8;
              return this.setMungedSDP(offer, write(sdpParsed));
            case 8:
              this.onOffer(offer);
            case 9:
              return _context4.a(2);
          }
        }, _callee4, this);
      }));
    }
  }, {
    key: "createAndSetAnswer",
    value: function createAndSetAnswer() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee5() {
        var _this5 = this;
        var _a, answer, sdpParsed;
        return _regenerator().w(function(_context5) {
          while (1) switch (_context5.n) {
            case 0:
              _context5.n = 1;
              return this.pc.createAnswer();
            case 1:
              answer = _context5.v;
              sdpParsed = parse((_a = answer.sdp) !== null && _a !== void 0 ? _a : "");
              sdpParsed.media.forEach(function(media) {
                ensureIPAddrMatchVersion(media);
                if (media.type === "audio") {
                  ensureAudioNackAndStereo(media, _this5.remoteStereoMids, _this5.remoteNackMids);
                }
              });
              _context5.n = 2;
              return this.setMungedSDP(answer, write(sdpParsed));
            case 2:
              return _context5.a(2, answer);
          }
        }, _callee5, this);
      }));
    }
  }, {
    key: "createDataChannel",
    value: function createDataChannel(label, dataChannelDict) {
      return this.pc.createDataChannel(label, dataChannelDict);
    }
  }, {
    key: "addTransceiver",
    value: function addTransceiver(mediaStreamTrack, transceiverInit) {
      return this.pc.addTransceiver(mediaStreamTrack, transceiverInit);
    }
  }, {
    key: "addTrack",
    value: function addTrack(track) {
      if (!this._pc) {
        throw new UnexpectedConnectionState("PC closed, cannot add track");
      }
      return this._pc.addTrack(track);
    }
  }, {
    key: "setTrackCodecBitrate",
    value: function setTrackCodecBitrate(info) {
      this.trackBitrates.push(info);
    }
  }, {
    key: "setConfiguration",
    value: function setConfiguration(rtcConfig) {
      var _a;
      if (!this._pc) {
        throw new UnexpectedConnectionState("PC closed, cannot configure");
      }
      return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.setConfiguration(rtcConfig);
    }
  }, {
    key: "canRemoveTrack",
    value: function canRemoveTrack() {
      var _a;
      return !!((_a = this._pc) === null || _a === void 0 ? void 0 : _a.removeTrack);
    }
  }, {
    key: "removeTrack",
    value: function removeTrack(sender) {
      var _a;
      return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.removeTrack(sender);
    }
  }, {
    key: "getConnectionState",
    value: function getConnectionState() {
      var _a, _b;
      return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.connectionState) !== null && _b !== void 0 ? _b : "closed";
    }
  }, {
    key: "getICEConnectionState",
    value: function getICEConnectionState() {
      var _a, _b;
      return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.iceConnectionState) !== null && _b !== void 0 ? _b : "closed";
    }
  }, {
    key: "getSignallingState",
    value: function getSignallingState() {
      var _a, _b;
      return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.signalingState) !== null && _b !== void 0 ? _b : "closed";
    }
  }, {
    key: "getTransceivers",
    value: function getTransceivers() {
      var _a, _b;
      return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.getTransceivers()) !== null && _b !== void 0 ? _b : [];
    }
  }, {
    key: "getSenders",
    value: function getSenders() {
      var _a, _b;
      return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.getSenders()) !== null && _b !== void 0 ? _b : [];
    }
  }, {
    key: "getLocalDescription",
    value: function getLocalDescription() {
      var _a;
      return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.localDescription;
    }
  }, {
    key: "getRemoteDescription",
    value: function getRemoteDescription() {
      var _a;
      return (_a = this.pc) === null || _a === void 0 ? void 0 : _a.remoteDescription;
    }
  }, {
    key: "getStats",
    value: function getStats() {
      return this.pc.getStats();
    }
  }, {
    key: "getConnectedAddress",
    value: function getConnectedAddress() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee6() {
        var _a, selectedCandidatePairId, candidatePairs, candidates, stats, selectedID;
        return _regenerator().w(function(_context6) {
          while (1) switch (_context6.n) {
            case 0:
              if (this._pc) {
                _context6.n = 1;
                break;
              }
              return _context6.a(2);
            case 1:
              selectedCandidatePairId = "";
              candidatePairs = /* @__PURE__ */ new Map();
              candidates = /* @__PURE__ */ new Map();
              _context6.n = 2;
              return this._pc.getStats();
            case 2:
              stats = _context6.v;
              stats.forEach(function(v) {
                switch (v.type) {
                  case "transport":
                    selectedCandidatePairId = v.selectedCandidatePairId;
                    break;
                  case "candidate-pair":
                    if (selectedCandidatePairId === "" && v.selected) {
                      selectedCandidatePairId = v.id;
                    }
                    candidatePairs.set(v.id, v);
                    break;
                  case "remote-candidate":
                    candidates.set(v.id, "".concat(v.address, ":").concat(v.port));
                    break;
                }
              });
              if (!(selectedCandidatePairId === "")) {
                _context6.n = 3;
                break;
              }
              return _context6.a(2, void 0);
            case 3:
              selectedID = (_a = candidatePairs.get(selectedCandidatePairId)) === null || _a === void 0 ? void 0 : _a.remoteCandidateId;
              if (!(selectedID === void 0)) {
                _context6.n = 4;
                break;
              }
              return _context6.a(2, void 0);
            case 4:
              return _context6.a(2, candidates.get(selectedID));
          }
        }, _callee6, this);
      }));
    }
  }, {
    key: "setMungedSDP",
    value: function setMungedSDP(sd, munged, remote) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee7() {
        var originalSdp, msg, fields, _t2, _t3;
        return _regenerator().w(function(_context7) {
          while (1) switch (_context7.n) {
            case 0:
              if (!munged) {
                _context7.n = 6;
                break;
              }
              originalSdp = sd.sdp;
              sd.sdp = munged;
              _context7.p = 1;
              this.log.debug("setting munged ".concat(remote ? "remote" : "local", " description"), this.logContext);
              if (!remote) {
                _context7.n = 3;
                break;
              }
              _context7.n = 2;
              return this.pc.setRemoteDescription(sd);
            case 2:
              _context7.n = 4;
              break;
            case 3:
              _context7.n = 4;
              return this.pc.setLocalDescription(sd);
            case 4:
              return _context7.a(2);
            case 5:
              _context7.p = 5;
              _t2 = _context7.v;
              this.log.warn("not able to set ".concat(sd.type, ", falling back to unmodified sdp"), Object.assign(Object.assign({}, this.logContext), {
                error: _t2,
                sdp: munged
              }));
              sd.sdp = originalSdp;
            case 6:
              _context7.p = 6;
              if (!remote) {
                _context7.n = 8;
                break;
              }
              _context7.n = 7;
              return this.pc.setRemoteDescription(sd);
            case 7:
              _context7.n = 9;
              break;
            case 8:
              _context7.n = 9;
              return this.pc.setLocalDescription(sd);
            case 9:
              _context7.n = 11;
              break;
            case 10:
              _context7.p = 10;
              _t3 = _context7.v;
              msg = "unknown error";
              if (_t3 instanceof Error) {
                msg = _t3.message;
              } else if (typeof _t3 === "string") {
                msg = _t3;
              }
              fields = {
                error: msg,
                sdp: sd.sdp
              };
              if (!remote && this.pc.remoteDescription) {
                fields.remoteSdp = this.pc.remoteDescription;
              }
              this.log.error("unable to set ".concat(sd.type), Object.assign(Object.assign({}, this.logContext), {
                fields
              }));
              throw new NegotiationError(msg);
            case 11:
              return _context7.a(2);
          }
        }, _callee7, this, [[6, 10], [1, 5]]);
      }));
    }
  }, {
    key: "ensureVideoDDExtensionForSVC",
    value: function ensureVideoDDExtensionForSVC(media, sdp2) {
      var _a, _b;
      var ddFound = (_a = media.ext) === null || _a === void 0 ? void 0 : _a.some(function(ext) {
        if (ext.uri === ddExtensionURI) {
          return true;
        }
        return false;
      });
      if (!ddFound) {
        if (this.ddExtID === 0) {
          var maxID = 0;
          sdp2.media.forEach(function(m) {
            var _a2;
            if (m.type !== "video") {
              return;
            }
            (_a2 = m.ext) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(ext) {
              if (ext.value > maxID) {
                maxID = ext.value;
              }
            });
          });
          this.ddExtID = maxID + 1;
        }
        (_b = media.ext) === null || _b === void 0 ? void 0 : _b.push({
          value: this.ddExtID,
          uri: ddExtensionURI
        });
      }
    }
  }]);
}(eventsExports.EventEmitter);
function ensureAudioNackAndStereo(media, stereoMids, nackMids) {
  var opusPayload = 0;
  media.rtp.some(function(rtp) {
    if (rtp.codec === "opus") {
      opusPayload = rtp.payload;
      return true;
    }
    return false;
  });
  if (opusPayload > 0) {
    if (!media.rtcpFb) {
      media.rtcpFb = [];
    }
    if (nackMids.includes(media.mid) && !media.rtcpFb.some(function(fb) {
      return fb.payload === opusPayload && fb.type === "nack";
    })) {
      media.rtcpFb.push({
        payload: opusPayload,
        type: "nack"
      });
    }
    if (stereoMids.includes(media.mid)) {
      media.fmtp.some(function(fmtp) {
        if (fmtp.payload === opusPayload) {
          if (!fmtp.config.includes("stereo=1")) {
            fmtp.config += ";stereo=1";
          }
          return true;
        }
        return false;
      });
    }
  }
}
function extractStereoAndNackAudioFromOffer(offer) {
  var _a;
  var stereoMids = [];
  var nackMids = [];
  var sdpParsed = parse((_a = offer.sdp) !== null && _a !== void 0 ? _a : "");
  var opusPayload = 0;
  sdpParsed.media.forEach(function(media) {
    var _a2;
    if (media.type === "audio") {
      media.rtp.some(function(rtp) {
        if (rtp.codec === "opus") {
          opusPayload = rtp.payload;
          return true;
        }
        return false;
      });
      if ((_a2 = media.rtcpFb) === null || _a2 === void 0 ? void 0 : _a2.some(function(fb) {
        return fb.payload === opusPayload && fb.type === "nack";
      })) {
        nackMids.push(media.mid);
      }
      media.fmtp.some(function(fmtp) {
        if (fmtp.payload === opusPayload) {
          if (fmtp.config.includes("sprop-stereo=1")) {
            stereoMids.push(media.mid);
          }
          return true;
        }
        return false;
      });
    }
  });
  return {
    stereoMids,
    nackMids
  };
}
function ensureIPAddrMatchVersion(media) {
  if (media.connection) {
    var isV6 = media.connection.ip.indexOf(":") >= 0;
    if (media.connection.version === 4 && isV6 || media.connection.version === 6 && !isV6) {
      media.connection.ip = "0.0.0.0";
      media.connection.version = 4;
    }
  }
}
var defaultVideoCodec = "vp8";
var publishDefaults = {
  audioPreset: AudioPresets.music,
  dtx: true,
  red: true,
  forceStereo: false,
  simulcast: true,
  screenShareEncoding: ScreenSharePresets.h1080fps15.encoding,
  stopMicTrackOnMute: false,
  videoCodec: defaultVideoCodec,
  backupCodec: true
};
var audioDefaults = {
  deviceId: "default",
  autoGainControl: true,
  echoCancellation: true,
  noiseSuppression: true,
  voiceIsolation: true
};
var videoDefaults = {
  deviceId: "default",
  resolution: VideoPresets.h720.resolution
};
var roomOptionDefaults = {
  adaptiveStream: false,
  dynacast: false,
  stopLocalTrackOnUnpublish: true,
  reconnectPolicy: new DefaultReconnectPolicy(),
  disconnectOnPageLeave: true,
  webAudioMix: false
};
var roomConnectOptionDefaults = {
  autoSubscribe: true,
  maxRetries: 1,
  peerConnectionTimeout: 15e3,
  websocketTimeout: 15e3
};
var PCTransportState;
(function(PCTransportState2) {
  PCTransportState2[PCTransportState2["NEW"] = 0] = "NEW";
  PCTransportState2[PCTransportState2["CONNECTING"] = 1] = "CONNECTING";
  PCTransportState2[PCTransportState2["CONNECTED"] = 2] = "CONNECTED";
  PCTransportState2[PCTransportState2["FAILED"] = 3] = "FAILED";
  PCTransportState2[PCTransportState2["CLOSING"] = 4] = "CLOSING";
  PCTransportState2[PCTransportState2["CLOSED"] = 5] = "CLOSED";
})(PCTransportState || (PCTransportState = {}));
var PCTransportManager = function() {
  function PCTransportManager2(rtcConfig, subscriberPrimary, loggerOptions) {
    var _this = this;
    _classCallCheck(this, PCTransportManager2);
    var _a;
    this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout;
    this.log = livekitLogger;
    this.updateState = function() {
      var _a2;
      var previousState = _this.state;
      var connectionStates = _this.requiredTransports.map(function(tr) {
        return tr.getConnectionState();
      });
      if (connectionStates.every(function(st) {
        return st === "connected";
      })) {
        _this.state = PCTransportState.CONNECTED;
      } else if (connectionStates.some(function(st) {
        return st === "failed";
      })) {
        _this.state = PCTransportState.FAILED;
      } else if (connectionStates.some(function(st) {
        return st === "connecting";
      })) {
        _this.state = PCTransportState.CONNECTING;
      } else if (connectionStates.every(function(st) {
        return st === "closed";
      })) {
        _this.state = PCTransportState.CLOSED;
      } else if (connectionStates.some(function(st) {
        return st === "closed";
      })) {
        _this.state = PCTransportState.CLOSING;
      } else if (connectionStates.every(function(st) {
        return st === "new";
      })) {
        _this.state = PCTransportState.NEW;
      }
      if (previousState !== _this.state) {
        _this.log.debug("pc state change: from ".concat(PCTransportState[previousState], " to ").concat(PCTransportState[_this.state]), _this.logContext);
        (_a2 = _this.onStateChange) === null || _a2 === void 0 ? void 0 : _a2.call(_this, _this.state, _this.publisher.getConnectionState(), _this.subscriber.getConnectionState());
      }
    };
    this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.PCManager);
    this.loggerOptions = loggerOptions;
    this.isPublisherConnectionRequired = !subscriberPrimary;
    this.isSubscriberConnectionRequired = subscriberPrimary;
    this.publisher = new PCTransport(rtcConfig, loggerOptions);
    this.subscriber = new PCTransport(rtcConfig, loggerOptions);
    this.publisher.onConnectionStateChange = this.updateState;
    this.subscriber.onConnectionStateChange = this.updateState;
    this.publisher.onIceConnectionStateChange = this.updateState;
    this.subscriber.onIceConnectionStateChange = this.updateState;
    this.publisher.onSignalingStatechange = this.updateState;
    this.subscriber.onSignalingStatechange = this.updateState;
    this.publisher.onIceCandidate = function(candidate) {
      var _a2;
      (_a2 = _this.onIceCandidate) === null || _a2 === void 0 ? void 0 : _a2.call(_this, candidate, SignalTarget.PUBLISHER);
    };
    this.subscriber.onIceCandidate = function(candidate) {
      var _a2;
      (_a2 = _this.onIceCandidate) === null || _a2 === void 0 ? void 0 : _a2.call(_this, candidate, SignalTarget.SUBSCRIBER);
    };
    this.subscriber.onDataChannel = function(ev) {
      var _a2;
      (_a2 = _this.onDataChannel) === null || _a2 === void 0 ? void 0 : _a2.call(_this, ev);
    };
    this.subscriber.onTrack = function(ev) {
      var _a2;
      (_a2 = _this.onTrack) === null || _a2 === void 0 ? void 0 : _a2.call(_this, ev);
    };
    this.publisher.onOffer = function(offer) {
      var _a2;
      (_a2 = _this.onPublisherOffer) === null || _a2 === void 0 ? void 0 : _a2.call(_this, offer);
    };
    this.state = PCTransportState.NEW;
    this.connectionLock = new Mutex();
    this.remoteOfferLock = new Mutex();
  }
  return _createClass(PCTransportManager2, [{
    key: "needsPublisher",
    get: function get2() {
      return this.isPublisherConnectionRequired;
    }
  }, {
    key: "needsSubscriber",
    get: function get2() {
      return this.isSubscriberConnectionRequired;
    }
  }, {
    key: "currentState",
    get: function get2() {
      return this.state;
    }
  }, {
    key: "logContext",
    get: function get2() {
      var _a, _b;
      return Object.assign({}, (_b = (_a = this.loggerOptions).loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));
    }
  }, {
    key: "requirePublisher",
    value: function requirePublisher() {
      var require2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      this.isPublisherConnectionRequired = require2;
      this.updateState();
    }
  }, {
    key: "requireSubscriber",
    value: function requireSubscriber() {
      var require2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      this.isSubscriberConnectionRequired = require2;
      this.updateState();
    }
  }, {
    key: "createAndSendPublisherOffer",
    value: function createAndSendPublisherOffer(options) {
      return this.publisher.createAndSendOffer(options);
    }
  }, {
    key: "setPublisherAnswer",
    value: function setPublisherAnswer(sd) {
      return this.publisher.setRemoteDescription(sd);
    }
  }, {
    key: "removeTrack",
    value: function removeTrack(sender) {
      return this.publisher.removeTrack(sender);
    }
  }, {
    key: "close",
    value: function close() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee() {
        var publisher, _iterator, _step, sender;
        return _regenerator().w(function(_context) {
          while (1) switch (_context.n) {
            case 0:
              if (this.publisher && this.publisher.getSignallingState() !== "closed") {
                publisher = this.publisher;
                _iterator = _createForOfIteratorHelper(publisher.getSenders());
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                    sender = _step.value;
                    try {
                      if (publisher.canRemoveTrack()) {
                        publisher.removeTrack(sender);
                      }
                    } catch (e) {
                      this.log.warn("could not removeTrack", Object.assign(Object.assign({}, this.logContext), {
                        error: e
                      }));
                    }
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
              }
              _context.n = 1;
              return Promise.all([this.publisher.close(), this.subscriber.close()]);
            case 1:
              this.updateState();
            case 2:
              return _context.a(2);
          }
        }, _callee, this);
      }));
    }
  }, {
    key: "triggerIceRestart",
    value: function triggerIceRestart() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee2() {
        return _regenerator().w(function(_context2) {
          while (1) switch (_context2.n) {
            case 0:
              this.subscriber.restartingIce = true;
              if (!this.needsPublisher) {
                _context2.n = 1;
                break;
              }
              _context2.n = 1;
              return this.createAndSendPublisherOffer({
                iceRestart: true
              });
            case 1:
              return _context2.a(2);
          }
        }, _callee2, this);
      }));
    }
  }, {
    key: "addIceCandidate",
    value: function addIceCandidate(candidate, target) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee3() {
        return _regenerator().w(function(_context3) {
          while (1) switch (_context3.n) {
            case 0:
              if (!(target === SignalTarget.PUBLISHER)) {
                _context3.n = 2;
                break;
              }
              _context3.n = 1;
              return this.publisher.addIceCandidate(candidate);
            case 1:
              _context3.n = 3;
              break;
            case 2:
              _context3.n = 3;
              return this.subscriber.addIceCandidate(candidate);
            case 3:
              return _context3.a(2);
          }
        }, _callee3, this);
      }));
    }
  }, {
    key: "createSubscriberAnswerFromOffer",
    value: function createSubscriberAnswerFromOffer(sd) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee4() {
        var unlock, answer;
        return _regenerator().w(function(_context4) {
          while (1) switch (_context4.n) {
            case 0:
              this.log.debug("received server offer", Object.assign(Object.assign({}, this.logContext), {
                RTCSdpType: sd.type,
                sdp: sd.sdp,
                signalingState: this.subscriber.getSignallingState().toString()
              }));
              _context4.n = 1;
              return this.remoteOfferLock.lock();
            case 1:
              unlock = _context4.v;
              _context4.p = 2;
              _context4.n = 3;
              return this.subscriber.setRemoteDescription(sd);
            case 3:
              _context4.n = 4;
              return this.subscriber.createAndSetAnswer();
            case 4:
              answer = _context4.v;
              return _context4.a(2, answer);
            case 5:
              _context4.p = 5;
              unlock();
              return _context4.f(5);
            case 6:
              return _context4.a(2);
          }
        }, _callee4, this, [[2, , 5, 6]]);
      }));
    }
  }, {
    key: "updateConfiguration",
    value: function updateConfiguration(config, iceRestart) {
      this.publisher.setConfiguration(config);
      this.subscriber.setConfiguration(config);
      if (iceRestart) {
        this.triggerIceRestart();
      }
    }
  }, {
    key: "ensurePCTransportConnection",
    value: function ensurePCTransportConnection(abortController, timeout) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee5() {
        var _this2 = this;
        var _a, unlock;
        return _regenerator().w(function(_context5) {
          while (1) switch (_context5.n) {
            case 0:
              _context5.n = 1;
              return this.connectionLock.lock();
            case 1:
              unlock = _context5.v;
              _context5.p = 2;
              if (this.isPublisherConnectionRequired && this.publisher.getConnectionState() !== "connected" && this.publisher.getConnectionState() !== "connecting") {
                this.log.debug("negotiation required, start negotiating", this.logContext);
                this.publisher.negotiate();
              }
              _context5.n = 3;
              return Promise.all((_a = this.requiredTransports) === null || _a === void 0 ? void 0 : _a.map(function(transport) {
                return _this2.ensureTransportConnected(transport, abortController, timeout);
              }));
            case 3:
              _context5.p = 3;
              unlock();
              return _context5.f(3);
            case 4:
              return _context5.a(2);
          }
        }, _callee5, this, [[2, , 3, 4]]);
      }));
    }
  }, {
    key: "negotiate",
    value: function negotiate(abortController) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee7() {
        var _this3 = this;
        return _regenerator().w(function(_context7) {
          while (1) switch (_context7.n) {
            case 0:
              return _context7.a(2, new Promise(function(resolve, reject) {
                return __awaiter(_this3, void 0, void 0, _regenerator().m(function _callee6() {
                  var _this4 = this;
                  var negotiationTimeout, abortHandler;
                  return _regenerator().w(function(_context6) {
                    while (1) switch (_context6.n) {
                      case 0:
                        negotiationTimeout = setTimeout(function() {
                          reject("negotiation timed out");
                        }, this.peerConnectionTimeout);
                        abortHandler = function abortHandler2() {
                          clearTimeout(negotiationTimeout);
                          reject("negotiation aborted");
                        };
                        abortController.signal.addEventListener("abort", abortHandler);
                        this.publisher.once(PCEvents.NegotiationStarted, function() {
                          if (abortController.signal.aborted) {
                            return;
                          }
                          _this4.publisher.once(PCEvents.NegotiationComplete, function() {
                            clearTimeout(negotiationTimeout);
                            resolve();
                          });
                        });
                        _context6.n = 1;
                        return this.publisher.negotiate(function(e) {
                          clearTimeout(negotiationTimeout);
                          reject(e);
                        });
                      case 1:
                        return _context6.a(2);
                    }
                  }, _callee6, this);
                }));
              }));
          }
        }, _callee7);
      }));
    }
  }, {
    key: "addPublisherTransceiver",
    value: function addPublisherTransceiver(track, transceiverInit) {
      return this.publisher.addTransceiver(track, transceiverInit);
    }
  }, {
    key: "addPublisherTrack",
    value: function addPublisherTrack(track) {
      return this.publisher.addTrack(track);
    }
  }, {
    key: "createPublisherDataChannel",
    value: function createPublisherDataChannel(label, dataChannelDict) {
      return this.publisher.createDataChannel(label, dataChannelDict);
    }
    /**
     * Returns the first required transport's address if no explicit target is specified
     */
  }, {
    key: "getConnectedAddress",
    value: function getConnectedAddress(target) {
      if (target === SignalTarget.PUBLISHER) {
        return this.publisher.getConnectedAddress();
      } else if (target === SignalTarget.SUBSCRIBER) {
        return this.publisher.getConnectedAddress();
      }
      return this.requiredTransports[0].getConnectedAddress();
    }
  }, {
    key: "requiredTransports",
    get: function get2() {
      var transports = [];
      if (this.isPublisherConnectionRequired) {
        transports.push(this.publisher);
      }
      if (this.isSubscriberConnectionRequired) {
        transports.push(this.subscriber);
      }
      return transports;
    }
  }, {
    key: "ensureTransportConnected",
    value: function ensureTransportConnected(pcTransport_1, abortController_1) {
      return __awaiter(this, arguments, void 0, function(pcTransport, abortController) {
        var _this5 = this;
        var timeout = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.peerConnectionTimeout;
        return _regenerator().m(function _callee9() {
          var connectionState;
          return _regenerator().w(function(_context9) {
            while (1) switch (_context9.n) {
              case 0:
                connectionState = pcTransport.getConnectionState();
                if (!(connectionState === "connected")) {
                  _context9.n = 1;
                  break;
                }
                return _context9.a(2);
              case 1:
                return _context9.a(2, new Promise(function(resolve, reject) {
                  return __awaiter(_this5, void 0, void 0, _regenerator().m(function _callee8() {
                    var _this6 = this;
                    var abortHandler, connectTimeout;
                    return _regenerator().w(function(_context8) {
                      while (1) switch (_context8.n) {
                        case 0:
                          abortHandler = function abortHandler2() {
                            _this6.log.warn("abort transport connection", _this6.logContext);
                            CriticalTimers.clearTimeout(connectTimeout);
                            reject(new ConnectionError(
                              "room connection has been cancelled",
                              3
                              /* ConnectionErrorReason.Cancelled */
                            ));
                          };
                          if (abortController === null || abortController === void 0 ? void 0 : abortController.signal.aborted) {
                            abortHandler();
                          }
                          abortController === null || abortController === void 0 ? void 0 : abortController.signal.addEventListener("abort", abortHandler);
                          connectTimeout = CriticalTimers.setTimeout(function() {
                            abortController === null || abortController === void 0 ? void 0 : abortController.signal.removeEventListener("abort", abortHandler);
                            reject(new ConnectionError(
                              "could not establish pc connection",
                              2
                              /* ConnectionErrorReason.InternalError */
                            ));
                          }, timeout);
                        case 1:
                          if (!(this.state !== PCTransportState.CONNECTED)) {
                            _context8.n = 4;
                            break;
                          }
                          _context8.n = 2;
                          return sleep(50);
                        case 2:
                          if (!(abortController === null || abortController === void 0 ? void 0 : abortController.signal.aborted)) {
                            _context8.n = 3;
                            break;
                          }
                          reject(new ConnectionError(
                            "room connection has been cancelled",
                            3
                            /* ConnectionErrorReason.Cancelled */
                          ));
                          return _context8.a(2);
                        case 3:
                          _context8.n = 1;
                          break;
                        case 4:
                          CriticalTimers.clearTimeout(connectTimeout);
                          abortController === null || abortController === void 0 ? void 0 : abortController.signal.removeEventListener("abort", abortHandler);
                          resolve();
                        case 5:
                          return _context8.a(2);
                      }
                    }, _callee8, this);
                  }));
                }));
            }
          }, _callee9);
        })();
      });
    }
  }]);
}();
var monitorFrequency = 2e3;
function computeBitrate(currentStats, prevStats) {
  if (!prevStats) {
    return 0;
  }
  var bytesNow;
  var bytesPrev;
  if ("bytesReceived" in currentStats) {
    bytesNow = currentStats.bytesReceived;
    bytesPrev = prevStats.bytesReceived;
  } else if ("bytesSent" in currentStats) {
    bytesNow = currentStats.bytesSent;
    bytesPrev = prevStats.bytesSent;
  }
  if (bytesNow === void 0 || bytesPrev === void 0 || currentStats.timestamp === void 0 || prevStats.timestamp === void 0) {
    return 0;
  }
  return (bytesNow - bytesPrev) * 8 * 1e3 / (currentStats.timestamp - prevStats.timestamp);
}
var LocalAudioTrack = function(_LocalTrack) {
  function LocalAudioTrack2(mediaTrack, constraints) {
    var _this;
    var userProvidedTrack = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    var audioContext = arguments.length > 3 ? arguments[3] : void 0;
    var loggerOptions = arguments.length > 4 ? arguments[4] : void 0;
    _classCallCheck(this, LocalAudioTrack2);
    _this = _callSuper(this, LocalAudioTrack2, [mediaTrack, Track.Kind.Audio, constraints, userProvidedTrack, loggerOptions]);
    _this.stopOnMute = false;
    _this.isKrispNoiseFilterEnabled = false;
    _this.monitorSender = function() {
      return __awaiter(_this, void 0, void 0, _regenerator().m(function _callee() {
        var stats, _t;
        return _regenerator().w(function(_context) {
          while (1) switch (_context.n) {
            case 0:
              if (this.sender) {
                _context.n = 1;
                break;
              }
              this._currentBitrate = 0;
              return _context.a(2);
            case 1:
              _context.p = 1;
              _context.n = 2;
              return this.getSenderStats();
            case 2:
              stats = _context.v;
              _context.n = 4;
              break;
            case 3:
              _context.p = 3;
              _t = _context.v;
              this.log.error("could not get audio sender stats", Object.assign(Object.assign({}, this.logContext), {
                error: _t
              }));
              return _context.a(2);
            case 4:
              if (stats && this.prevStats) {
                this._currentBitrate = computeBitrate(stats, this.prevStats);
              }
              this.prevStats = stats;
            case 5:
              return _context.a(2);
          }
        }, _callee, this, [[1, 3]]);
      }));
    };
    _this.handleKrispNoiseFilterEnable = function() {
      _this.isKrispNoiseFilterEnabled = true;
      _this.log.debug("Krisp noise filter enabled", _this.logContext);
      _this.emit(TrackEvent.AudioTrackFeatureUpdate, _this, AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION, true);
    };
    _this.handleKrispNoiseFilterDisable = function() {
      _this.isKrispNoiseFilterEnabled = false;
      _this.log.debug("Krisp noise filter disabled", _this.logContext);
      _this.emit(TrackEvent.AudioTrackFeatureUpdate, _this, AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION, false);
    };
    _this.audioContext = audioContext;
    _this.checkForSilence();
    return _this;
  }
  _inherits(LocalAudioTrack2, _LocalTrack);
  return _createClass(LocalAudioTrack2, [{
    key: "enhancedNoiseCancellation",
    get: (
      /**
       * boolean indicating whether enhanced noise cancellation is currently being used on this track
       */
      function get2() {
        return this.isKrispNoiseFilterEnabled;
      }
    )
  }, {
    key: "mute",
    value: function mute() {
      var _this2 = this;
      var _super = Object.create(null, {
        mute: {
          get: function get2() {
            return _superPropGet(LocalAudioTrack2, "mute", _this2, 1);
          }
        }
      });
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee2() {
        var unlock;
        return _regenerator().w(function(_context2) {
          while (1) switch (_context2.n) {
            case 0:
              _context2.n = 1;
              return this.muteLock.lock();
            case 1:
              unlock = _context2.v;
              _context2.p = 2;
              if (!this.isMuted) {
                _context2.n = 3;
                break;
              }
              this.log.debug("Track already muted", this.logContext);
              return _context2.a(2, this);
            case 3:
              if (this.source === Track.Source.Microphone && this.stopOnMute && !this.isUserProvided) {
                this.log.debug("stopping mic track", this.logContext);
                this._mediaStreamTrack.stop();
              }
              _context2.n = 4;
              return _super.mute.call(this);
            case 4:
              return _context2.a(2, this);
            case 5:
              _context2.p = 5;
              unlock();
              return _context2.f(5);
            case 6:
              return _context2.a(2);
          }
        }, _callee2, this, [[2, , 5, 6]]);
      }));
    }
  }, {
    key: "unmute",
    value: function unmute() {
      var _this3 = this;
      var _super = Object.create(null, {
        unmute: {
          get: function get2() {
            return _superPropGet(LocalAudioTrack2, "unmute", _this3, 1);
          }
        }
      });
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee3() {
        var unlock, deviceHasChanged;
        return _regenerator().w(function(_context3) {
          while (1) switch (_context3.n) {
            case 0:
              _context3.n = 1;
              return this.muteLock.lock();
            case 1:
              unlock = _context3.v;
              _context3.p = 2;
              if (this.isMuted) {
                _context3.n = 3;
                break;
              }
              this.log.debug("Track already unmuted", this.logContext);
              return _context3.a(2, this);
            case 3:
              deviceHasChanged = this._constraints.deviceId && this._mediaStreamTrack.getSettings().deviceId !== unwrapConstraint(this._constraints.deviceId);
              if (!(this.source === Track.Source.Microphone && (this.stopOnMute || this._mediaStreamTrack.readyState === "ended" || deviceHasChanged) && !this.isUserProvided)) {
                _context3.n = 4;
                break;
              }
              this.log.debug("reacquiring mic track", this.logContext);
              _context3.n = 4;
              return this.restartTrack();
            case 4:
              _context3.n = 5;
              return _super.unmute.call(this);
            case 5:
              return _context3.a(2, this);
            case 6:
              _context3.p = 6;
              unlock();
              return _context3.f(6);
            case 7:
              return _context3.a(2);
          }
        }, _callee3, this, [[2, , 6, 7]]);
      }));
    }
  }, {
    key: "restartTrack",
    value: function restartTrack(options) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee4() {
        var constraints, streamConstraints;
        return _regenerator().w(function(_context4) {
          while (1) switch (_context4.n) {
            case 0:
              if (options) {
                streamConstraints = constraintsForOptions({
                  audio: options
                });
                if (typeof streamConstraints.audio !== "boolean") {
                  constraints = streamConstraints.audio;
                }
              }
              _context4.n = 1;
              return this.restart(constraints);
            case 1:
              return _context4.a(2);
          }
        }, _callee4, this);
      }));
    }
  }, {
    key: "restart",
    value: function restart(constraints) {
      var _this4 = this;
      var _super = Object.create(null, {
        restart: {
          get: function get2() {
            return _superPropGet(LocalAudioTrack2, "restart", _this4, 1);
          }
        }
      });
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee5() {
        var track;
        return _regenerator().w(function(_context5) {
          while (1) switch (_context5.n) {
            case 0:
              _context5.n = 1;
              return _super.restart.call(this, constraints);
            case 1:
              track = _context5.v;
              this.checkForSilence();
              return _context5.a(2, track);
          }
        }, _callee5, this);
      }));
    }
    /* @internal */
  }, {
    key: "startMonitor",
    value: function startMonitor() {
      var _this5 = this;
      if (!isWeb()) {
        return;
      }
      if (this.monitorInterval) {
        return;
      }
      this.monitorInterval = setInterval(function() {
        _this5.monitorSender();
      }, monitorFrequency);
    }
  }, {
    key: "setProcessor",
    value: function setProcessor(processor) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee6() {
        var _a, unlock, processorOptions;
        return _regenerator().w(function(_context6) {
          while (1) switch (_context6.n) {
            case 0:
              _context6.n = 1;
              return this.processorLock.lock();
            case 1:
              unlock = _context6.v;
              _context6.p = 2;
              if (this.audioContext) {
                _context6.n = 3;
                break;
              }
              throw Error("Audio context needs to be set on LocalAudioTrack in order to enable processors");
            case 3:
              if (!this.processor) {
                _context6.n = 4;
                break;
              }
              _context6.n = 4;
              return this.stopProcessor();
            case 4:
              processorOptions = {
                kind: this.kind,
                track: this._mediaStreamTrack,
                audioContext: this.audioContext
              };
              this.log.debug("setting up audio processor ".concat(processor.name), this.logContext);
              _context6.n = 5;
              return processor.init(processorOptions);
            case 5:
              this.processor = processor;
              if (!this.processor.processedTrack) {
                _context6.n = 7;
                break;
              }
              _context6.n = 6;
              return (_a = this.sender) === null || _a === void 0 ? void 0 : _a.replaceTrack(this.processor.processedTrack);
            case 6:
              this.processor.processedTrack.addEventListener("enable-lk-krisp-noise-filter", this.handleKrispNoiseFilterEnable);
              this.processor.processedTrack.addEventListener("disable-lk-krisp-noise-filter", this.handleKrispNoiseFilterDisable);
            case 7:
              this.emit(TrackEvent.TrackProcessorUpdate, this.processor);
            case 8:
              _context6.p = 8;
              unlock();
              return _context6.f(8);
            case 9:
              return _context6.a(2);
          }
        }, _callee6, this, [[2, , 8, 9]]);
      }));
    }
    /**
     * @internal
     * @experimental
     */
  }, {
    key: "setAudioContext",
    value: function setAudioContext(audioContext) {
      this.audioContext = audioContext;
    }
  }, {
    key: "getSenderStats",
    value: function getSenderStats() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee7() {
        var _a, stats, audioStats;
        return _regenerator().w(function(_context7) {
          while (1) switch (_context7.n) {
            case 0:
              if ((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats) {
                _context7.n = 1;
                break;
              }
              return _context7.a(2, void 0);
            case 1:
              _context7.n = 2;
              return this.sender.getStats();
            case 2:
              stats = _context7.v;
              stats.forEach(function(v) {
                if (v.type === "outbound-rtp") {
                  audioStats = {
                    type: "audio",
                    streamId: v.id,
                    packetsSent: v.packetsSent,
                    packetsLost: v.packetsLost,
                    bytesSent: v.bytesSent,
                    timestamp: v.timestamp,
                    roundTripTime: v.roundTripTime,
                    jitter: v.jitter
                  };
                }
              });
              return _context7.a(2, audioStats);
          }
        }, _callee7, this);
      }));
    }
  }, {
    key: "checkForSilence",
    value: function checkForSilence() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee8() {
        var trackIsSilent;
        return _regenerator().w(function(_context8) {
          while (1) switch (_context8.n) {
            case 0:
              _context8.n = 1;
              return detectSilence(this);
            case 1:
              trackIsSilent = _context8.v;
              if (trackIsSilent) {
                if (!this.isMuted) {
                  this.log.warn("silence detected on local audio track", this.logContext);
                }
                this.emit(TrackEvent.AudioSilenceDetected);
              }
              return _context8.a(2, trackIsSilent);
          }
        }, _callee8, this);
      }));
    }
  }]);
}(LocalTrack);
function mediaTrackToLocalTrack(mediaStreamTrack, constraints, loggerOptions) {
  switch (mediaStreamTrack.kind) {
    case "audio":
      return new LocalAudioTrack(mediaStreamTrack, constraints, false, void 0, loggerOptions);
    case "video":
      return new LocalVideoTrack(mediaStreamTrack, constraints, false, loggerOptions);
    default:
      throw new TrackInvalidError("unsupported track type: ".concat(mediaStreamTrack.kind));
  }
}
var presets169 = Object.values(VideoPresets);
var presets43 = Object.values(VideoPresets43);
var presetsScreenShare = Object.values(ScreenSharePresets);
var defaultSimulcastPresets169 = [VideoPresets.h540, VideoPresets.h720];
var defaultSimulcastPresets43 = [VideoPresets43.h540, VideoPresets43.h720];
var computeDefaultScreenShareSimulcastPresets = function computeDefaultScreenShareSimulcastPresets2(fromPreset) {
  var layers = [{
    scaleResolutionDownBy: 2,
    fps: fromPreset.encoding.maxFramerate
  }];
  return layers.map(function(t) {
    var _a, _b;
    return new VideoPreset(Math.floor(fromPreset.width / t.scaleResolutionDownBy), Math.floor(fromPreset.height / t.scaleResolutionDownBy), Math.max(15e4, Math.floor(fromPreset.encoding.maxBitrate / (Math.pow(t.scaleResolutionDownBy, 2) * (((_a = fromPreset.encoding.maxFramerate) !== null && _a !== void 0 ? _a : 30) / ((_b = t.fps) !== null && _b !== void 0 ? _b : 30))))), t.fps, fromPreset.encoding.priority);
  });
};
var videoRids = ["q", "h", "f"];
function computeVideoEncodings(isScreenShare, width, height, options) {
  var _a, _b;
  var videoEncoding = options === null || options === void 0 ? void 0 : options.videoEncoding;
  if (isScreenShare) {
    videoEncoding = options === null || options === void 0 ? void 0 : options.screenShareEncoding;
  }
  var useSimulcast = options === null || options === void 0 ? void 0 : options.simulcast;
  var scalabilityMode = options === null || options === void 0 ? void 0 : options.scalabilityMode;
  var videoCodec = options === null || options === void 0 ? void 0 : options.videoCodec;
  if (!videoEncoding && !useSimulcast && !scalabilityMode || !width || !height) {
    return [{}];
  }
  if (!videoEncoding) {
    videoEncoding = determineAppropriateEncoding(isScreenShare, width, height, videoCodec);
    livekitLogger.debug("using video encoding", videoEncoding);
  }
  var sourceFramerate = videoEncoding.maxFramerate;
  var original = new VideoPreset(width, height, videoEncoding.maxBitrate, videoEncoding.maxFramerate, videoEncoding.priority);
  if (scalabilityMode && isSVCCodec(videoCodec)) {
    var sm = new ScalabilityMode(scalabilityMode);
    var encodings = [];
    if (sm.spatial > 3) {
      throw new Error("unsupported scalabilityMode: ".concat(scalabilityMode));
    }
    var browser = getBrowser();
    if (isSafari() || // Even tho RN runs M114, it does not produce SVC layers when a single encoding
    // is provided. So we'll use the legacy SVC specification for now.
    // TODO: when we upstream libwebrtc, this will need additional verification
    isReactNative() || (browser === null || browser === void 0 ? void 0 : browser.name) === "Chrome" && compareVersions(browser === null || browser === void 0 ? void 0 : browser.version, "113") < 0) {
      var bitratesRatio = sm.suffix == "h" ? 2 : 3;
      for (var i = 0; i < sm.spatial; i += 1) {
        encodings.push({
          rid: videoRids[2 - i],
          maxBitrate: videoEncoding.maxBitrate / Math.pow(bitratesRatio, i),
          maxFramerate: original.encoding.maxFramerate
        });
      }
      encodings[0].scalabilityMode = scalabilityMode;
    } else {
      encodings.push({
        maxBitrate: videoEncoding.maxBitrate,
        maxFramerate: original.encoding.maxFramerate,
        /* @ts-ignore */
        scalabilityMode
      });
    }
    if (original.encoding.priority) {
      encodings[0].priority = original.encoding.priority;
      encodings[0].networkPriority = original.encoding.priority;
    }
    livekitLogger.debug("using svc encoding", {
      encodings
    });
    return encodings;
  }
  if (!useSimulcast) {
    return [videoEncoding];
  }
  var presets = [];
  if (isScreenShare) {
    presets = (_a = sortPresets(options === null || options === void 0 ? void 0 : options.screenShareSimulcastLayers)) !== null && _a !== void 0 ? _a : defaultSimulcastLayers(isScreenShare, original);
  } else {
    presets = (_b = sortPresets(options === null || options === void 0 ? void 0 : options.videoSimulcastLayers)) !== null && _b !== void 0 ? _b : defaultSimulcastLayers(isScreenShare, original);
  }
  var midPreset;
  if (presets.length > 0) {
    var lowPreset = presets[0];
    if (presets.length > 1) {
      var _presets = presets;
      var _presets2 = _slicedToArray(_presets, 2);
      midPreset = _presets2[1];
    }
    var size = Math.max(width, height);
    if (size >= 960 && midPreset) {
      return encodingsFromPresets(width, height, [lowPreset, midPreset, original], sourceFramerate);
    }
    if (size >= 480) {
      return encodingsFromPresets(width, height, [lowPreset, original], sourceFramerate);
    }
  }
  return encodingsFromPresets(width, height, [original]);
}
function computeTrackBackupEncodings(track, videoCodec, opts) {
  var _a, _b, _c, _d;
  if (!opts.backupCodec || opts.backupCodec === true || opts.backupCodec.codec === opts.videoCodec) {
    return;
  }
  if (videoCodec !== opts.backupCodec.codec) {
    livekitLogger.warn("requested a different codec than specified as backup", {
      serverRequested: videoCodec,
      backup: opts.backupCodec.codec
    });
  }
  opts.videoCodec = videoCodec;
  opts.videoEncoding = opts.backupCodec.encoding;
  var settings = track.mediaStreamTrack.getSettings();
  var width = (_a = settings.width) !== null && _a !== void 0 ? _a : (_b = track.dimensions) === null || _b === void 0 ? void 0 : _b.width;
  var height = (_c = settings.height) !== null && _c !== void 0 ? _c : (_d = track.dimensions) === null || _d === void 0 ? void 0 : _d.height;
  var encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, width, height, opts);
  return encodings;
}
function determineAppropriateEncoding(isScreenShare, width, height, codec) {
  var presets = presetsForResolution(isScreenShare, width, height);
  var encoding = presets[0].encoding;
  var size = Math.max(width, height);
  for (var i = 0; i < presets.length; i += 1) {
    var preset = presets[i];
    encoding = preset.encoding;
    if (preset.width >= size) {
      break;
    }
  }
  if (codec) {
    switch (codec) {
      case "av1":
        encoding = Object.assign({}, encoding);
        encoding.maxBitrate = encoding.maxBitrate * 0.7;
        break;
      case "vp9":
        encoding = Object.assign({}, encoding);
        encoding.maxBitrate = encoding.maxBitrate * 0.85;
        break;
    }
  }
  return encoding;
}
function presetsForResolution(isScreenShare, width, height) {
  if (isScreenShare) {
    return presetsScreenShare;
  }
  var aspect = width > height ? width / height : height / width;
  if (Math.abs(aspect - 16 / 9) < Math.abs(aspect - 4 / 3)) {
    return presets169;
  }
  return presets43;
}
function defaultSimulcastLayers(isScreenShare, original) {
  if (isScreenShare) {
    return computeDefaultScreenShareSimulcastPresets(original);
  }
  var width = original.width, height = original.height;
  var aspect = width > height ? width / height : height / width;
  if (Math.abs(aspect - 16 / 9) < Math.abs(aspect - 4 / 3)) {
    return defaultSimulcastPresets169;
  }
  return defaultSimulcastPresets43;
}
function encodingsFromPresets(width, height, presets, sourceFramerate) {
  var encodings = [];
  presets.forEach(function(preset, idx) {
    if (idx >= videoRids.length) {
      return;
    }
    var size = Math.min(width, height);
    var rid = videoRids[idx];
    var encoding = {
      rid,
      scaleResolutionDownBy: Math.max(1, size / Math.min(preset.width, preset.height)),
      maxBitrate: preset.encoding.maxBitrate
    };
    var maxFramerate = sourceFramerate && preset.encoding.maxFramerate ? Math.min(sourceFramerate, preset.encoding.maxFramerate) : preset.encoding.maxFramerate;
    if (maxFramerate) {
      encoding.maxFramerate = maxFramerate;
    }
    var canSetPriority = isFireFox() || idx === 0;
    if (preset.encoding.priority && canSetPriority) {
      encoding.priority = preset.encoding.priority;
      encoding.networkPriority = preset.encoding.priority;
    }
    encodings.push(encoding);
  });
  if (isReactNative() && getReactNativeOs() === "ios") {
    var topFramerate = void 0;
    encodings.forEach(function(encoding) {
      if (!topFramerate) {
        topFramerate = encoding.maxFramerate;
      } else if (encoding.maxFramerate && encoding.maxFramerate > topFramerate) {
        topFramerate = encoding.maxFramerate;
      }
    });
    var notifyOnce = true;
    encodings.forEach(function(encoding) {
      var _a;
      if (encoding.maxFramerate != topFramerate) {
        if (notifyOnce) {
          notifyOnce = false;
          livekitLogger.info("Simulcast on iOS React-Native requires all encodings to share the same framerate.");
        }
        livekitLogger.info('Setting framerate of encoding "'.concat((_a = encoding.rid) !== null && _a !== void 0 ? _a : "", '" to ').concat(topFramerate));
        encoding.maxFramerate = topFramerate;
      }
    });
  }
  return encodings;
}
function sortPresets(presets) {
  if (!presets) return;
  return presets.sort(function(a, b) {
    var aEnc = a.encoding;
    var bEnc = b.encoding;
    if (aEnc.maxBitrate > bEnc.maxBitrate) {
      return 1;
    }
    if (aEnc.maxBitrate < bEnc.maxBitrate) return -1;
    if (aEnc.maxBitrate === bEnc.maxBitrate && aEnc.maxFramerate && bEnc.maxFramerate) {
      return aEnc.maxFramerate > bEnc.maxFramerate ? 1 : -1;
    }
    return 0;
  });
}
var ScalabilityMode = function() {
  function ScalabilityMode2(scalabilityMode) {
    _classCallCheck(this, ScalabilityMode2);
    var results = scalabilityMode.match(/^L(\d)T(\d)(h|_KEY|_KEY_SHIFT){0,1}$/);
    if (!results) {
      throw new Error("invalid scalability mode");
    }
    this.spatial = parseInt(results[1]);
    this.temporal = parseInt(results[2]);
    if (results.length > 3) {
      switch (results[3]) {
        case "h":
        case "_KEY":
        case "_KEY_SHIFT":
          this.suffix = results[3];
      }
    }
  }
  return _createClass(ScalabilityMode2, [{
    key: "toString",
    value: function toString() {
      var _a;
      return "L".concat(this.spatial, "T").concat(this.temporal).concat((_a = this.suffix) !== null && _a !== void 0 ? _a : "");
    }
  }]);
}();
function getDefaultDegradationPreference(track) {
  if (track.source === Track.Source.ScreenShare || track.constraints.height && unwrapConstraint(track.constraints.height) >= 1080) {
    return "maintain-resolution";
  } else {
    return "balanced";
  }
}
var refreshSubscribedCodecAfterNewCodec = 5e3;
var LocalVideoTrack = function(_LocalTrack) {
  function LocalVideoTrack2(mediaTrack, constraints) {
    var _this;
    var userProvidedTrack = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    var loggerOptions = arguments.length > 3 ? arguments[3] : void 0;
    _classCallCheck(this, LocalVideoTrack2);
    _this = _callSuper(this, LocalVideoTrack2, [mediaTrack, Track.Kind.Video, constraints, userProvidedTrack, loggerOptions]);
    _this.simulcastCodecs = /* @__PURE__ */ new Map();
    _this.degradationPreference = "balanced";
    _this.monitorSender = function() {
      return __awaiter(_this, void 0, void 0, _regenerator().m(function _callee() {
        var _this2 = this;
        var stats, statsMap, totalBitrate, _t;
        return _regenerator().w(function(_context) {
          while (1) switch (_context.n) {
            case 0:
              if (this.sender) {
                _context.n = 1;
                break;
              }
              this._currentBitrate = 0;
              return _context.a(2);
            case 1:
              _context.p = 1;
              _context.n = 2;
              return this.getSenderStats();
            case 2:
              stats = _context.v;
              _context.n = 4;
              break;
            case 3:
              _context.p = 3;
              _t = _context.v;
              this.log.error("could not get audio sender stats", Object.assign(Object.assign({}, this.logContext), {
                error: _t
              }));
              return _context.a(2);
            case 4:
              statsMap = new Map(stats.map(function(s) {
                return [s.rid, s];
              }));
              if (this.prevStats) {
                totalBitrate = 0;
                statsMap.forEach(function(s, key) {
                  var _a;
                  var prev = (_a = _this2.prevStats) === null || _a === void 0 ? void 0 : _a.get(key);
                  totalBitrate += computeBitrate(s, prev);
                });
                this._currentBitrate = totalBitrate;
              }
              this.prevStats = statsMap;
            case 5:
              return _context.a(2);
          }
        }, _callee, this, [[1, 3]]);
      }));
    };
    _this.senderLock = new Mutex();
    return _this;
  }
  _inherits(LocalVideoTrack2, _LocalTrack);
  return _createClass(LocalVideoTrack2, [{
    key: "sender",
    get: function get2() {
      return this._sender;
    },
    set: function set2(sender) {
      this._sender = sender;
      if (this.degradationPreference) {
        this.setDegradationPreference(this.degradationPreference);
      }
    }
  }, {
    key: "isSimulcast",
    get: function get2() {
      if (this.sender && this.sender.getParameters().encodings.length > 1) {
        return true;
      }
      return false;
    }
    /* @internal */
  }, {
    key: "startMonitor",
    value: function startMonitor(signalClient) {
      var _this3 = this;
      var _a;
      this.signalClient = signalClient;
      if (!isWeb()) {
        return;
      }
      var params = (_a = this.sender) === null || _a === void 0 ? void 0 : _a.getParameters();
      if (params) {
        this.encodings = params.encodings;
      }
      if (this.monitorInterval) {
        return;
      }
      this.monitorInterval = setInterval(function() {
        _this3.monitorSender();
      }, monitorFrequency);
    }
  }, {
    key: "stop",
    value: function stop() {
      this._mediaStreamTrack.getConstraints();
      this.simulcastCodecs.forEach(function(trackInfo) {
        trackInfo.mediaStreamTrack.stop();
      });
      _superPropGet(LocalVideoTrack2, "stop", this, 3)([]);
    }
  }, {
    key: "pauseUpstream",
    value: function pauseUpstream() {
      var _this4 = this;
      var _super = Object.create(null, {
        pauseUpstream: {
          get: function get2() {
            return _superPropGet(LocalVideoTrack2, "pauseUpstream", _this4, 1);
          }
        }
      });
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee2() {
        var _a, e_1, _b, _c, _d, _e, _f, _g, sc, _t2;
        return _regenerator().w(function(_context2) {
          while (1) switch (_context2.n) {
            case 0:
              _context2.n = 1;
              return _super.pauseUpstream.call(this);
            case 1:
              _context2.p = 1;
              _e = true, _f = __asyncValues(this.simulcastCodecs.values());
            case 2:
              _context2.n = 3;
              return _f.next();
            case 3:
              _g = _context2.v;
              _a = _g.done;
              if (_a) {
                _context2.n = 5;
                break;
              }
              _c = _g.value;
              _e = false;
              sc = _c;
              _context2.n = 4;
              return (_d = sc.sender) === null || _d === void 0 ? void 0 : _d.replaceTrack(null);
            case 4:
              _e = true;
              _context2.n = 2;
              break;
            case 5:
              _context2.n = 7;
              break;
            case 6:
              _context2.p = 6;
              _t2 = _context2.v;
              e_1 = {
                error: _t2
              };
            case 7:
              _context2.p = 7;
              _context2.p = 8;
              if (!(!_e && !_a && (_b = _f["return"]))) {
                _context2.n = 9;
                break;
              }
              _context2.n = 9;
              return _b.call(_f);
            case 9:
              _context2.p = 9;
              if (!e_1) {
                _context2.n = 10;
                break;
              }
              throw e_1.error;
            case 10:
              return _context2.f(9);
            case 11:
              return _context2.f(7);
            case 12:
              return _context2.a(2);
          }
        }, _callee2, this, [[8, , 9, 11], [1, 6, 7, 12]]);
      }));
    }
  }, {
    key: "resumeUpstream",
    value: function resumeUpstream() {
      var _this5 = this;
      var _super = Object.create(null, {
        resumeUpstream: {
          get: function get2() {
            return _superPropGet(LocalVideoTrack2, "resumeUpstream", _this5, 1);
          }
        }
      });
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee3() {
        var _a, e_2, _b, _c, _d, _e, _f, _g, sc, _t3;
        return _regenerator().w(function(_context3) {
          while (1) switch (_context3.n) {
            case 0:
              _context3.n = 1;
              return _super.resumeUpstream.call(this);
            case 1:
              _context3.p = 1;
              _e = true, _f = __asyncValues(this.simulcastCodecs.values());
            case 2:
              _context3.n = 3;
              return _f.next();
            case 3:
              _g = _context3.v;
              _a = _g.done;
              if (_a) {
                _context3.n = 5;
                break;
              }
              _c = _g.value;
              _e = false;
              sc = _c;
              _context3.n = 4;
              return (_d = sc.sender) === null || _d === void 0 ? void 0 : _d.replaceTrack(sc.mediaStreamTrack);
            case 4:
              _e = true;
              _context3.n = 2;
              break;
            case 5:
              _context3.n = 7;
              break;
            case 6:
              _context3.p = 6;
              _t3 = _context3.v;
              e_2 = {
                error: _t3
              };
            case 7:
              _context3.p = 7;
              _context3.p = 8;
              if (!(!_e && !_a && (_b = _f["return"]))) {
                _context3.n = 9;
                break;
              }
              _context3.n = 9;
              return _b.call(_f);
            case 9:
              _context3.p = 9;
              if (!e_2) {
                _context3.n = 10;
                break;
              }
              throw e_2.error;
            case 10:
              return _context3.f(9);
            case 11:
              return _context3.f(7);
            case 12:
              return _context3.a(2);
          }
        }, _callee3, this, [[8, , 9, 11], [1, 6, 7, 12]]);
      }));
    }
  }, {
    key: "mute",
    value: function mute() {
      var _this6 = this;
      var _super = Object.create(null, {
        mute: {
          get: function get2() {
            return _superPropGet(LocalVideoTrack2, "mute", _this6, 1);
          }
        }
      });
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee4() {
        var unlock;
        return _regenerator().w(function(_context4) {
          while (1) switch (_context4.n) {
            case 0:
              _context4.n = 1;
              return this.muteLock.lock();
            case 1:
              unlock = _context4.v;
              _context4.p = 2;
              if (!this.isMuted) {
                _context4.n = 3;
                break;
              }
              this.log.debug("Track already muted", this.logContext);
              return _context4.a(2, this);
            case 3:
              if (this.source === Track.Source.Camera && !this.isUserProvided) {
                this.log.debug("stopping camera track", this.logContext);
                this._mediaStreamTrack.stop();
              }
              _context4.n = 4;
              return _super.mute.call(this);
            case 4:
              return _context4.a(2, this);
            case 5:
              _context4.p = 5;
              unlock();
              return _context4.f(5);
            case 6:
              return _context4.a(2);
          }
        }, _callee4, this, [[2, , 5, 6]]);
      }));
    }
  }, {
    key: "unmute",
    value: function unmute() {
      var _this7 = this;
      var _super = Object.create(null, {
        unmute: {
          get: function get2() {
            return _superPropGet(LocalVideoTrack2, "unmute", _this7, 1);
          }
        }
      });
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee5() {
        var unlock;
        return _regenerator().w(function(_context5) {
          while (1) switch (_context5.n) {
            case 0:
              _context5.n = 1;
              return this.muteLock.lock();
            case 1:
              unlock = _context5.v;
              _context5.p = 2;
              if (this.isMuted) {
                _context5.n = 3;
                break;
              }
              this.log.debug("Track already unmuted", this.logContext);
              return _context5.a(2, this);
            case 3:
              if (!(this.source === Track.Source.Camera && !this.isUserProvided)) {
                _context5.n = 4;
                break;
              }
              this.log.debug("reacquiring camera track", this.logContext);
              _context5.n = 4;
              return this.restartTrack();
            case 4:
              _context5.n = 5;
              return _super.unmute.call(this);
            case 5:
              return _context5.a(2, this);
            case 6:
              _context5.p = 6;
              unlock();
              return _context5.f(6);
            case 7:
              return _context5.a(2);
          }
        }, _callee5, this, [[2, , 6, 7]]);
      }));
    }
  }, {
    key: "setTrackMuted",
    value: function setTrackMuted(muted) {
      _superPropGet(LocalVideoTrack2, "setTrackMuted", this, 3)([muted]);
      var _iterator = _createForOfIteratorHelper(this.simulcastCodecs.values()), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var sc = _step.value;
          sc.mediaStreamTrack.enabled = !muted;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "getSenderStats",
    value: function getSenderStats() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee6() {
        var _a, items, stats;
        return _regenerator().w(function(_context6) {
          while (1) switch (_context6.n) {
            case 0:
              if ((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats) {
                _context6.n = 1;
                break;
              }
              return _context6.a(2, []);
            case 1:
              items = [];
              _context6.n = 2;
              return this.sender.getStats();
            case 2:
              stats = _context6.v;
              stats.forEach(function(v) {
                var _a2;
                if (v.type === "outbound-rtp") {
                  var vs = {
                    type: "video",
                    streamId: v.id,
                    frameHeight: v.frameHeight,
                    frameWidth: v.frameWidth,
                    framesPerSecond: v.framesPerSecond,
                    framesSent: v.framesSent,
                    firCount: v.firCount,
                    pliCount: v.pliCount,
                    nackCount: v.nackCount,
                    packetsSent: v.packetsSent,
                    bytesSent: v.bytesSent,
                    qualityLimitationReason: v.qualityLimitationReason,
                    qualityLimitationDurations: v.qualityLimitationDurations,
                    qualityLimitationResolutionChanges: v.qualityLimitationResolutionChanges,
                    rid: (_a2 = v.rid) !== null && _a2 !== void 0 ? _a2 : v.id,
                    retransmittedPacketsSent: v.retransmittedPacketsSent,
                    targetBitrate: v.targetBitrate,
                    timestamp: v.timestamp
                  };
                  var r2 = stats.get(v.remoteId);
                  if (r2) {
                    vs.jitter = r2.jitter;
                    vs.packetsLost = r2.packetsLost;
                    vs.roundTripTime = r2.roundTripTime;
                  }
                  items.push(vs);
                }
              });
              items.sort(function(a, b) {
                var _a2, _b;
                return ((_a2 = b.frameWidth) !== null && _a2 !== void 0 ? _a2 : 0) - ((_b = a.frameWidth) !== null && _b !== void 0 ? _b : 0);
              });
              return _context6.a(2, items);
          }
        }, _callee6, this);
      }));
    }
  }, {
    key: "setPublishingQuality",
    value: function setPublishingQuality(maxQuality) {
      var qualities = [];
      for (var q = VideoQuality.LOW; q <= VideoQuality.HIGH; q += 1) {
        qualities.push(new SubscribedQuality({
          quality: q,
          enabled: q <= maxQuality
        }));
      }
      this.log.debug("setting publishing quality. max quality ".concat(maxQuality), this.logContext);
      this.setPublishingLayers(qualities);
    }
  }, {
    key: "restartTrack",
    value: function restartTrack(options) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee7() {
        var _a, e_3, _b, _c, constraints, streamConstraints, _d, _e, _f, sc, _t4;
        return _regenerator().w(function(_context7) {
          while (1) switch (_context7.n) {
            case 0:
              if (options) {
                streamConstraints = constraintsForOptions({
                  video: options
                });
                if (typeof streamConstraints.video !== "boolean") {
                  constraints = streamConstraints.video;
                }
              }
              _context7.n = 1;
              return this.restart(constraints);
            case 1:
              _context7.p = 1;
              _d = true, _e = __asyncValues(this.simulcastCodecs.values());
            case 2:
              _context7.n = 3;
              return _e.next();
            case 3:
              _f = _context7.v;
              _a = _f.done;
              if (_a) {
                _context7.n = 5;
                break;
              }
              _c = _f.value;
              _d = false;
              sc = _c;
              if (!sc.sender) {
                _context7.n = 4;
                break;
              }
              sc.mediaStreamTrack = this.mediaStreamTrack.clone();
              _context7.n = 4;
              return sc.sender.replaceTrack(sc.mediaStreamTrack);
            case 4:
              _d = true;
              _context7.n = 2;
              break;
            case 5:
              _context7.n = 7;
              break;
            case 6:
              _context7.p = 6;
              _t4 = _context7.v;
              e_3 = {
                error: _t4
              };
            case 7:
              _context7.p = 7;
              _context7.p = 8;
              if (!(!_d && !_a && (_b = _e["return"]))) {
                _context7.n = 9;
                break;
              }
              _context7.n = 9;
              return _b.call(_e);
            case 9:
              _context7.p = 9;
              if (!e_3) {
                _context7.n = 10;
                break;
              }
              throw e_3.error;
            case 10:
              return _context7.f(9);
            case 11:
              return _context7.f(7);
            case 12:
              return _context7.a(2);
          }
        }, _callee7, this, [[8, , 9, 11], [1, 6, 7, 12]]);
      }));
    }
  }, {
    key: "setProcessor",
    value: function setProcessor(processor_1) {
      var _this8 = this;
      var _super = Object.create(null, {
        setProcessor: {
          get: function get2() {
            return _superPropGet(LocalVideoTrack2, "setProcessor", _this8, 1);
          }
        }
      });
      return __awaiter(this, arguments, void 0, function(processor) {
        var _this9 = this;
        var showProcessedStreamLocally = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        return _regenerator().m(function _callee8() {
          var _a, e_4, _b, _c, _d, _e, _f, _g, _h, sc, _t5;
          return _regenerator().w(function(_context8) {
            while (1) switch (_context8.n) {
              case 0:
                _context8.n = 1;
                return _super.setProcessor.call(_this9, processor, showProcessedStreamLocally);
              case 1:
                if (!((_d = _this9.processor) === null || _d === void 0 ? void 0 : _d.processedTrack)) {
                  _context8.n = 13;
                  break;
                }
                _context8.p = 2;
                _f = true, _g = __asyncValues(_this9.simulcastCodecs.values());
              case 3:
                _context8.n = 4;
                return _g.next();
              case 4:
                _h = _context8.v;
                _a = _h.done;
                if (_a) {
                  _context8.n = 6;
                  break;
                }
                _c = _h.value;
                _f = false;
                sc = _c;
                _context8.n = 5;
                return (_e = sc.sender) === null || _e === void 0 ? void 0 : _e.replaceTrack(_this9.processor.processedTrack);
              case 5:
                _f = true;
                _context8.n = 3;
                break;
              case 6:
                _context8.n = 8;
                break;
              case 7:
                _context8.p = 7;
                _t5 = _context8.v;
                e_4 = {
                  error: _t5
                };
              case 8:
                _context8.p = 8;
                _context8.p = 9;
                if (!(!_f && !_a && (_b = _g["return"]))) {
                  _context8.n = 10;
                  break;
                }
                _context8.n = 10;
                return _b.call(_g);
              case 10:
                _context8.p = 10;
                if (!e_4) {
                  _context8.n = 11;
                  break;
                }
                throw e_4.error;
              case 11:
                return _context8.f(10);
              case 12:
                return _context8.f(8);
              case 13:
                return _context8.a(2);
            }
          }, _callee8, null, [[9, , 10, 12], [2, 7, 8, 13]]);
        })();
      });
    }
  }, {
    key: "setDegradationPreference",
    value: function setDegradationPreference(preference) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee9() {
        var params;
        return _regenerator().w(function(_context9) {
          while (1) switch (_context9.n) {
            case 0:
              this.degradationPreference = preference;
              if (this.sender) {
                try {
                  this.log.debug("setting degradationPreference to ".concat(preference), this.logContext);
                  params = this.sender.getParameters();
                  params.degradationPreference = preference;
                  this.sender.setParameters(params);
                } catch (e) {
                  this.log.warn("failed to set degradationPreference", Object.assign({
                    error: e
                  }, this.logContext));
                }
              }
            case 1:
              return _context9.a(2);
          }
        }, _callee9, this);
      }));
    }
  }, {
    key: "addSimulcastTrack",
    value: function addSimulcastTrack(codec, encodings) {
      if (this.simulcastCodecs.has(codec)) {
        this.log.error("".concat(codec, " already added, skipping adding simulcast codec"), this.logContext);
        return;
      }
      var simulcastCodecInfo = {
        codec,
        mediaStreamTrack: this.mediaStreamTrack.clone(),
        sender: void 0,
        encodings
      };
      this.simulcastCodecs.set(codec, simulcastCodecInfo);
      return simulcastCodecInfo;
    }
  }, {
    key: "setSimulcastTrackSender",
    value: function setSimulcastTrackSender(codec, sender) {
      var _this0 = this;
      var simulcastCodecInfo = this.simulcastCodecs.get(codec);
      if (!simulcastCodecInfo) {
        return;
      }
      simulcastCodecInfo.sender = sender;
      setTimeout(function() {
        if (_this0.subscribedCodecs) {
          _this0.setPublishingCodecs(_this0.subscribedCodecs);
        }
      }, refreshSubscribedCodecAfterNewCodec);
    }
    /**
     * @internal
     * Sets codecs that should be publishing, returns new codecs that have not yet
     * been published
     */
  }, {
    key: "setPublishingCodecs",
    value: function setPublishingCodecs(codecs) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee0() {
        var _a, codecs_1, codecs_1_1, _b, e_5, _c, _d, newCodecs, codec, simulcastCodecInfo, _iterator2, _step2, q, _t6, _t7;
        return _regenerator().w(function(_context0) {
          while (1) switch (_context0.n) {
            case 0:
              this.log.debug("setting publishing codecs", Object.assign(Object.assign({}, this.logContext), {
                codecs,
                currentCodec: this.codec
              }));
              if (!(!this.codec && codecs.length > 0)) {
                _context0.n = 2;
                break;
              }
              _context0.n = 1;
              return this.setPublishingLayers(codecs[0].qualities);
            case 1:
              return _context0.a(2, []);
            case 2:
              this.subscribedCodecs = codecs;
              newCodecs = [];
              _context0.p = 3;
              _a = true, codecs_1 = __asyncValues(codecs);
            case 4:
              _context0.n = 5;
              return codecs_1.next();
            case 5:
              codecs_1_1 = _context0.v;
              _b = codecs_1_1.done;
              if (_b) {
                _context0.n = 17;
                break;
              }
              _d = codecs_1_1.value;
              _a = false;
              codec = _d;
              if (!(!this.codec || this.codec === codec.codec)) {
                _context0.n = 7;
                break;
              }
              _context0.n = 6;
              return this.setPublishingLayers(codec.qualities);
            case 6:
              _context0.n = 16;
              break;
            case 7:
              simulcastCodecInfo = this.simulcastCodecs.get(codec.codec);
              this.log.debug("try setPublishingCodec for ".concat(codec.codec), Object.assign(Object.assign({}, this.logContext), {
                simulcastCodecInfo
              }));
              if (!(!simulcastCodecInfo || !simulcastCodecInfo.sender)) {
                _context0.n = 15;
                break;
              }
              _iterator2 = _createForOfIteratorHelper(codec.qualities);
              _context0.p = 8;
              _iterator2.s();
            case 9:
              if ((_step2 = _iterator2.n()).done) {
                _context0.n = 11;
                break;
              }
              q = _step2.value;
              if (!q.enabled) {
                _context0.n = 10;
                break;
              }
              newCodecs.push(codec.codec);
              return _context0.a(3, 11);
            case 10:
              _context0.n = 9;
              break;
            case 11:
              _context0.n = 13;
              break;
            case 12:
              _context0.p = 12;
              _t6 = _context0.v;
              _iterator2.e(_t6);
            case 13:
              _context0.p = 13;
              _iterator2.f();
              return _context0.f(13);
            case 14:
              _context0.n = 16;
              break;
            case 15:
              if (!simulcastCodecInfo.encodings) {
                _context0.n = 16;
                break;
              }
              this.log.debug("try setPublishingLayersForSender ".concat(codec.codec), this.logContext);
              _context0.n = 16;
              return setPublishingLayersForSender(simulcastCodecInfo.sender, simulcastCodecInfo.encodings, codec.qualities, this.senderLock, this.log, this.logContext);
            case 16:
              _a = true;
              _context0.n = 4;
              break;
            case 17:
              _context0.n = 19;
              break;
            case 18:
              _context0.p = 18;
              _t7 = _context0.v;
              e_5 = {
                error: _t7
              };
            case 19:
              _context0.p = 19;
              _context0.p = 20;
              if (!(!_a && !_b && (_c = codecs_1["return"]))) {
                _context0.n = 21;
                break;
              }
              _context0.n = 21;
              return _c.call(codecs_1);
            case 21:
              _context0.p = 21;
              if (!e_5) {
                _context0.n = 22;
                break;
              }
              throw e_5.error;
            case 22:
              return _context0.f(21);
            case 23:
              return _context0.f(19);
            case 24:
              return _context0.a(2, newCodecs);
          }
        }, _callee0, this, [[20, , 21, 23], [8, 12, 13, 14], [3, 18, 19, 24]]);
      }));
    }
    /**
     * @internal
     * Sets layers that should be publishing
     */
  }, {
    key: "setPublishingLayers",
    value: function setPublishingLayers(qualities) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee1() {
        return _regenerator().w(function(_context1) {
          while (1) switch (_context1.n) {
            case 0:
              this.log.debug("setting publishing layers", Object.assign(Object.assign({}, this.logContext), {
                qualities
              }));
              if (!(!this.sender || !this.encodings)) {
                _context1.n = 1;
                break;
              }
              return _context1.a(2);
            case 1:
              _context1.n = 2;
              return setPublishingLayersForSender(this.sender, this.encodings, qualities, this.senderLock, this.log, this.logContext);
            case 2:
              return _context1.a(2);
          }
        }, _callee1, this);
      }));
    }
  }, {
    key: "handleAppVisibilityChanged",
    value: function handleAppVisibilityChanged() {
      var _this1 = this;
      var _super = Object.create(null, {
        handleAppVisibilityChanged: {
          get: function get2() {
            return _superPropGet(LocalVideoTrack2, "handleAppVisibilityChanged", _this1, 1);
          }
        }
      });
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee10() {
        return _regenerator().w(function(_context10) {
          while (1) switch (_context10.n) {
            case 0:
              _context10.n = 1;
              return _super.handleAppVisibilityChanged.call(this);
            case 1:
              if (isMobile()) {
                _context10.n = 2;
                break;
              }
              return _context10.a(2);
            case 2:
              if (this.isInBackground && this.source === Track.Source.Camera) {
                this._mediaStreamTrack.enabled = false;
              }
            case 3:
              return _context10.a(2);
          }
        }, _callee10, this);
      }));
    }
  }]);
}(LocalTrack);
function setPublishingLayersForSender(sender, senderEncodings, qualities, senderLock, log2, logContext) {
  return __awaiter(this, void 0, void 0, _regenerator().m(function _callee11() {
    var unlock, params, encodings, hasChanged, closableSpatial, encoding, maxQuality;
    return _regenerator().w(function(_context11) {
      while (1) switch (_context11.n) {
        case 0:
          _context11.n = 1;
          return senderLock.lock();
        case 1:
          unlock = _context11.v;
          log2.debug("setPublishingLayersForSender", Object.assign(Object.assign({}, logContext), {
            sender,
            qualities,
            senderEncodings
          }));
          _context11.p = 2;
          params = sender.getParameters();
          encodings = params.encodings;
          if (encodings) {
            _context11.n = 3;
            break;
          }
          return _context11.a(2);
        case 3:
          if (!(encodings.length !== senderEncodings.length)) {
            _context11.n = 4;
            break;
          }
          log2.warn("cannot set publishing layers, encodings mismatch", Object.assign(Object.assign({}, logContext), {
            encodings,
            senderEncodings
          }));
          return _context11.a(2);
        case 4:
          hasChanged = false;
          closableSpatial = false;
          if (closableSpatial && encodings[0].scalabilityMode) {
            encoding = encodings[0];
            maxQuality = VideoQuality$1.OFF;
            qualities.forEach(function(q) {
              if (q.enabled && (maxQuality === VideoQuality$1.OFF || q.quality > maxQuality)) {
                maxQuality = q.quality;
              }
            });
            if (maxQuality === VideoQuality$1.OFF) {
              if (encoding.active) {
                encoding.active = false;
                hasChanged = true;
              }
            } else if (!encoding.active) {
              hasChanged = true;
              encoding.active = true;
            }
          } else {
            encodings.forEach(function(encoding2, idx) {
              var _a;
              var rid = (_a = encoding2.rid) !== null && _a !== void 0 ? _a : "";
              if (rid === "") {
                rid = "q";
              }
              var quality = videoQualityForRid(rid);
              var subscribedQuality = qualities.find(function(q) {
                return q.quality === quality;
              });
              if (!subscribedQuality) {
                return;
              }
              if (encoding2.active !== subscribedQuality.enabled) {
                hasChanged = true;
                encoding2.active = subscribedQuality.enabled;
                log2.debug("setting layer ".concat(subscribedQuality.quality, " to ").concat(encoding2.active ? "enabled" : "disabled"), logContext);
                if (isFireFox()) {
                  if (subscribedQuality.enabled) {
                    encoding2.scaleResolutionDownBy = senderEncodings[idx].scaleResolutionDownBy;
                    encoding2.maxBitrate = senderEncodings[idx].maxBitrate;
                    encoding2.maxFrameRate = senderEncodings[idx].maxFrameRate;
                  } else {
                    encoding2.scaleResolutionDownBy = 4;
                    encoding2.maxBitrate = 10;
                    encoding2.maxFrameRate = 2;
                  }
                }
              }
            });
          }
          if (!hasChanged) {
            _context11.n = 5;
            break;
          }
          params.encodings = encodings;
          log2.debug("setting encodings", Object.assign(Object.assign({}, logContext), {
            encodings: params.encodings
          }));
          _context11.n = 5;
          return sender.setParameters(params);
        case 5:
          _context11.p = 5;
          unlock();
          return _context11.f(5);
        case 6:
          return _context11.a(2);
      }
    }, _callee11, null, [[2, , 5, 6]]);
  }));
}
function videoQualityForRid(rid) {
  switch (rid) {
    case "f":
      return VideoQuality.HIGH;
    case "h":
      return VideoQuality.MEDIUM;
    case "q":
      return VideoQuality.LOW;
    default:
      return VideoQuality.HIGH;
  }
}
function videoLayersFromEncodings(width, height, encodings, svc) {
  if (!encodings) {
    return [new VideoLayer({
      quality: VideoQuality.HIGH,
      width,
      height,
      bitrate: 0,
      ssrc: 0
    })];
  }
  if (svc) {
    var encodingSM = encodings[0].scalabilityMode;
    var sm = new ScalabilityMode(encodingSM);
    var layers = [];
    var resRatio = sm.suffix == "h" ? 1.5 : 2;
    var bitratesRatio = sm.suffix == "h" ? 2 : 3;
    for (var i = 0; i < sm.spatial; i += 1) {
      layers.push(new VideoLayer({
        quality: Math.min(VideoQuality.HIGH, sm.spatial - 1) - i,
        width: Math.ceil(width / Math.pow(resRatio, i)),
        height: Math.ceil(height / Math.pow(resRatio, i)),
        bitrate: encodings[0].maxBitrate ? Math.ceil(encodings[0].maxBitrate / Math.pow(bitratesRatio, i)) : 0,
        ssrc: 0
      }));
    }
    return layers;
  }
  return encodings.map(function(encoding) {
    var _a, _b, _c;
    var scale = (_a = encoding.scaleResolutionDownBy) !== null && _a !== void 0 ? _a : 1;
    var quality = videoQualityForRid((_b = encoding.rid) !== null && _b !== void 0 ? _b : "");
    return new VideoLayer({
      quality,
      width: Math.ceil(width / scale),
      height: Math.ceil(height / scale),
      bitrate: (_c = encoding.maxBitrate) !== null && _c !== void 0 ? _c : 0,
      ssrc: 0
    });
  });
}
var lossyDataChannel = "_lossy";
var reliableDataChannel = "_reliable";
var minReconnectWait = 2 * 1e3;
var leaveReconnect = "leave-reconnect";
var PCState;
(function(PCState2) {
  PCState2[PCState2["New"] = 0] = "New";
  PCState2[PCState2["Connected"] = 1] = "Connected";
  PCState2[PCState2["Disconnected"] = 2] = "Disconnected";
  PCState2[PCState2["Reconnecting"] = 3] = "Reconnecting";
  PCState2[PCState2["Closed"] = 4] = "Closed";
})(PCState || (PCState = {}));
var RTCEngine = function(_EventEmitter) {
  function RTCEngine2(options) {
    var _this;
    _classCallCheck(this, RTCEngine2);
    var _a;
    _this = _callSuper(this, RTCEngine2);
    _this.options = options;
    _this.rtcConfig = {};
    _this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout;
    _this.fullReconnectOnNext = false;
    _this.subscriberPrimary = false;
    _this.hasPublished = false;
    _this.pcState = PCState.New;
    _this._isClosed = true;
    _this.pendingTrackResolvers = {};
    _this.reconnectAttempts = 0;
    _this.reconnectStart = 0;
    _this.attemptingReconnect = false;
    _this.joinAttempts = 0;
    _this.maxJoinAttempts = 1;
    _this.firstReconnectAttempt = true;
    _this.shouldFailNext = false;
    _this.log = livekitLogger;
    _this.disconnectStartTimePrimary = 0;
    _this.disconnectStartTimeSecondary = 0;
    _this.handleDataChannel = function(_a2) {
      return __awaiter(_this, [_a2], void 0, function(_ref) {
        var _this2 = this;
        var channel = _ref.channel;
        return _regenerator().m(function _callee() {
          return _regenerator().w(function(_context) {
            while (1) switch (_context.n) {
              case 0:
                if (channel) {
                  _context.n = 1;
                  break;
                }
                return _context.a(2);
              case 1:
                if (!(channel.label === reliableDataChannel)) {
                  _context.n = 2;
                  break;
                }
                _this2.reliableDCSub = channel;
                _context.n = 4;
                break;
              case 2:
                if (!(channel.label === lossyDataChannel)) {
                  _context.n = 3;
                  break;
                }
                _this2.lossyDCSub = channel;
                _context.n = 4;
                break;
              case 3:
                return _context.a(2);
              case 4:
                _this2.log.debug("on data channel ".concat(channel.id, ", ").concat(channel.label), _this2.logContext);
                channel.onmessage = _this2.handleDataMessage;
              case 5:
                return _context.a(2);
            }
          }, _callee);
        })();
      });
    };
    _this.handleDataMessage = function(message) {
      return __awaiter(_this, void 0, void 0, _regenerator().m(function _callee2() {
        var _a2, _b, unlock, buffer, dp;
        return _regenerator().w(function(_context2) {
          while (1) switch (_context2.n) {
            case 0:
              _context2.n = 1;
              return this.dataProcessLock.lock();
            case 1:
              unlock = _context2.v;
              _context2.p = 2;
              if (!(message.data instanceof ArrayBuffer)) {
                _context2.n = 3;
                break;
              }
              buffer = message.data;
              _context2.n = 6;
              break;
            case 3:
              if (!(message.data instanceof Blob)) {
                _context2.n = 5;
                break;
              }
              _context2.n = 4;
              return message.data.arrayBuffer();
            case 4:
              buffer = _context2.v;
              _context2.n = 6;
              break;
            case 5:
              this.log.error("unsupported data type", Object.assign(Object.assign({}, this.logContext), {
                data: message.data
              }));
              return _context2.a(2);
            case 6:
              dp = DataPacket.fromBinary(new Uint8Array(buffer));
              if (((_a2 = dp.value) === null || _a2 === void 0 ? void 0 : _a2["case"]) === "speaker") {
                this.emit(EngineEvent.ActiveSpeakersUpdate, dp.value.value.speakers);
              } else {
                if (((_b = dp.value) === null || _b === void 0 ? void 0 : _b["case"]) === "user") {
                  applyUserDataCompat(dp, dp.value.value);
                }
                this.emit(EngineEvent.DataPacketReceived, dp);
              }
            case 7:
              _context2.p = 7;
              unlock();
              return _context2.f(7);
            case 8:
              return _context2.a(2);
          }
        }, _callee2, this, [[2, , 7, 8]]);
      }));
    };
    _this.handleDataError = function(event) {
      var channel = event.currentTarget;
      var channelKind = channel.maxRetransmits === 0 ? "lossy" : "reliable";
      if (event instanceof ErrorEvent && event.error) {
        var error = event.error.error;
        _this.log.error("DataChannel error on ".concat(channelKind, ": ").concat(event.message), Object.assign(Object.assign({}, _this.logContext), {
          error
        }));
      } else {
        _this.log.error("Unknown DataChannel error on ".concat(channelKind), Object.assign(Object.assign({}, _this.logContext), {
          event
        }));
      }
    };
    _this.handleBufferedAmountLow = function(event) {
      var channel = event.currentTarget;
      var channelKind = channel.maxRetransmits === 0 ? DataPacket_Kind.LOSSY : DataPacket_Kind.RELIABLE;
      _this.updateAndEmitDCBufferStatus(channelKind);
    };
    _this.handleDisconnect = function(connection, disconnectReason) {
      if (_this._isClosed) {
        return;
      }
      _this.log.warn("".concat(connection, " disconnected"), _this.logContext);
      if (_this.reconnectAttempts === 0) {
        _this.reconnectStart = Date.now();
      }
      var disconnect = function disconnect2(duration2) {
        _this.log.warn("could not recover connection after ".concat(_this.reconnectAttempts, " attempts, ").concat(duration2, "ms. giving up"), _this.logContext);
        _this.emit(EngineEvent.Disconnected);
        _this.close();
      };
      var duration = Date.now() - _this.reconnectStart;
      var delay = _this.getNextRetryDelay({
        elapsedMs: duration,
        retryCount: _this.reconnectAttempts
      });
      if (delay === null) {
        disconnect(duration);
        return;
      }
      if (connection === leaveReconnect) {
        delay = 0;
      }
      _this.log.debug("reconnecting in ".concat(delay, "ms"), _this.logContext);
      _this.clearReconnectTimeout();
      if (_this.token && _this.regionUrlProvider) {
        _this.regionUrlProvider.updateToken(_this.token);
      }
      _this.reconnectTimeout = CriticalTimers.setTimeout(function() {
        return _this.attemptReconnect(disconnectReason)["finally"](function() {
          return _this.reconnectTimeout = void 0;
        });
      }, delay);
    };
    _this.waitForRestarted = function() {
      return new Promise(function(resolve, reject) {
        if (_this.pcState === PCState.Connected) {
          resolve();
        }
        var onRestarted = function onRestarted2() {
          _this.off(EngineEvent.Disconnected, onDisconnected);
          resolve();
        };
        var onDisconnected = function onDisconnected2() {
          _this.off(EngineEvent.Restarted, onRestarted);
          reject();
        };
        _this.once(EngineEvent.Restarted, onRestarted);
        _this.once(EngineEvent.Disconnected, onDisconnected);
      });
    };
    _this.updateAndEmitDCBufferStatus = function(kind) {
      var status = _this.isBufferStatusLow(kind);
      if (typeof status !== "undefined" && status !== _this.dcBufferStatus.get(kind)) {
        _this.dcBufferStatus.set(kind, status);
        _this.emit(EngineEvent.DCBufferStatusChanged, status, kind);
      }
    };
    _this.isBufferStatusLow = function(kind) {
      var dc = _this.dataChannelForKind(kind);
      if (dc) {
        return dc.bufferedAmount <= dc.bufferedAmountLowThreshold;
      }
    };
    _this.handleBrowserOnLine = function() {
      if (_this.client.currentState === SignalConnectionState.RECONNECTING) {
        _this.clearReconnectTimeout();
        _this.attemptReconnect(ReconnectReason.RR_SIGNAL_DISCONNECTED);
      }
    };
    _this.log = getLogger((_a = options.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Engine);
    _this.loggerOptions = {
      loggerName: options.loggerName,
      loggerContextCb: function loggerContextCb() {
        return _this.logContext;
      }
    };
    _this.client = new SignalClient(void 0, _this.loggerOptions);
    _this.client.signalLatency = _this.options.expSignalLatency;
    _this.reconnectPolicy = _this.options.reconnectPolicy;
    _this.registerOnLineListener();
    _this.closingLock = new Mutex();
    _this.dataProcessLock = new Mutex();
    _this.dcBufferStatus = /* @__PURE__ */ new Map([[DataPacket_Kind.LOSSY, true], [DataPacket_Kind.RELIABLE, true]]);
    _this.client.onParticipantUpdate = function(updates) {
      return _this.emit(EngineEvent.ParticipantUpdate, updates);
    };
    _this.client.onConnectionQuality = function(update) {
      return _this.emit(EngineEvent.ConnectionQualityUpdate, update);
    };
    _this.client.onRoomUpdate = function(update) {
      return _this.emit(EngineEvent.RoomUpdate, update);
    };
    _this.client.onSubscriptionError = function(resp) {
      return _this.emit(EngineEvent.SubscriptionError, resp);
    };
    _this.client.onSubscriptionPermissionUpdate = function(update) {
      return _this.emit(EngineEvent.SubscriptionPermissionUpdate, update);
    };
    _this.client.onSpeakersChanged = function(update) {
      return _this.emit(EngineEvent.SpeakersChanged, update);
    };
    _this.client.onStreamStateUpdate = function(update) {
      return _this.emit(EngineEvent.StreamStateChanged, update);
    };
    _this.client.onRequestResponse = function(response) {
      return _this.emit(EngineEvent.SignalRequestResponse, response);
    };
    return _this;
  }
  _inherits(RTCEngine2, _EventEmitter);
  return _createClass(RTCEngine2, [{
    key: "isClosed",
    get: function get2() {
      return this._isClosed;
    }
  }, {
    key: "pendingReconnect",
    get: function get2() {
      return !!this.reconnectTimeout;
    }
  }, {
    key: "logContext",
    get: function get2() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      return {
        room: (_b = (_a = this.latestJoinResponse) === null || _a === void 0 ? void 0 : _a.room) === null || _b === void 0 ? void 0 : _b.name,
        roomID: (_d = (_c = this.latestJoinResponse) === null || _c === void 0 ? void 0 : _c.room) === null || _d === void 0 ? void 0 : _d.sid,
        participant: (_f = (_e = this.latestJoinResponse) === null || _e === void 0 ? void 0 : _e.participant) === null || _f === void 0 ? void 0 : _f.identity,
        pID: (_h = (_g = this.latestJoinResponse) === null || _g === void 0 ? void 0 : _g.participant) === null || _h === void 0 ? void 0 : _h.sid
      };
    }
  }, {
    key: "join",
    value: function join(url, token, opts, abortSignal) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee3() {
        var joinResponse, _t;
        return _regenerator().w(function(_context3) {
          while (1) switch (_context3.n) {
            case 0:
              this.url = url;
              this.token = token;
              this.signalOpts = opts;
              this.maxJoinAttempts = opts.maxRetries;
              _context3.p = 1;
              this.joinAttempts += 1;
              this.setupSignalClientCallbacks();
              _context3.n = 2;
              return this.client.join(url, token, opts, abortSignal);
            case 2:
              joinResponse = _context3.v;
              this._isClosed = false;
              this.latestJoinResponse = joinResponse;
              this.subscriberPrimary = joinResponse.subscriberPrimary;
              if (this.pcManager) {
                _context3.n = 3;
                break;
              }
              _context3.n = 3;
              return this.configure(joinResponse);
            case 3:
              if (!this.subscriberPrimary || joinResponse.fastPublish) {
                this.negotiate();
              }
              this.clientConfiguration = joinResponse.clientConfiguration;
              return _context3.a(2, joinResponse);
            case 4:
              _context3.p = 4;
              _t = _context3.v;
              if (!(_t instanceof ConnectionError)) {
                _context3.n = 5;
                break;
              }
              if (!(_t.reason === 1)) {
                _context3.n = 5;
                break;
              }
              this.log.warn("Couldn't connect to server, attempt ".concat(this.joinAttempts, " of ").concat(this.maxJoinAttempts), this.logContext);
              if (!(this.joinAttempts < this.maxJoinAttempts)) {
                _context3.n = 5;
                break;
              }
              return _context3.a(2, this.join(url, token, opts, abortSignal));
            case 5:
              throw _t;
            case 6:
              return _context3.a(2);
          }
        }, _callee3, this, [[1, 4]]);
      }));
    }
  }, {
    key: "close",
    value: function close() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee4() {
        var unlock;
        return _regenerator().w(function(_context4) {
          while (1) switch (_context4.n) {
            case 0:
              _context4.n = 1;
              return this.closingLock.lock();
            case 1:
              unlock = _context4.v;
              if (!this.isClosed) {
                _context4.n = 2;
                break;
              }
              unlock();
              return _context4.a(2);
            case 2:
              _context4.p = 2;
              this._isClosed = true;
              this.joinAttempts = 0;
              this.emit(EngineEvent.Closing);
              this.removeAllListeners();
              this.deregisterOnLineListener();
              this.clearPendingReconnect();
              _context4.n = 3;
              return this.cleanupPeerConnections();
            case 3:
              _context4.n = 4;
              return this.cleanupClient();
            case 4:
              _context4.p = 4;
              unlock();
              return _context4.f(4);
            case 5:
              return _context4.a(2);
          }
        }, _callee4, this, [[2, , 4, 5]]);
      }));
    }
  }, {
    key: "cleanupPeerConnections",
    value: function cleanupPeerConnections() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee5() {
        var _a, dcCleanup;
        return _regenerator().w(function(_context5) {
          while (1) switch (_context5.n) {
            case 0:
              _context5.n = 1;
              return (_a = this.pcManager) === null || _a === void 0 ? void 0 : _a.close();
            case 1:
              this.pcManager = void 0;
              dcCleanup = function dcCleanup2(dc) {
                if (!dc) return;
                dc.close();
                dc.onbufferedamountlow = null;
                dc.onclose = null;
                dc.onclosing = null;
                dc.onerror = null;
                dc.onmessage = null;
                dc.onopen = null;
              };
              dcCleanup(this.lossyDC);
              dcCleanup(this.lossyDCSub);
              dcCleanup(this.reliableDC);
              dcCleanup(this.reliableDCSub);
              this.lossyDC = void 0;
              this.lossyDCSub = void 0;
              this.reliableDC = void 0;
              this.reliableDCSub = void 0;
            case 2:
              return _context5.a(2);
          }
        }, _callee5, this);
      }));
    }
  }, {
    key: "cleanupClient",
    value: function cleanupClient() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee6() {
        return _regenerator().w(function(_context6) {
          while (1) switch (_context6.n) {
            case 0:
              _context6.n = 1;
              return this.client.close();
            case 1:
              this.client.resetCallbacks();
            case 2:
              return _context6.a(2);
          }
        }, _callee6, this);
      }));
    }
  }, {
    key: "addTrack",
    value: function addTrack(req) {
      var _this3 = this;
      if (this.pendingTrackResolvers[req.cid]) {
        throw new TrackInvalidError("a track with the same ID has already been published");
      }
      return new Promise(function(_resolve, _reject) {
        var publicationTimeout = setTimeout(function() {
          delete _this3.pendingTrackResolvers[req.cid];
          _reject(new ConnectionError(
            "publication of local track timed out, no response from server",
            2
            /* ConnectionErrorReason.InternalError */
          ));
        }, 1e4);
        _this3.pendingTrackResolvers[req.cid] = {
          resolve: function resolve(info) {
            clearTimeout(publicationTimeout);
            _resolve(info);
          },
          reject: function reject() {
            clearTimeout(publicationTimeout);
            _reject(new Error("Cancelled publication by calling unpublish"));
          }
        };
        _this3.client.sendAddTrack(req);
      });
    }
    /**
     * Removes sender from PeerConnection, returning true if it was removed successfully
     * and a negotiation is necessary
     * @param sender
     * @returns
     */
  }, {
    key: "removeTrack",
    value: function removeTrack(sender) {
      if (sender.track && this.pendingTrackResolvers[sender.track.id]) {
        var reject = this.pendingTrackResolvers[sender.track.id].reject;
        if (reject) {
          reject();
        }
        delete this.pendingTrackResolvers[sender.track.id];
      }
      try {
        this.pcManager.removeTrack(sender);
        return true;
      } catch (e) {
        this.log.warn("failed to remove track", Object.assign(Object.assign({}, this.logContext), {
          error: e
        }));
      }
      return false;
    }
  }, {
    key: "updateMuteStatus",
    value: function updateMuteStatus(trackSid, muted) {
      this.client.sendMuteTrack(trackSid, muted);
    }
  }, {
    key: "dataSubscriberReadyState",
    get: function get2() {
      var _a;
      return (_a = this.reliableDCSub) === null || _a === void 0 ? void 0 : _a.readyState;
    }
  }, {
    key: "getConnectedServerAddress",
    value: function getConnectedServerAddress() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee7() {
        var _a;
        return _regenerator().w(function(_context7) {
          while (1) switch (_context7.n) {
            case 0:
              return _context7.a(2, (_a = this.pcManager) === null || _a === void 0 ? void 0 : _a.getConnectedAddress());
          }
        }, _callee7, this);
      }));
    }
    //private numberOfTimeSet: number = 0;
    /* @internal */
  }, {
    key: "setRegionUrlProvider",
    value: function setRegionUrlProvider(provider) {
      this.regionUrlProvider = provider;
    }
  }, {
    key: "configure",
    value: function configure(joinResponse) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee9() {
        var _this4 = this;
        var _a, _b, rtcConfig;
        return _regenerator().w(function(_context9) {
          while (1) switch (_context9.n) {
            case 0:
              if (!(this.pcManager && this.pcManager.currentState !== PCTransportState.NEW)) {
                _context9.n = 1;
                break;
              }
              return _context9.a(2);
            case 1:
              this.participantSid = (_a = joinResponse.participant) === null || _a === void 0 ? void 0 : _a.sid;
              rtcConfig = this.makeRTCConfiguration(joinResponse);
              this.pcManager = new PCTransportManager(rtcConfig, joinResponse.subscriberPrimary, this.loggerOptions);
              this.emit(EngineEvent.TransportsCreated, this.pcManager.publisher, this.pcManager.subscriber);
              this.pcManager.onIceCandidate = function(candidate, target) {
                _this4.client.sendIceCandidate(candidate, target);
              };
              this.pcManager.onPublisherOffer = function(offer) {
                _this4.client.sendOffer(offer);
              };
              this.pcManager.onDataChannel = this.handleDataChannel;
              this.pcManager.onStateChange = function(connectionState, publisherState, subscriberState) {
                return __awaiter(_this4, void 0, void 0, _regenerator().m(function _callee8() {
                  var shouldEmit, isSignalSevered, isPCSevered;
                  return _regenerator().w(function(_context8) {
                    while (1) switch (_context8.n) {
                      case 0:
                        this.log.debug("primary PC state changed ".concat(connectionState), this.logContext);
                        if (["closed", "disconnected", "failed"].includes(publisherState)) {
                          this.publisherConnectionPromise = void 0;
                        }
                        if (connectionState === PCTransportState.CONNECTED) {
                          shouldEmit = this.pcState === PCState.New;
                          this.pcState = PCState.Connected;
                          if (shouldEmit) {
                            this.emit(EngineEvent.Connected, joinResponse);
                          }
                        } else if (connectionState === PCTransportState.FAILED) {
                          if (this.pcState === PCState.Connected) {
                            this.pcState = PCState.Disconnected;
                            this.handleDisconnect("peerconnection failed", subscriberState === "failed" ? ReconnectReason.RR_SUBSCRIBER_FAILED : ReconnectReason.RR_PUBLISHER_FAILED);
                          }
                        }
                        isSignalSevered = this.client.isDisconnected || this.client.currentState === SignalConnectionState.RECONNECTING;
                        isPCSevered = [PCTransportState.FAILED, PCTransportState.CLOSING, PCTransportState.CLOSED].includes(connectionState);
                        if (isSignalSevered && isPCSevered && !this._isClosed) {
                          this.emit(EngineEvent.Offline);
                        }
                      case 1:
                        return _context8.a(2);
                    }
                  }, _callee8, this);
                }));
              };
              this.pcManager.onTrack = function(ev) {
                _this4.emit(EngineEvent.MediaTrackAdded, ev.track, ev.streams[0], ev.receiver);
              };
              if (!supportOptionalDatachannel((_b = joinResponse.serverInfo) === null || _b === void 0 ? void 0 : _b.protocol)) {
                this.createDataChannels();
              }
            case 2:
              return _context9.a(2);
          }
        }, _callee9, this);
      }));
    }
  }, {
    key: "setupSignalClientCallbacks",
    value: function setupSignalClientCallbacks() {
      var _this5 = this;
      this.client.onAnswer = function(sd) {
        return __awaiter(_this5, void 0, void 0, _regenerator().m(function _callee0() {
          return _regenerator().w(function(_context0) {
            while (1) switch (_context0.n) {
              case 0:
                if (this.pcManager) {
                  _context0.n = 1;
                  break;
                }
                return _context0.a(2);
              case 1:
                this.log.debug("received server answer", Object.assign(Object.assign({}, this.logContext), {
                  RTCSdpType: sd.type
                }));
                _context0.n = 2;
                return this.pcManager.setPublisherAnswer(sd);
              case 2:
                return _context0.a(2);
            }
          }, _callee0, this);
        }));
      };
      this.client.onTrickle = function(candidate, target) {
        if (!_this5.pcManager) {
          return;
        }
        _this5.log.trace("got ICE candidate from peer", Object.assign(Object.assign({}, _this5.logContext), {
          candidate,
          target
        }));
        _this5.pcManager.addIceCandidate(candidate, target);
      };
      this.client.onOffer = function(sd) {
        return __awaiter(_this5, void 0, void 0, _regenerator().m(function _callee1() {
          var answer;
          return _regenerator().w(function(_context1) {
            while (1) switch (_context1.n) {
              case 0:
                if (this.pcManager) {
                  _context1.n = 1;
                  break;
                }
                return _context1.a(2);
              case 1:
                _context1.n = 2;
                return this.pcManager.createSubscriberAnswerFromOffer(sd);
              case 2:
                answer = _context1.v;
                this.client.sendAnswer(answer);
              case 3:
                return _context1.a(2);
            }
          }, _callee1, this);
        }));
      };
      this.client.onLocalTrackPublished = function(res) {
        var _a;
        _this5.log.debug("received trackPublishedResponse", Object.assign(Object.assign({}, _this5.logContext), {
          cid: res.cid,
          track: (_a = res.track) === null || _a === void 0 ? void 0 : _a.sid
        }));
        if (!_this5.pendingTrackResolvers[res.cid]) {
          _this5.log.error("missing track resolver for ".concat(res.cid), Object.assign(Object.assign({}, _this5.logContext), {
            cid: res.cid
          }));
          return;
        }
        var resolve = _this5.pendingTrackResolvers[res.cid].resolve;
        delete _this5.pendingTrackResolvers[res.cid];
        resolve(res.track);
      };
      this.client.onLocalTrackUnpublished = function(response) {
        _this5.emit(EngineEvent.LocalTrackUnpublished, response);
      };
      this.client.onLocalTrackSubscribed = function(trackSid) {
        _this5.emit(EngineEvent.LocalTrackSubscribed, trackSid);
      };
      this.client.onTokenRefresh = function(token) {
        _this5.token = token;
        sessionStorage.setItem("token", _this5.token);
      };
      this.client.onRemoteMuteChanged = function(trackSid, muted) {
        _this5.emit(EngineEvent.RemoteMute, trackSid, muted);
      };
      this.client.onSubscribedQualityUpdate = function(update) {
        _this5.emit(EngineEvent.SubscribedQualityUpdate, update);
      };
      this.client.onClose = function() {
        _this5.handleDisconnect("signal", ReconnectReason.RR_SIGNAL_DISCONNECTED);
      };
      this.client.onLeave = function(leave) {
        _this5.log.debug("client leave request", Object.assign(Object.assign({}, _this5.logContext), {
          reason: leave === null || leave === void 0 ? void 0 : leave.reason
        }));
        sessionStorage.removeItem("token");
        sessionStorage.removeItem("isAudioMuted");
        sessionStorage.removeItem("isVideoMuted");
        if (leave.regions && _this5.regionUrlProvider) {
          _this5.log.debug("updating regions", _this5.logContext);
          _this5.regionUrlProvider.setServerReportedRegions(leave.regions);
        }
        switch (leave.action) {
          case LeaveRequest_Action.DISCONNECT:
            _this5.emit(EngineEvent.Disconnected, leave === null || leave === void 0 ? void 0 : leave.reason);
            _this5.close();
            break;
          case LeaveRequest_Action.RECONNECT:
            _this5.fullReconnectOnNext = true;
            _this5.handleDisconnect(leaveReconnect);
            break;
          case LeaveRequest_Action.RESUME:
            _this5.handleDisconnect(leaveReconnect);
        }
      };
    }
  }, {
    key: "makeRTCConfiguration",
    value: function makeRTCConfiguration(serverResponse) {
      var _a;
      var rtcConfig = Object.assign({}, this.rtcConfig);
      if ((_a = this.signalOpts) === null || _a === void 0 ? void 0 : _a.e2eeEnabled) {
        this.log.debug("E2EE - setting up transports with insertable streams", this.logContext);
        rtcConfig.encodedInsertableStreams = true;
      }
      if (serverResponse.iceServers && !rtcConfig.iceServers) {
        var rtcIceServers = [];
        serverResponse.iceServers.forEach(function(iceServer) {
          var rtcIceServer = {
            urls: iceServer.urls
          };
          if (iceServer.username) rtcIceServer.username = iceServer.username;
          if (iceServer.credential) {
            rtcIceServer.credential = iceServer.credential;
          }
          rtcIceServers.push(rtcIceServer);
        });
        rtcConfig.iceServers = rtcIceServers;
      }
      if (serverResponse.clientConfiguration && serverResponse.clientConfiguration.forceRelay === ClientConfigSetting.ENABLED) {
        rtcConfig.iceTransportPolicy = "relay";
      }
      rtcConfig.sdpSemantics = "unified-plan";
      rtcConfig.continualGatheringPolicy = "gather_continually";
      return rtcConfig;
    }
  }, {
    key: "createDataChannels",
    value: function createDataChannels() {
      if (!this.pcManager) {
        return;
      }
      if (this.lossyDC) {
        this.lossyDC.onmessage = null;
        this.lossyDC.onerror = null;
      }
      if (this.reliableDC) {
        this.reliableDC.onmessage = null;
        this.reliableDC.onerror = null;
      }
      this.lossyDC = this.pcManager.createPublisherDataChannel(lossyDataChannel, {
        // will drop older packets that arrive
        ordered: true,
        maxRetransmits: 0
      });
      this.reliableDC = this.pcManager.createPublisherDataChannel(reliableDataChannel, {
        ordered: true
      });
      this.lossyDC.onmessage = this.handleDataMessage;
      this.reliableDC.onmessage = this.handleDataMessage;
      this.lossyDC.onerror = this.handleDataError;
      this.reliableDC.onerror = this.handleDataError;
      this.lossyDC.bufferedAmountLowThreshold = 65535;
      this.reliableDC.bufferedAmountLowThreshold = 65535;
      this.lossyDC.onbufferedamountlow = this.handleBufferedAmountLow;
      this.reliableDC.onbufferedamountlow = this.handleBufferedAmountLow;
    }
  }, {
    key: "createSender",
    value: function createSender(track, opts, encodings) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee10() {
        var sender, _sender;
        return _regenerator().w(function(_context10) {
          while (1) switch (_context10.n) {
            case 0:
              if (!supportsTransceiver()) {
                _context10.n = 2;
                break;
              }
              _context10.n = 1;
              return this.createTransceiverRTCRtpSender(track, opts, encodings);
            case 1:
              sender = _context10.v;
              return _context10.a(2, sender);
            case 2:
              if (!supportsAddTrack()) {
                _context10.n = 4;
                break;
              }
              this.log.warn("using add-track fallback", this.logContext);
              _context10.n = 3;
              return this.createRTCRtpSender(track.mediaStreamTrack);
            case 3:
              _sender = _context10.v;
              return _context10.a(2, _sender);
            case 4:
              throw new UnexpectedConnectionState("Required webRTC APIs not supported on this device");
            case 5:
              return _context10.a(2);
          }
        }, _callee10, this);
      }));
    }
  }, {
    key: "createSimulcastSender",
    value: function createSimulcastSender(track, simulcastTrack, opts, encodings) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee11() {
        return _regenerator().w(function(_context11) {
          while (1) switch (_context11.n) {
            case 0:
              if (!supportsTransceiver()) {
                _context11.n = 1;
                break;
              }
              return _context11.a(2, this.createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings));
            case 1:
              if (!supportsAddTrack()) {
                _context11.n = 2;
                break;
              }
              this.log.debug("using add-track fallback", this.logContext);
              return _context11.a(2, this.createRTCRtpSender(track.mediaStreamTrack));
            case 2:
              throw new UnexpectedConnectionState("Cannot stream on this device");
            case 3:
              return _context11.a(2);
          }
        }, _callee11, this);
      }));
    }
  }, {
    key: "createTransceiverRTCRtpSender",
    value: function createTransceiverRTCRtpSender(track, opts, encodings) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee12() {
        var streams, transceiverInit, transceiver;
        return _regenerator().w(function(_context12) {
          while (1) switch (_context12.n) {
            case 0:
              if (this.pcManager) {
                _context12.n = 1;
                break;
              }
              throw new UnexpectedConnectionState("publisher is closed");
            case 1:
              streams = [];
              if (track.mediaStream) {
                streams.push(track.mediaStream);
              }
              if (track instanceof LocalVideoTrack) {
                track.codec = opts.videoCodec;
              }
              transceiverInit = {
                direction: "sendonly",
                streams
              };
              if (encodings) {
                transceiverInit.sendEncodings = encodings;
              }
              _context12.n = 2;
              return this.pcManager.addPublisherTransceiver(track.mediaStreamTrack, transceiverInit);
            case 2:
              transceiver = _context12.v;
              return _context12.a(2, transceiver.sender);
          }
        }, _callee12, this);
      }));
    }
  }, {
    key: "createSimulcastTransceiverSender",
    value: function createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee13() {
        var transceiverInit, transceiver;
        return _regenerator().w(function(_context13) {
          while (1) switch (_context13.n) {
            case 0:
              if (this.pcManager) {
                _context13.n = 1;
                break;
              }
              throw new UnexpectedConnectionState("publisher is closed");
            case 1:
              transceiverInit = {
                direction: "sendonly"
              };
              if (encodings) {
                transceiverInit.sendEncodings = encodings;
              }
              _context13.n = 2;
              return this.pcManager.addPublisherTransceiver(simulcastTrack.mediaStreamTrack, transceiverInit);
            case 2:
              transceiver = _context13.v;
              if (opts.videoCodec) {
                _context13.n = 3;
                break;
              }
              return _context13.a(2);
            case 3:
              track.setSimulcastTrackSender(opts.videoCodec, transceiver.sender);
              return _context13.a(2, transceiver.sender);
          }
        }, _callee13, this);
      }));
    }
  }, {
    key: "createRTCRtpSender",
    value: function createRTCRtpSender(track) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee14() {
        return _regenerator().w(function(_context14) {
          while (1) switch (_context14.n) {
            case 0:
              if (this.pcManager) {
                _context14.n = 1;
                break;
              }
              throw new UnexpectedConnectionState("publisher is closed");
            case 1:
              return _context14.a(2, this.pcManager.addPublisherTrack(track));
          }
        }, _callee14, this);
      }));
    }
  }, {
    key: "attemptReconnect",
    value: function attemptReconnect(reason) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee15() {
        var _a, _b, _c, recoverable, _t2;
        return _regenerator().w(function(_context15) {
          while (1) switch (_context15.n) {
            case 0:
              if (!this._isClosed) {
                _context15.n = 1;
                break;
              }
              return _context15.a(2);
            case 1:
              if (!this.attemptingReconnect) {
                _context15.n = 2;
                break;
              }
              livekitLogger.warn("already attempting reconnect, returning early", this.logContext);
              return _context15.a(2);
            case 2:
              if (((_a = this.clientConfiguration) === null || _a === void 0 ? void 0 : _a.resumeConnection) === ClientConfigSetting.DISABLED || // signaling state could change to closed due to hardware sleep
              // those connections cannot be resumed
              ((_c = (_b = this.pcManager) === null || _b === void 0 ? void 0 : _b.currentState) !== null && _c !== void 0 ? _c : PCTransportState.NEW) === PCTransportState.NEW) {
                this.fullReconnectOnNext = true;
              }
              _context15.p = 3;
              this.attemptingReconnect = true;
              if (!this.fullReconnectOnNext) {
                _context15.n = 5;
                break;
              }
              _context15.n = 4;
              return this.restartConnection();
            case 4:
              _context15.n = 6;
              break;
            case 5:
              _context15.n = 6;
              return this.resumeConnection(reason);
            case 6:
              this.clearPendingReconnect();
              this.fullReconnectOnNext = false;
              _context15.n = 9;
              break;
            case 7:
              _context15.p = 7;
              _t2 = _context15.v;
              this.reconnectAttempts += 1;
              recoverable = true;
              if (_t2 instanceof UnexpectedConnectionState) {
                this.log.debug("received unrecoverable error", Object.assign(Object.assign({}, this.logContext), {
                  error: _t2
                }));
                recoverable = false;
              } else if (!(_t2 instanceof SignalReconnectError)) {
                this.fullReconnectOnNext = true;
              }
              if (!recoverable) {
                _context15.n = 8;
                break;
              }
              this.handleDisconnect("reconnect", ReconnectReason.RR_UNKNOWN);
              _context15.n = 9;
              break;
            case 8:
              this.log.info("could not recover connection after ".concat(this.reconnectAttempts, " attempts, ").concat(Date.now() - this.reconnectStart, "ms. giving up"), this.logContext);
              this.emit(EngineEvent.Disconnected);
              _context15.n = 9;
              return this.close();
            case 9:
              _context15.p = 9;
              this.attemptingReconnect = false;
              return _context15.f(9);
            case 10:
              return _context15.a(2);
          }
        }, _callee15, this, [[3, 7, 9, 10]]);
      }));
    }
  }, {
    key: "getNextRetryDelay",
    value: function getNextRetryDelay(context) {
      try {
        return this.reconnectPolicy.nextRetryDelayInMs(context);
      } catch (e) {
        this.log.warn("encountered error in reconnect policy", Object.assign(Object.assign({}, this.logContext), {
          error: e
        }));
      }
      return null;
    }
  }, {
    key: "restartConnection",
    value: function restartConnection(regionUrl) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee16() {
        var _a, _b, _c, joinResponse, rightNow, nextRegionUrl, _t3, _t4;
        return _regenerator().w(function(_context16) {
          while (1) switch (_context16.n) {
            case 0:
              _context16.p = 0;
              if (!(!this.url || !this.token)) {
                _context16.n = 1;
                break;
              }
              throw new UnexpectedConnectionState("could not reconnect, url or token not saved");
            case 1:
              this.log.info("reconnecting, attempt: ".concat(this.reconnectAttempts), this.logContext);
              this.emit(EngineEvent.Restarting);
              if (this.client.isDisconnected) {
                _context16.n = 2;
                break;
              }
              _context16.n = 2;
              return this.client.sendLeave();
            case 2:
              _context16.n = 3;
              return this.cleanupPeerConnections();
            case 3:
              _context16.n = 4;
              return this.cleanupClient();
            case 4:
              _context16.p = 4;
              if (this.signalOpts) {
                _context16.n = 5;
                break;
              }
              this.log.warn("attempted connection restart, without signal options present", this.logContext);
              throw new SignalReconnectError();
            case 5:
              _context16.n = 6;
              return this.join(regionUrl !== null && regionUrl !== void 0 ? regionUrl : this.url, this.token, this.signalOpts);
            case 6:
              joinResponse = _context16.v;
              _context16.n = 9;
              break;
            case 7:
              _context16.p = 7;
              _t3 = _context16.v;
              if (!(_t3 instanceof ConnectionError && _t3.reason === 0)) {
                _context16.n = 8;
                break;
              }
              throw new UnexpectedConnectionState("could not reconnect, token might be expired");
            case 8:
              throw new SignalReconnectError();
            case 9:
              if (!this.shouldFailNext) {
                _context16.n = 10;
                break;
              }
              this.shouldFailNext = false;
              throw new Error("simulated failure");
            case 10:
              this.client.setReconnected();
              this.emit(EngineEvent.SignalRestarted, joinResponse);
              _context16.n = 11;
              return this.waitForPCReconnected();
            case 11:
              if (!(this.client.currentState !== SignalConnectionState.CONNECTED)) {
                _context16.n = 12;
                break;
              }
              throw new SignalReconnectError("Signal connection got severed during reconnect");
            case 12:
              this.client.setReconnected();
              this.emit(EngineEvent.SignalRestarted, joinResponse);
              (_a = this.regionUrlProvider) === null || _a === void 0 ? void 0 : _a.resetAttempts();
              this.emit(EngineEvent.Restarted);
              rightNow = Date.now();
              if (this.disconnectStartTimePrimary == 0) {
                this.disconnectStartTimePrimary = rightNow;
              }
              if (this.disconnectStartTimeSecondary == 0) {
                this.disconnectStartTimeSecondary = rightNow;
              }
              this.emit(EngineEvent.PrimaryDelay, rightNow - this.disconnectStartTimePrimary);
              this.emit(EngineEvent.SecondaryDelay, rightNow - this.disconnectStartTimeSecondary);
              this.disconnectStartTimePrimary = this.disconnectStartTimeSecondary = 0;
              _context16.n = 17;
              break;
            case 13:
              _context16.p = 13;
              _t4 = _context16.v;
              _context16.n = 14;
              return (_b = this.regionUrlProvider) === null || _b === void 0 ? void 0 : _b.getNextBestRegionUrl();
            case 14:
              nextRegionUrl = _context16.v;
              if (!nextRegionUrl) {
                _context16.n = 16;
                break;
              }
              _context16.n = 15;
              return this.restartConnection(nextRegionUrl);
            case 15:
              return _context16.a(2);
            case 16:
              (_c = this.regionUrlProvider) === null || _c === void 0 ? void 0 : _c.resetAttempts();
              throw _t4;
            case 17:
              return _context16.a(2);
          }
        }, _callee16, this, [[4, 7], [0, 13]]);
      }));
    }
  }, {
    key: "resumeConnection",
    value: function resumeConnection(reason) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee17() {
        var _a, res, message, rtcConfig, _t5;
        return _regenerator().w(function(_context17) {
          while (1) switch (_context17.n) {
            case 0:
              if (!(!this.url || !this.token)) {
                _context17.n = 1;
                break;
              }
              throw new UnexpectedConnectionState("could not reconnect, url or token not saved");
            case 1:
              if (this.pcManager) {
                _context17.n = 2;
                break;
              }
              throw new UnexpectedConnectionState("publisher and subscriber connections unset");
            case 2:
              this.log.info("resuming signal connection, attempt ".concat(this.reconnectAttempts), this.logContext);
              this.emit(EngineEvent.Resuming);
              _context17.p = 3;
              this.setupSignalClientCallbacks();
              _context17.n = 4;
              return this.client.reconnect(this.url, this.token, this.participantSid, reason);
            case 4:
              res = _context17.v;
              _context17.n = 8;
              break;
            case 5:
              _context17.p = 5;
              _t5 = _context17.v;
              message = "";
              if (_t5 instanceof Error) {
                message = _t5.message;
                this.log.error(_t5.message, Object.assign(Object.assign({}, this.logContext), {
                  error: _t5
                }));
              }
              if (!(_t5 instanceof ConnectionError && _t5.reason === 0)) {
                _context17.n = 6;
                break;
              }
              throw new UnexpectedConnectionState("could not reconnect, token might be expired");
            case 6:
              if (!(_t5 instanceof ConnectionError && _t5.reason === 4)) {
                _context17.n = 7;
                break;
              }
              throw _t5;
            case 7:
              throw new SignalReconnectError(message);
            case 8:
              this.emit(EngineEvent.SignalResumed);
              if (res) {
                rtcConfig = this.makeRTCConfiguration(res);
                this.pcManager.updateConfiguration(rtcConfig);
              } else {
                this.log.warn("Did not receive reconnect response", this.logContext);
              }
              if (!this.shouldFailNext) {
                _context17.n = 9;
                break;
              }
              this.shouldFailNext = false;
              throw new Error("simulated failure");
            case 9:
              _context17.n = 10;
              return this.pcManager.triggerIceRestart();
            case 10:
              _context17.n = 11;
              return this.waitForPCReconnected();
            case 11:
              if (!(this.client.currentState !== SignalConnectionState.CONNECTED)) {
                _context17.n = 12;
                break;
              }
              throw new SignalReconnectError("Signal connection got severed during reconnect");
            case 12:
              if (this.hasPublished) {
                if ((this.disconnectStartTimePrimary == 0 || this.disconnectStartTimeSecondary == 0) && this.firstReconnectAttempt) {
                  this.disconnectStartTimePrimary = this.disconnectStartTimeSecondary = Date.now();
                  this.firstReconnectAttempt = false;
                }
              }
              this.client.setReconnected();
              if (((_a = this.reliableDC) === null || _a === void 0 ? void 0 : _a.readyState) === "open" && this.reliableDC.id === null) {
                this.createDataChannels();
              }
              this.emit(EngineEvent.Resumed);
            case 13:
              return _context17.a(2);
          }
        }, _callee17, this, [[3, 5]]);
      }));
    }
  }, {
    key: "waitForPCInitialConnection",
    value: function waitForPCInitialConnection(timeout, abortController) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee18() {
        return _regenerator().w(function(_context18) {
          while (1) switch (_context18.n) {
            case 0:
              if (this.pcManager) {
                _context18.n = 1;
                break;
              }
              throw new UnexpectedConnectionState("PC manager is closed");
            case 1:
              _context18.n = 2;
              return this.pcManager.ensurePCTransportConnection(abortController, timeout);
            case 2:
              return _context18.a(2);
          }
        }, _callee18, this);
      }));
    }
  }, {
    key: "waitForPCReconnected",
    value: function waitForPCReconnected() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee19() {
        var _a, startTime, now, rightNow, _t6;
        return _regenerator().w(function(_context19) {
          while (1) switch (_context19.n) {
            case 0:
              this.pcState = PCState.Reconnecting;
              this.log.debug("waiting for peer connection to reconnect", this.logContext);
              _context19.p = 1;
              _context19.n = 2;
              return sleep(minReconnectWait);
            case 2:
              if (this.pcManager) {
                _context19.n = 3;
                break;
              }
              throw new UnexpectedConnectionState("PC manager is closed");
            case 3:
              _context19.n = 4;
              return this.pcManager.ensurePCTransportConnection(void 0, this.peerConnectionTimeout);
            case 4:
              startTime = Date.now();
              now = startTime;
              this.pcState = PCState.Reconnecting;
            case 5:
              if (!(now - startTime < this.peerConnectionTimeout)) {
                _context19.n = 8;
                break;
              }
              if (!(this.primaryPC === void 0)) {
                _context19.n = 6;
                break;
              }
              return _context19.a(3, 8);
            case 6:
              if (
                // on Safari, we don't get a connectionstatechanged event during ICE restart
                // this means we'd have to check its status manually and update address
                // manually
                now - startTime > minReconnectWait && ((_a = this.primaryPC) === null || _a === void 0 ? void 0 : _a.connectionState) === "connected"
              ) {
                rightNow = Date.now();
                if (this.disconnectStartTimePrimary == 0) {
                  this.disconnectStartTimePrimary = rightNow;
                }
                if (this.disconnectStartTimeSecondary == 0) {
                  this.disconnectStartTimeSecondary = rightNow;
                }
                this.emit(EngineEvent.PrimaryDelay, rightNow - this.disconnectStartTimePrimary);
                this.emit(EngineEvent.SecondaryDelay, rightNow - this.disconnectStartTimeSecondary);
                this.disconnectStartTimePrimary = 0;
                this.disconnectStartTimeSecondary = 0;
                this.firstReconnectAttempt = true;
              }
            case 7:
              _context19.n = 5;
              break;
            case 8:
              _context19.n = 10;
              break;
            case 9:
              _context19.p = 9;
              _t6 = _context19.v;
              this.pcState = PCState.Disconnected;
              throw new ConnectionError(
                "could not establish PC connection, ".concat(_t6.message),
                2
                /* ConnectionErrorReason.InternalError */
              );
            case 10:
              return _context19.a(2);
          }
        }, _callee19, this, [[1, 9]]);
      }));
    }
    /* @internal */
  }, {
    key: "sendDataPacket",
    value: function sendDataPacket(packet, kind) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee20() {
        var msg, dc;
        return _regenerator().w(function(_context20) {
          while (1) switch (_context20.n) {
            case 0:
              msg = packet.toBinary();
              _context20.n = 1;
              return this.ensurePublisherConnected(kind);
            case 1:
              dc = this.dataChannelForKind(kind);
              if (dc) {
                dc.send(msg);
              }
              this.updateAndEmitDCBufferStatus(kind);
            case 2:
              return _context20.a(2);
          }
        }, _callee20, this);
      }));
    }
    /**
     * @internal
     */
  }, {
    key: "ensureDataTransportConnected",
    value: function ensureDataTransportConnected(kind_1) {
      return __awaiter(this, arguments, void 0, function(kind) {
        var _this6 = this;
        var subscriber = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.subscriberPrimary;
        return _regenerator().m(function _callee21() {
          var _a, transport, transportName, needNegotiation, targetChannel, endTime;
          return _regenerator().w(function(_context21) {
            while (1) switch (_context21.n) {
              case 0:
                if (_this6.pcManager) {
                  _context21.n = 1;
                  break;
                }
                throw new UnexpectedConnectionState("PC manager is closed");
              case 1:
                transport = subscriber ? _this6.pcManager.subscriber : _this6.pcManager.publisher;
                transportName = subscriber ? "Subscriber" : "Publisher";
                if (transport) {
                  _context21.n = 2;
                  break;
                }
                throw new ConnectionError(
                  "".concat(transportName, " connection not set"),
                  2
                  /* ConnectionErrorReason.InternalError */
                );
              case 2:
                needNegotiation = false;
                if (!subscriber && !_this6.dataChannelForKind(kind, subscriber)) {
                  _this6.createDataChannels();
                  needNegotiation = true;
                }
                if (!needNegotiation && !subscriber && !_this6.pcManager.publisher.isICEConnected && _this6.pcManager.publisher.getICEConnectionState() !== "checking") {
                  needNegotiation = true;
                }
                if (needNegotiation) {
                  _this6.negotiate();
                }
                targetChannel = _this6.dataChannelForKind(kind, subscriber);
                if (!((targetChannel === null || targetChannel === void 0 ? void 0 : targetChannel.readyState) === "open")) {
                  _context21.n = 3;
                  break;
                }
                return _context21.a(2);
              case 3:
                endTime = (/* @__PURE__ */ new Date()).getTime() + _this6.peerConnectionTimeout;
              case 4:
                if (!((/* @__PURE__ */ new Date()).getTime() < endTime)) {
                  _context21.n = 7;
                  break;
                }
                if (!(transport.isICEConnected && ((_a = _this6.dataChannelForKind(kind, subscriber)) === null || _a === void 0 ? void 0 : _a.readyState) === "open")) {
                  _context21.n = 5;
                  break;
                }
                return _context21.a(2);
              case 5:
                _context21.n = 6;
                return sleep(50);
              case 6:
                _context21.n = 4;
                break;
              case 7:
                throw new ConnectionError(
                  "could not establish ".concat(transportName, " connection, state: ").concat(transport.getICEConnectionState()),
                  2
                  /* ConnectionErrorReason.InternalError */
                );
              case 8:
                return _context21.a(2);
            }
          }, _callee21);
        })();
      });
    }
  }, {
    key: "ensurePublisherConnected",
    value: function ensurePublisherConnected(kind) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee22() {
        return _regenerator().w(function(_context22) {
          while (1) switch (_context22.n) {
            case 0:
              if (!this.publisherConnectionPromise) {
                this.publisherConnectionPromise = this.ensureDataTransportConnected(kind, false);
              }
              _context22.n = 1;
              return this.publisherConnectionPromise;
            case 1:
              return _context22.a(2);
          }
        }, _callee22, this);
      }));
    }
    /* @internal */
  }, {
    key: "verifyTransport",
    value: function verifyTransport() {
      if (!this.pcManager) {
        return false;
      }
      if (this.pcManager.currentState !== PCTransportState.CONNECTED) {
        return false;
      }
      if (!this.client.ws || this.client.ws.readyState === WebSocket.CLOSED) {
        return false;
      }
      return true;
    }
    /** @internal */
  }, {
    key: "negotiate",
    value: function negotiate() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee24() {
        var _this7 = this;
        return _regenerator().w(function(_context24) {
          while (1) switch (_context24.n) {
            case 0:
              return _context24.a(2, new Promise(function(resolve, reject) {
                return __awaiter(_this7, void 0, void 0, _regenerator().m(function _callee23() {
                  var _this8 = this;
                  var abortController, handleClosed, _t7;
                  return _regenerator().w(function(_context23) {
                    while (1) switch (_context23.n) {
                      case 0:
                        if (this.pcManager) {
                          _context23.n = 1;
                          break;
                        }
                        reject(new NegotiationError("PC manager is closed"));
                        return _context23.a(2);
                      case 1:
                        this.pcManager.requirePublisher();
                        if (this.pcManager.publisher.getTransceivers().length == 0 && !this.lossyDC && !this.reliableDC) {
                          this.createDataChannels();
                        }
                        abortController = new AbortController();
                        handleClosed = function handleClosed2() {
                          abortController.abort();
                          _this8.log.debug("engine disconnected while negotiation was ongoing", _this8.logContext);
                          resolve();
                          return;
                        };
                        if (this.isClosed) {
                          reject("cannot negotiate on closed engine");
                        }
                        this.on(EngineEvent.Closing, handleClosed);
                        this.pcManager.publisher.once(PCEvents.RTPVideoPayloadTypes, function(rtpTypes) {
                          var rtpMap = /* @__PURE__ */ new Map();
                          rtpTypes.forEach(function(rtp) {
                            var codec = rtp.codec.toLowerCase();
                            if (isVideoCodec(codec)) {
                              rtpMap.set(rtp.payload, codec);
                            }
                          });
                          _this8.emit(EngineEvent.RTPVideoMapUpdate, rtpMap);
                        });
                        _context23.p = 2;
                        _context23.n = 3;
                        return this.pcManager.negotiate(abortController);
                      case 3:
                        resolve();
                        _context23.n = 5;
                        break;
                      case 4:
                        _context23.p = 4;
                        _t7 = _context23.v;
                        if (_t7 instanceof NegotiationError) {
                          this.fullReconnectOnNext = true;
                        }
                        this.handleDisconnect("negotiation", ReconnectReason.RR_UNKNOWN);
                        reject(_t7);
                      case 5:
                        _context23.p = 5;
                        this.off(EngineEvent.Closing, handleClosed);
                        return _context23.f(5);
                      case 6:
                        return _context23.a(2);
                    }
                  }, _callee23, this, [[2, 4, 5, 6]]);
                }));
              }));
          }
        }, _callee24);
      }));
    }
  }, {
    key: "dataChannelForKind",
    value: function dataChannelForKind(kind, sub) {
      if (!sub) {
        if (kind === DataPacket_Kind.LOSSY) {
          return this.lossyDC;
        }
        if (kind === DataPacket_Kind.RELIABLE) {
          return this.reliableDC;
        }
      } else {
        if (kind === DataPacket_Kind.LOSSY) {
          return this.lossyDCSub;
        }
        if (kind === DataPacket_Kind.RELIABLE) {
          return this.reliableDCSub;
        }
      }
    }
    /** @internal */
  }, {
    key: "sendSyncState",
    value: function sendSyncState(remoteTracks, localTracks) {
      var _a, _b;
      if (!this.pcManager) {
        this.log.warn("sync state cannot be sent without peer connection setup", this.logContext);
        return;
      }
      var previousAnswer = this.pcManager.subscriber.getLocalDescription();
      var previousOffer = this.pcManager.subscriber.getRemoteDescription();
      var autoSubscribe = (_b = (_a = this.signalOpts) === null || _a === void 0 ? void 0 : _a.autoSubscribe) !== null && _b !== void 0 ? _b : true;
      var trackSids = new Array();
      var trackSidsDisabled = new Array();
      remoteTracks.forEach(function(track) {
        if (track.isDesired !== autoSubscribe) {
          trackSids.push(track.trackSid);
        }
        if (!track.isEnabled) {
          trackSidsDisabled.push(track.trackSid);
        }
      });
      this.client.sendSyncState(new SyncState({
        answer: previousAnswer ? toProtoSessionDescription({
          sdp: previousAnswer.sdp,
          type: previousAnswer.type
        }) : void 0,
        offer: previousOffer ? toProtoSessionDescription({
          sdp: previousOffer.sdp,
          type: previousOffer.type
        }) : void 0,
        subscription: new UpdateSubscription({
          trackSids,
          subscribe: !autoSubscribe,
          participantTracks: []
        }),
        publishTracks: getTrackPublicationInfo(localTracks),
        dataChannels: this.dataChannelsInfo(),
        trackSidsDisabled
      }));
    }
    /* @internal */
  }, {
    key: "failNext",
    value: function failNext() {
      this.shouldFailNext = true;
    }
  }, {
    key: "dataChannelsInfo",
    value: function dataChannelsInfo() {
      var infos = [];
      var getInfo = function getInfo2(dc, target) {
        if ((dc === null || dc === void 0 ? void 0 : dc.id) !== void 0 && dc.id !== null) {
          infos.push(new DataChannelInfo({
            label: dc.label,
            id: dc.id,
            target
          }));
        }
      };
      getInfo(this.dataChannelForKind(DataPacket_Kind.LOSSY), SignalTarget.PUBLISHER);
      getInfo(this.dataChannelForKind(DataPacket_Kind.RELIABLE), SignalTarget.PUBLISHER);
      getInfo(this.dataChannelForKind(DataPacket_Kind.LOSSY, true), SignalTarget.SUBSCRIBER);
      getInfo(this.dataChannelForKind(DataPacket_Kind.RELIABLE, true), SignalTarget.SUBSCRIBER);
      return infos;
    }
  }, {
    key: "clearReconnectTimeout",
    value: function clearReconnectTimeout() {
      if (this.reconnectTimeout) {
        CriticalTimers.clearTimeout(this.reconnectTimeout);
      }
    }
  }, {
    key: "clearPendingReconnect",
    value: function clearPendingReconnect() {
      this.clearReconnectTimeout();
      this.reconnectAttempts = 0;
    }
  }, {
    key: "registerOnLineListener",
    value: function registerOnLineListener() {
      if (isWeb()) {
        window.addEventListener("online", this.handleBrowserOnLine);
      }
    }
  }, {
    key: "deregisterOnLineListener",
    value: function deregisterOnLineListener() {
      if (isWeb()) {
        window.removeEventListener("online", this.handleBrowserOnLine);
      }
    }
  }]);
}(eventsExports.EventEmitter);
var SignalReconnectError = function(_Error) {
  function SignalReconnectError2() {
    _classCallCheck(this, SignalReconnectError2);
    return _callSuper(this, SignalReconnectError2, arguments);
  }
  _inherits(SignalReconnectError2, _Error);
  return _createClass(SignalReconnectError2);
}(_wrapNativeSuper(Error));
function supportOptionalDatachannel(protocol) {
  return protocol !== void 0 && protocol > 13;
}
function applyUserDataCompat(newObj, oldObj) {
  var participantIdentity = newObj.participantIdentity ? newObj.participantIdentity : oldObj.participantIdentity;
  newObj.participantIdentity = participantIdentity;
  oldObj.participantIdentity = participantIdentity;
  var destinationIdentities = newObj.destinationIdentities.length !== 0 ? newObj.destinationIdentities : oldObj.destinationIdentities;
  newObj.destinationIdentities = destinationIdentities;
  oldObj.destinationIdentities = destinationIdentities;
}
var RegionUrlProvider = function() {
  function RegionUrlProvider2(url, token) {
    _classCallCheck(this, RegionUrlProvider2);
    this.lastUpdateAt = 0;
    this.settingsCacheTime = 3e3;
    this.attemptedRegions = [];
    this.serverUrl = new URL(url);
    this.token = token;
  }
  return _createClass(RegionUrlProvider2, [{
    key: "updateToken",
    value: function updateToken(token) {
      this.token = token;
    }
  }, {
    key: "isCloud",
    value: function isCloud$1() {
      return isCloud(this.serverUrl);
    }
  }, {
    key: "getServerUrl",
    value: function getServerUrl() {
      return this.serverUrl;
    }
  }, {
    key: "getNextBestRegionUrl",
    value: function getNextBestRegionUrl(abortSignal) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee() {
        var _this = this;
        var regionsLeft, nextRegion;
        return _regenerator().w(function(_context) {
          while (1) switch (_context.n) {
            case 0:
              if (this.isCloud()) {
                _context.n = 1;
                break;
              }
              throw Error("region availability is only supported for LiveKit Cloud domains");
            case 1:
              if (!(!this.regionSettings || Date.now() - this.lastUpdateAt > this.settingsCacheTime)) {
                _context.n = 3;
                break;
              }
              _context.n = 2;
              return this.fetchRegionSettings(abortSignal);
            case 2:
              this.regionSettings = _context.v;
            case 3:
              regionsLeft = this.regionSettings.regions.filter(function(region) {
                return !_this.attemptedRegions.find(function(attempted) {
                  return attempted.url === region.url;
                });
              });
              if (!(regionsLeft.length > 0)) {
                _context.n = 4;
                break;
              }
              nextRegion = regionsLeft[0];
              this.attemptedRegions.push(nextRegion);
              livekitLogger.debug("next region: ".concat(nextRegion.region));
              return _context.a(2, nextRegion.url);
            case 4:
              return _context.a(2, null);
            case 5:
              return _context.a(2);
          }
        }, _callee, this);
      }));
    }
  }, {
    key: "resetAttempts",
    value: function resetAttempts() {
      this.attemptedRegions = [];
    }
    /* @internal */
  }, {
    key: "fetchRegionSettings",
    value: function fetchRegionSettings(signal) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee2() {
        var regionSettingsResponse, regionSettings;
        return _regenerator().w(function(_context2) {
          while (1) switch (_context2.n) {
            case 0:
              _context2.n = 1;
              return fetch("".concat(getCloudConfigUrl(this.serverUrl), "/regions"), {
                headers: {
                  authorization: "Bearer ".concat(this.token)
                },
                signal
              });
            case 1:
              regionSettingsResponse = _context2.v;
              if (!regionSettingsResponse.ok) {
                _context2.n = 3;
                break;
              }
              _context2.n = 2;
              return regionSettingsResponse.json();
            case 2:
              regionSettings = _context2.v;
              this.lastUpdateAt = Date.now();
              return _context2.a(2, regionSettings);
            case 3:
              throw new ConnectionError("Could not fetch region settings: ".concat(regionSettingsResponse.statusText), regionSettingsResponse.status === 401 ? 0 : 2, regionSettingsResponse.status);
            case 4:
              return _context2.a(2);
          }
        }, _callee2, this);
      }));
    }
  }, {
    key: "setServerReportedRegions",
    value: function setServerReportedRegions(regions) {
      this.regionSettings = regions;
      this.lastUpdateAt = Date.now();
    }
  }]);
}();
function getCloudConfigUrl(serverUrl) {
  return "".concat(serverUrl.protocol.replace("ws", "http"), "//").concat(serverUrl.host, "/settings");
}
var RpcError = function(_Error) {
  function RpcError2(code, message, data) {
    var _this;
    _classCallCheck(this, RpcError2);
    _this = _callSuper(this, RpcError2, [message]);
    _this.code = code;
    _this.message = truncateBytes(message, RpcError2.MAX_MESSAGE_BYTES);
    _this.data = data ? truncateBytes(data, RpcError2.MAX_DATA_BYTES) : void 0;
    return _this;
  }
  _inherits(RpcError2, _Error);
  return _createClass(RpcError2, [{
    key: "toProto",
    value: (
      /**
       * @internal
       */
      function toProto() {
        return new RpcError$1({
          code: this.code,
          message: this.message,
          data: this.data
        });
      }
    )
    /**
     * Creates an error object from the code, with an auto-populated message.
     *
     * @internal
     */
  }], [{
    key: "fromProto",
    value: function fromProto(proto) {
      return new RpcError2(proto.code, proto.message, proto.data);
    }
  }, {
    key: "builtIn",
    value: function builtIn(key, data) {
      return new RpcError2(RpcError2.ErrorCode[key], RpcError2.ErrorMessage[key], data);
    }
  }]);
}(_wrapNativeSuper(Error));
RpcError.MAX_MESSAGE_BYTES = 256;
RpcError.MAX_DATA_BYTES = 15360;
RpcError.ErrorCode = {
  APPLICATION_ERROR: 1500,
  CONNECTION_TIMEOUT: 1501,
  RESPONSE_TIMEOUT: 1502,
  RECIPIENT_DISCONNECTED: 1503,
  RESPONSE_PAYLOAD_TOO_LARGE: 1504,
  SEND_FAILED: 1505,
  UNSUPPORTED_METHOD: 1400,
  RECIPIENT_NOT_FOUND: 1401,
  REQUEST_PAYLOAD_TOO_LARGE: 1402,
  UNSUPPORTED_SERVER: 1403
};
RpcError.ErrorMessage = {
  APPLICATION_ERROR: "Application error in method handler",
  CONNECTION_TIMEOUT: "Connection timeout",
  RESPONSE_TIMEOUT: "Response timeout",
  RECIPIENT_DISCONNECTED: "Recipient disconnected",
  RESPONSE_PAYLOAD_TOO_LARGE: "Response payload too large",
  SEND_FAILED: "Failed to send",
  UNSUPPORTED_METHOD: "Method not supported at destination",
  RECIPIENT_NOT_FOUND: "Recipient not found",
  REQUEST_PAYLOAD_TOO_LARGE: "Request payload too large",
  UNSUPPORTED_SERVER: "RPC not supported by server"
};
var MAX_PAYLOAD_BYTES = 15360;
function byteLength(str) {
  var encoder = new TextEncoder();
  return encoder.encode(str).length;
}
function truncateBytes(str, maxBytes) {
  if (byteLength(str) <= maxBytes) {
    return str;
  }
  var low = 0;
  var high = str.length;
  var encoder = new TextEncoder();
  while (low < high) {
    var mid = Math.floor((low + high + 1) / 2);
    if (encoder.encode(str.slice(0, mid)).length <= maxBytes) {
      low = mid;
    } else {
      high = mid - 1;
    }
  }
  return str.slice(0, low);
}
var RemoteTrack = function(_Track) {
  function RemoteTrack2(mediaTrack, sid, kind, receiver, loggerOptions) {
    var _this;
    _classCallCheck(this, RemoteTrack2);
    _this = _callSuper(this, RemoteTrack2, [mediaTrack, kind, loggerOptions]);
    _this.sid = sid;
    _this.receiver = receiver;
    return _this;
  }
  _inherits(RemoteTrack2, _Track);
  return _createClass(RemoteTrack2, [{
    key: "setMuted",
    value: function setMuted(muted) {
      if (this.isMuted !== muted) {
        this.isMuted = muted;
        this._mediaStreamTrack.enabled = !muted;
        this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);
      }
    }
    /** @internal */
  }, {
    key: "setMediaStream",
    value: function setMediaStream(stream) {
      var _this2 = this;
      this.mediaStream = stream;
      var _onRemoveTrack = function onRemoveTrack(event) {
        if (event.track === _this2._mediaStreamTrack) {
          stream.removeEventListener("removetrack", _onRemoveTrack);
          if (_this2.receiver && "playoutDelayHint" in _this2.receiver) {
            _this2.receiver.playoutDelayHint = void 0;
          }
          _this2.receiver = void 0;
          _this2._currentBitrate = 0;
          _this2.emit(TrackEvent.Ended, _this2);
        }
      };
      stream.addEventListener("removetrack", _onRemoveTrack);
    }
  }, {
    key: "start",
    value: function start() {
      this.startMonitor();
      _superPropGet(RemoteTrack2, "enable", this, 3)([]);
    }
  }, {
    key: "stop",
    value: function stop() {
      this.stopMonitor();
      _superPropGet(RemoteTrack2, "disable", this, 3)([]);
    }
    /**
     * Gets the RTCStatsReport for the RemoteTrack's underlying RTCRtpReceiver
     * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport
     *
     * @returns Promise<RTCStatsReport> | undefined
     */
  }, {
    key: "getRTCStatsReport",
    value: function getRTCStatsReport() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee() {
        var _a, statsReport;
        return _regenerator().w(function(_context) {
          while (1) switch (_context.n) {
            case 0:
              if ((_a = this.receiver) === null || _a === void 0 ? void 0 : _a.getStats) {
                _context.n = 1;
                break;
              }
              return _context.a(2);
            case 1:
              _context.n = 2;
              return this.receiver.getStats();
            case 2:
              statsReport = _context.v;
              return _context.a(2, statsReport);
          }
        }, _callee, this);
      }));
    }
    /**
    * Allows to set a playout delay (in seconds) for this track.
    * A higher value allows for more buffering of the track in the browser
    * and will result in a delay of media being played back of `delayInSeconds`
    */
  }, {
    key: "setPlayoutDelay",
    value: function setPlayoutDelay(delayInSeconds) {
      if (this.receiver) {
        if ("playoutDelayHint" in this.receiver) {
          this.receiver.playoutDelayHint = delayInSeconds;
        } else {
          this.log.warn("Playout delay not supported in this browser");
        }
      } else {
        this.log.warn("Cannot set playout delay, track already ended");
      }
    }
    /**
     * Returns the current playout delay (in seconds) of this track.
     */
  }, {
    key: "getPlayoutDelay",
    value: function getPlayoutDelay() {
      if (this.receiver) {
        if ("playoutDelayHint" in this.receiver) {
          return this.receiver.playoutDelayHint;
        } else {
          this.log.warn("Playout delay not supported in this browser");
        }
      } else {
        this.log.warn("Cannot get playout delay, track already ended");
      }
      return 0;
    }
    /* @internal */
  }, {
    key: "startMonitor",
    value: function startMonitor() {
      var _this3 = this;
      if (!this.monitorInterval) {
        this.monitorInterval = setInterval(function() {
          return _this3.monitorReceiver();
        }, monitorFrequency);
      }
      if (supportsSynchronizationSources()) {
        this.registerTimeSyncUpdate();
      }
    }
  }, {
    key: "registerTimeSyncUpdate",
    value: function registerTimeSyncUpdate() {
      var _this4 = this;
      var _loop = function loop() {
        var _a;
        _this4.timeSyncHandle = requestAnimationFrame(function() {
          return _loop();
        });
        var sources = (_a = _this4.receiver) === null || _a === void 0 ? void 0 : _a.getSynchronizationSources()[0];
        if (sources) {
          var timestamp = sources.timestamp, rtpTimestamp = sources.rtpTimestamp;
          if (rtpTimestamp && _this4.rtpTimestamp !== rtpTimestamp) {
            _this4.emit(TrackEvent.TimeSyncUpdate, {
              timestamp,
              rtpTimestamp
            });
            _this4.rtpTimestamp = rtpTimestamp;
          }
        }
      };
      _loop();
    }
  }]);
}(Track);
var RemoteAudioTrack = function(_RemoteTrack) {
  function RemoteAudioTrack2(mediaTrack, sid, receiver, audioContext, audioOutput, loggerOptions) {
    var _this;
    _classCallCheck(this, RemoteAudioTrack2);
    _this = _callSuper(this, RemoteAudioTrack2, [mediaTrack, sid, Track.Kind.Audio, receiver, loggerOptions]);
    _this.monitorReceiver = function() {
      return __awaiter(_this, void 0, void 0, _regenerator().m(function _callee() {
        var stats;
        return _regenerator().w(function(_context) {
          while (1) switch (_context.n) {
            case 0:
              if (this.receiver) {
                _context.n = 1;
                break;
              }
              this._currentBitrate = 0;
              return _context.a(2);
            case 1:
              _context.n = 2;
              return this.getReceiverStats();
            case 2:
              stats = _context.v;
              if (stats && this.prevStats && this.receiver) {
                this._currentBitrate = computeBitrate(stats, this.prevStats);
              }
              this.prevStats = stats;
            case 3:
              return _context.a(2);
          }
        }, _callee, this);
      }));
    };
    _this.audioContext = audioContext;
    _this.webAudioPluginNodes = [];
    if (audioOutput) {
      _this.sinkId = audioOutput.deviceId;
    }
    return _this;
  }
  _inherits(RemoteAudioTrack2, _RemoteTrack);
  return _createClass(RemoteAudioTrack2, [{
    key: "setVolume",
    value: function setVolume(volume) {
      var _a;
      var _iterator = _createForOfIteratorHelper(this.attachedElements), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var el = _step.value;
          if (this.audioContext) {
            (_a = this.gainNode) === null || _a === void 0 ? void 0 : _a.gain.setTargetAtTime(volume, 0, 0.1);
          } else {
            el.volume = volume;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      if (isReactNative()) {
        this._mediaStreamTrack._setVolume(volume);
      }
      this.elementVolume = volume;
    }
    /**
     * gets the volume of attached audio elements (loudest)
     */
  }, {
    key: "getVolume",
    value: function getVolume() {
      if (this.elementVolume) {
        return this.elementVolume;
      }
      if (isReactNative()) {
        return 1;
      }
      var highestVolume = 0;
      this.attachedElements.forEach(function(element) {
        if (element.volume > highestVolume) {
          highestVolume = element.volume;
        }
      });
      return highestVolume;
    }
    /**
     * calls setSinkId on all attached elements, if supported
     * @param deviceId audio output device
     */
  }, {
    key: "setSinkId",
    value: function setSinkId(deviceId) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee2() {
        return _regenerator().w(function(_context2) {
          while (1) switch (_context2.n) {
            case 0:
              this.sinkId = deviceId;
              _context2.n = 1;
              return Promise.all(this.attachedElements.map(function(elm) {
                if (!supportsSetSinkId(elm)) {
                  return;
                }
                return elm.setSinkId(deviceId);
              }));
            case 1:
              return _context2.a(2);
          }
        }, _callee2, this);
      }));
    }
  }, {
    key: "attach",
    value: function attach(element) {
      var needsNewWebAudioConnection = this.attachedElements.length === 0;
      if (!element) {
        element = _superPropGet(RemoteAudioTrack2, "attach", this, 3)([]);
      } else {
        _superPropGet(RemoteAudioTrack2, "attach", this, 3)([element]);
      }
      if (this.sinkId && supportsSetSinkId(element)) {
        element.setSinkId(this.sinkId);
      }
      if (this.audioContext && needsNewWebAudioConnection) {
        this.log.debug("using audio context mapping", this.logContext);
        this.connectWebAudio(this.audioContext, element);
        element.volume = 0;
        element.muted = true;
      }
      if (this.elementVolume) {
        this.setVolume(this.elementVolume);
      }
      return element;
    }
  }, {
    key: "detach",
    value: function detach(element) {
      var detached;
      if (!element) {
        detached = _superPropGet(RemoteAudioTrack2, "detach", this, 3)([]);
        this.disconnectWebAudio();
      } else {
        detached = _superPropGet(RemoteAudioTrack2, "detach", this, 3)([element]);
        if (this.audioContext) {
          if (this.attachedElements.length > 0) {
            this.connectWebAudio(this.audioContext, this.attachedElements[0]);
          } else {
            this.disconnectWebAudio();
          }
        }
      }
      return detached;
    }
    /**
     * @internal
     * @experimental
     */
  }, {
    key: "setAudioContext",
    value: function setAudioContext(audioContext) {
      this.audioContext = audioContext;
      if (audioContext && this.attachedElements.length > 0) {
        this.connectWebAudio(audioContext, this.attachedElements[0]);
      } else if (!audioContext) {
        this.disconnectWebAudio();
      }
    }
    /**
     * @internal
     * @experimental
     * @param {AudioNode[]} nodes - An array of WebAudio nodes. These nodes should not be connected to each other when passed, as the sdk will take care of connecting them in the order of the array.
     */
  }, {
    key: "setWebAudioPlugins",
    value: function setWebAudioPlugins(nodes) {
      this.webAudioPluginNodes = nodes;
      if (this.attachedElements.length > 0 && this.audioContext) {
        this.connectWebAudio(this.audioContext, this.attachedElements[0]);
      }
    }
  }, {
    key: "connectWebAudio",
    value: function connectWebAudio(context, element) {
      var _this2 = this;
      this.disconnectWebAudio();
      this.sourceNode = context.createMediaStreamSource(element.srcObject);
      var lastNode = this.sourceNode;
      this.webAudioPluginNodes.forEach(function(node) {
        lastNode.connect(node);
        lastNode = node;
      });
      this.gainNode = context.createGain();
      lastNode.connect(this.gainNode);
      this.gainNode.connect(context.destination);
      if (this.elementVolume) {
        this.gainNode.gain.setTargetAtTime(this.elementVolume, 0, 0.1);
      }
      if (context.state !== "running") {
        context.resume().then(function() {
          if (context.state !== "running") {
            _this2.emit(TrackEvent.AudioPlaybackFailed, new Error("Audio Context couldn't be started automatically"));
          }
        })["catch"](function(e) {
          _this2.emit(TrackEvent.AudioPlaybackFailed, e);
        });
      }
    }
  }, {
    key: "disconnectWebAudio",
    value: function disconnectWebAudio() {
      var _a, _b;
      (_a = this.gainNode) === null || _a === void 0 ? void 0 : _a.disconnect();
      (_b = this.sourceNode) === null || _b === void 0 ? void 0 : _b.disconnect();
      this.gainNode = void 0;
      this.sourceNode = void 0;
    }
  }, {
    key: "getReceiverStats",
    value: function getReceiverStats() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee3() {
        var stats, receiverStats;
        return _regenerator().w(function(_context3) {
          while (1) switch (_context3.n) {
            case 0:
              if (!(!this.receiver || !this.receiver.getStats)) {
                _context3.n = 1;
                break;
              }
              return _context3.a(2);
            case 1:
              _context3.n = 2;
              return this.receiver.getStats();
            case 2:
              stats = _context3.v;
              stats.forEach(function(v) {
                if (v.type === "inbound-rtp") {
                  receiverStats = {
                    type: "audio",
                    streamId: v.id,
                    timestamp: v.timestamp,
                    jitter: v.jitter,
                    bytesReceived: v.bytesReceived,
                    concealedSamples: v.concealedSamples,
                    concealmentEvents: v.concealmentEvents,
                    silentConcealedSamples: v.silentConcealedSamples,
                    silentConcealmentEvents: v.silentConcealmentEvents,
                    totalAudioEnergy: v.totalAudioEnergy,
                    totalSamplesDuration: v.totalSamplesDuration
                  };
                }
              });
              return _context3.a(2, receiverStats);
          }
        }, _callee3, this);
      }));
    }
  }]);
}(RemoteTrack);
var REACTION_DELAY = 100;
var RemoteVideoTrack = function(_RemoteTrack) {
  function RemoteVideoTrack2(mediaTrack, sid, receiver, adaptiveStreamSettings, loggerOptions) {
    var _this;
    _classCallCheck(this, RemoteVideoTrack2);
    _this = _callSuper(this, RemoteVideoTrack2, [mediaTrack, sid, Track.Kind.Video, receiver, loggerOptions]);
    _this.elementInfos = [];
    _this.monitorReceiver = function() {
      return __awaiter(_this, void 0, void 0, _regenerator().m(function _callee() {
        var stats;
        return _regenerator().w(function(_context) {
          while (1) switch (_context.n) {
            case 0:
              if (this.receiver) {
                _context.n = 1;
                break;
              }
              this._currentBitrate = 0;
              return _context.a(2);
            case 1:
              _context.n = 2;
              return this.getReceiverStats();
            case 2:
              stats = _context.v;
              if (stats && this.prevStats && this.receiver) {
                this._currentBitrate = computeBitrate(stats, this.prevStats);
              }
              this.prevStats = stats;
            case 3:
              return _context.a(2);
          }
        }, _callee, this);
      }));
    };
    _this.debouncedHandleResize = r(function() {
      _this.updateDimensions();
    }, REACTION_DELAY);
    _this.adaptiveStreamSettings = adaptiveStreamSettings;
    return _this;
  }
  _inherits(RemoteVideoTrack2, _RemoteTrack);
  return _createClass(RemoteVideoTrack2, [{
    key: "isAdaptiveStream",
    get: function get2() {
      return this.adaptiveStreamSettings !== void 0;
    }
    /**
     * Note: When using adaptiveStream, you need to use remoteVideoTrack.attach() to add the track to a HTMLVideoElement, otherwise your video tracks might never start
     */
  }, {
    key: "mediaStreamTrack",
    get: function get2() {
      return this._mediaStreamTrack;
    }
    /** @internal */
  }, {
    key: "setMuted",
    value: function setMuted(muted) {
      var _this2 = this;
      _superPropGet(RemoteVideoTrack2, "setMuted", this, 3)([muted]);
      this.attachedElements.forEach(function(element) {
        if (muted) {
          detachTrack(_this2._mediaStreamTrack, element);
        } else {
          attachToElement(_this2._mediaStreamTrack, element);
        }
      });
    }
  }, {
    key: "attach",
    value: function attach(element) {
      if (!element) {
        element = _superPropGet(RemoteVideoTrack2, "attach", this, 3)([]);
      } else {
        _superPropGet(RemoteVideoTrack2, "attach", this, 3)([element]);
      }
      if (this.adaptiveStreamSettings && this.elementInfos.find(function(info) {
        return info.element === element;
      }) === void 0) {
        var elementInfo = new HTMLElementInfo(element);
        this.observeElementInfo(elementInfo);
      }
      return element;
    }
    /**
     * Observe an ElementInfo for changes when adaptive streaming.
     * @param elementInfo
     * @internal
     */
  }, {
    key: "observeElementInfo",
    value: function observeElementInfo(elementInfo) {
      var _this3 = this;
      if (this.adaptiveStreamSettings && this.elementInfos.find(function(info) {
        return info === elementInfo;
      }) === void 0) {
        elementInfo.handleResize = function() {
          _this3.debouncedHandleResize();
        };
        elementInfo.handleVisibilityChanged = function() {
          _this3.updateVisibility();
        };
        this.elementInfos.push(elementInfo);
        elementInfo.observe();
        this.debouncedHandleResize();
        this.updateVisibility();
      } else {
        this.log.warn("visibility resize observer not triggered", this.logContext);
      }
    }
    /**
     * Stop observing an ElementInfo for changes.
     * @param elementInfo
     * @internal
     */
  }, {
    key: "stopObservingElementInfo",
    value: function stopObservingElementInfo(elementInfo) {
      if (!this.isAdaptiveStream) {
        this.log.warn("stopObservingElementInfo ignored", this.logContext);
        return;
      }
      var stopElementInfos = this.elementInfos.filter(function(info2) {
        return info2 === elementInfo;
      });
      var _iterator = _createForOfIteratorHelper(stopElementInfos), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var info = _step.value;
          info.stopObserving();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      this.elementInfos = this.elementInfos.filter(function(info2) {
        return info2 !== elementInfo;
      });
      this.updateVisibility();
      this.debouncedHandleResize();
    }
  }, {
    key: "detach",
    value: function detach(element) {
      var detachedElements = [];
      if (element) {
        this.stopObservingElement(element);
        return _superPropGet(RemoteVideoTrack2, "detach", this, 3)([element]);
      }
      detachedElements = _superPropGet(RemoteVideoTrack2, "detach", this, 3)([]);
      var _iterator2 = _createForOfIteratorHelper(detachedElements), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var e = _step2.value;
          this.stopObservingElement(e);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return detachedElements;
    }
    /** @internal */
  }, {
    key: "getDecoderImplementation",
    value: function getDecoderImplementation() {
      var _a;
      return (_a = this.prevStats) === null || _a === void 0 ? void 0 : _a.decoderImplementation;
    }
  }, {
    key: "getReceiverStats",
    value: function getReceiverStats() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee2() {
        var stats, receiverStats, codecID, codecs;
        return _regenerator().w(function(_context2) {
          while (1) switch (_context2.n) {
            case 0:
              if (!(!this.receiver || !this.receiver.getStats)) {
                _context2.n = 1;
                break;
              }
              return _context2.a(2);
            case 1:
              _context2.n = 2;
              return this.receiver.getStats();
            case 2:
              stats = _context2.v;
              codecID = "";
              codecs = /* @__PURE__ */ new Map();
              stats.forEach(function(v) {
                if (v.type === "inbound-rtp") {
                  codecID = v.codecId;
                  receiverStats = {
                    type: "video",
                    streamId: v.id,
                    framesDecoded: v.framesDecoded,
                    framesDropped: v.framesDropped,
                    framesReceived: v.framesReceived,
                    packetsReceived: v.packetsReceived,
                    packetsLost: v.packetsLost,
                    frameWidth: v.frameWidth,
                    frameHeight: v.frameHeight,
                    pliCount: v.pliCount,
                    firCount: v.firCount,
                    nackCount: v.nackCount,
                    jitter: v.jitter,
                    timestamp: v.timestamp,
                    bytesReceived: v.bytesReceived,
                    decoderImplementation: v.decoderImplementation
                  };
                } else if (v.type === "codec") {
                  codecs.set(v.id, v);
                }
              });
              if (receiverStats && codecID !== "" && codecs.get(codecID)) {
                receiverStats.mimeType = codecs.get(codecID).mimeType;
              }
              return _context2.a(2, receiverStats);
          }
        }, _callee2, this);
      }));
    }
  }, {
    key: "stopObservingElement",
    value: function stopObservingElement(element) {
      var stopElementInfos = this.elementInfos.filter(function(info2) {
        return info2.element === element;
      });
      var _iterator3 = _createForOfIteratorHelper(stopElementInfos), _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
          var info = _step3.value;
          this.stopObservingElementInfo(info);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }
  }, {
    key: "handleAppVisibilityChanged",
    value: function handleAppVisibilityChanged() {
      var _this4 = this;
      var _super = Object.create(null, {
        handleAppVisibilityChanged: {
          get: function get2() {
            return _superPropGet(RemoteVideoTrack2, "handleAppVisibilityChanged", _this4, 1);
          }
        }
      });
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee3() {
        return _regenerator().w(function(_context3) {
          while (1) switch (_context3.n) {
            case 0:
              _context3.n = 1;
              return _super.handleAppVisibilityChanged.call(this);
            case 1:
              if (this.isAdaptiveStream) {
                _context3.n = 2;
                break;
              }
              return _context3.a(2);
            case 2:
              this.updateVisibility();
            case 3:
              return _context3.a(2);
          }
        }, _callee3, this);
      }));
    }
  }, {
    key: "updateVisibility",
    value: function updateVisibility() {
      var _this5 = this;
      var _a, _b;
      var lastVisibilityChange = this.elementInfos.reduce(function(prev, info) {
        return Math.max(prev, info.visibilityChangedAt || 0);
      }, 0);
      var backgroundPause = ((_b = (_a = this.adaptiveStreamSettings) === null || _a === void 0 ? void 0 : _a.pauseVideoInBackground) !== null && _b !== void 0 ? _b : true) ? this.isInBackground : false;
      var isPiPMode = this.elementInfos.some(function(info) {
        return info.pictureInPicture;
      });
      var isVisible = this.elementInfos.some(function(info) {
        return info.visible;
      }) && !backgroundPause || isPiPMode;
      if (this.lastVisible === isVisible) {
        return;
      }
      if (!isVisible && Date.now() - lastVisibilityChange < REACTION_DELAY) {
        CriticalTimers.setTimeout(function() {
          _this5.updateVisibility();
        }, REACTION_DELAY);
        return;
      }
      this.lastVisible = isVisible;
      this.emit(TrackEvent.VisibilityChanged, isVisible, this);
    }
  }, {
    key: "updateDimensions",
    value: function updateDimensions() {
      var _a, _b;
      var maxWidth = 0;
      var maxHeight = 0;
      var pixelDensity = this.getPixelDensity();
      var _iterator4 = _createForOfIteratorHelper(this.elementInfos), _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
          var info = _step4.value;
          var currentElementWidth = info.width() * pixelDensity;
          var currentElementHeight = info.height() * pixelDensity;
          if (currentElementWidth + currentElementHeight > maxWidth + maxHeight) {
            maxWidth = currentElementWidth;
            maxHeight = currentElementHeight;
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      if (((_a = this.lastDimensions) === null || _a === void 0 ? void 0 : _a.width) === maxWidth && ((_b = this.lastDimensions) === null || _b === void 0 ? void 0 : _b.height) === maxHeight) {
        return;
      }
      this.lastDimensions = {
        width: maxWidth,
        height: maxHeight
      };
      this.emit(TrackEvent.VideoDimensionsChanged, this.lastDimensions, this);
    }
  }, {
    key: "getPixelDensity",
    value: function getPixelDensity() {
      var _a;
      var pixelDensity = (_a = this.adaptiveStreamSettings) === null || _a === void 0 ? void 0 : _a.pixelDensity;
      if (pixelDensity === "screen") {
        return getDevicePixelRatio();
      } else if (!pixelDensity) {
        var devicePixelRatio = getDevicePixelRatio();
        if (devicePixelRatio > 2) {
          return 2;
        } else {
          return 1;
        }
      }
      return pixelDensity;
    }
  }]);
}(RemoteTrack);
var HTMLElementInfo = function() {
  function HTMLElementInfo2(element, visible) {
    var _this6 = this;
    _classCallCheck(this, HTMLElementInfo2);
    this.onVisibilityChanged = function(entry) {
      var _a;
      var target = entry.target, isIntersecting = entry.isIntersecting;
      if (target === _this6.element) {
        _this6.isIntersecting = isIntersecting;
        _this6.isPiP = isElementInPiP(_this6.element);
        _this6.visibilityChangedAt = Date.now();
        (_a = _this6.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(_this6);
      }
    };
    this.onEnterPiP = function() {
      var _a, _b, _c;
      (_b = (_a = window.documentPictureInPicture) === null || _a === void 0 ? void 0 : _a.window) === null || _b === void 0 ? void 0 : _b.addEventListener("pagehide", _this6.onLeavePiP);
      _this6.isPiP = isElementInPiP(_this6.element);
      (_c = _this6.handleVisibilityChanged) === null || _c === void 0 ? void 0 : _c.call(_this6);
    };
    this.onLeavePiP = function() {
      var _a;
      _this6.isPiP = isElementInPiP(_this6.element);
      (_a = _this6.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(_this6);
    };
    this.element = element;
    this.isIntersecting = visible !== null && visible !== void 0 ? visible : isElementInViewport(element);
    this.isPiP = isWeb() && isElementInPiP(element);
    this.visibilityChangedAt = 0;
  }
  return _createClass(HTMLElementInfo2, [{
    key: "visible",
    get: function get2() {
      return this.isPiP || this.isIntersecting;
    }
  }, {
    key: "pictureInPicture",
    get: function get2() {
      return this.isPiP;
    }
  }, {
    key: "width",
    value: function width() {
      return this.element.clientWidth;
    }
  }, {
    key: "height",
    value: function height() {
      return this.element.clientHeight;
    }
  }, {
    key: "observe",
    value: function observe() {
      var _this7 = this;
      var _a, _b, _c;
      this.isIntersecting = isElementInViewport(this.element);
      this.isPiP = isElementInPiP(this.element);
      this.element.handleResize = function() {
        var _a2;
        (_a2 = _this7.handleResize) === null || _a2 === void 0 ? void 0 : _a2.call(_this7);
      };
      this.element.handleVisibilityChanged = this.onVisibilityChanged;
      getIntersectionObserver().observe(this.element);
      getResizeObserver().observe(this.element);
      this.element.addEventListener("enterpictureinpicture", this.onEnterPiP);
      this.element.addEventListener("leavepictureinpicture", this.onLeavePiP);
      (_a = window.documentPictureInPicture) === null || _a === void 0 ? void 0 : _a.addEventListener("enter", this.onEnterPiP);
      (_c = (_b = window.documentPictureInPicture) === null || _b === void 0 ? void 0 : _b.window) === null || _c === void 0 ? void 0 : _c.addEventListener("pagehide", this.onLeavePiP);
    }
  }, {
    key: "stopObserving",
    value: function stopObserving() {
      var _a, _b, _c, _d, _e;
      (_a = getIntersectionObserver()) === null || _a === void 0 ? void 0 : _a.unobserve(this.element);
      (_b = getResizeObserver()) === null || _b === void 0 ? void 0 : _b.unobserve(this.element);
      this.element.removeEventListener("enterpictureinpicture", this.onEnterPiP);
      this.element.removeEventListener("leavepictureinpicture", this.onLeavePiP);
      (_c = window.documentPictureInPicture) === null || _c === void 0 ? void 0 : _c.removeEventListener("enter", this.onEnterPiP);
      (_e = (_d = window.documentPictureInPicture) === null || _d === void 0 ? void 0 : _d.window) === null || _e === void 0 ? void 0 : _e.removeEventListener("pagehide", this.onLeavePiP);
    }
  }]);
}();
function isElementInPiP(el) {
  var _a, _b;
  if (document.pictureInPictureElement === el) return true;
  if ((_a = window.documentPictureInPicture) === null || _a === void 0 ? void 0 : _a.window) return isElementInViewport(el, (_b = window.documentPictureInPicture) === null || _b === void 0 ? void 0 : _b.window);
  return false;
}
function isElementInViewport(el, win) {
  var viewportWindow = win || window;
  var top = el.offsetTop;
  var left = el.offsetLeft;
  var width = el.offsetWidth;
  var height = el.offsetHeight;
  var _el = el, hidden = _el.hidden;
  var _getComputedStyle = getComputedStyle(el), display = _getComputedStyle.display;
  while (el.offsetParent) {
    el = el.offsetParent;
    top += el.offsetTop;
    left += el.offsetLeft;
  }
  return top < viewportWindow.pageYOffset + viewportWindow.innerHeight && left < viewportWindow.pageXOffset + viewportWindow.innerWidth && top + height > viewportWindow.pageYOffset && left + width > viewportWindow.pageXOffset && !hidden && display !== "none";
}
var TrackPublication = function(_EventEmitter) {
  function TrackPublication2(kind, id, name, loggerOptions) {
    var _this;
    _classCallCheck(this, TrackPublication2);
    var _a;
    _this = _callSuper(this, TrackPublication2);
    _this.metadataMuted = false;
    _this.encryption = Encryption_Type.NONE;
    _this.log = livekitLogger;
    _this.handleMuted = function() {
      _this.emit(TrackEvent.Muted);
    };
    _this.handleUnmuted = function() {
      _this.emit(TrackEvent.Unmuted);
    };
    _this.log = getLogger((_a = loggerOptions === null || loggerOptions === void 0 ? void 0 : loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Publication);
    _this.loggerContextCb = _this.loggerContextCb;
    _this.setMaxListeners(100);
    _this.kind = kind;
    _this.trackSid = id;
    _this.trackName = name;
    _this.source = Track.Source.Unknown;
    return _this;
  }
  _inherits(TrackPublication2, _EventEmitter);
  return _createClass(TrackPublication2, [{
    key: "setTrack",
    value: function setTrack(track) {
      if (this.track) {
        this.track.off(TrackEvent.Muted, this.handleMuted);
        this.track.off(TrackEvent.Unmuted, this.handleUnmuted);
      }
      this.track = track;
      if (track) {
        track.on(TrackEvent.Muted, this.handleMuted);
        track.on(TrackEvent.Unmuted, this.handleUnmuted);
      }
    }
  }, {
    key: "logContext",
    get: function get2() {
      var _a;
      return Object.assign(Object.assign({}, (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)), getLogContextFromTrack(this));
    }
  }, {
    key: "isMuted",
    get: function get2() {
      return this.metadataMuted;
    }
  }, {
    key: "isEnabled",
    get: function get2() {
      return true;
    }
  }, {
    key: "isSubscribed",
    get: function get2() {
      return this.track !== void 0;
    }
  }, {
    key: "isEncrypted",
    get: function get2() {
      return this.encryption !== Encryption_Type.NONE;
    }
    /**
     * an [AudioTrack] if this publication holds an audio track
     */
  }, {
    key: "audioTrack",
    get: function get2() {
      if (this.track instanceof LocalAudioTrack || this.track instanceof RemoteAudioTrack) {
        return this.track;
      }
    }
    /**
     * an [VideoTrack] if this publication holds a video track
     */
  }, {
    key: "videoTrack",
    get: function get2() {
      if (this.track instanceof LocalVideoTrack || this.track instanceof RemoteVideoTrack) {
        return this.track;
      }
    }
    /** @internal */
  }, {
    key: "updateInfo",
    value: function updateInfo(info) {
      this.trackSid = info.sid;
      this.trackName = info.name;
      this.source = Track.sourceFromProto(info.source);
      this.mimeType = info.mimeType;
      if (this.kind === Track.Kind.Video && info.width > 0) {
        this.dimensions = {
          width: info.width,
          height: info.height
        };
        this.simulcasted = info.simulcast;
      }
      this.encryption = info.encryption;
      this.trackInfo = info;
      this.log.debug("update publication info", Object.assign(Object.assign({}, this.logContext), {
        info
      }));
    }
  }]);
}(eventsExports.EventEmitter);
(function(TrackPublication2) {
  (function(SubscriptionStatus) {
    SubscriptionStatus["Desired"] = "desired";
    SubscriptionStatus["Subscribed"] = "subscribed";
    SubscriptionStatus["Unsubscribed"] = "unsubscribed";
  })(TrackPublication2.SubscriptionStatus || (TrackPublication2.SubscriptionStatus = {}));
  (function(PermissionStatus) {
    PermissionStatus["Allowed"] = "allowed";
    PermissionStatus["NotAllowed"] = "not_allowed";
  })(TrackPublication2.PermissionStatus || (TrackPublication2.PermissionStatus = {}));
})(TrackPublication || (TrackPublication = {}));
var LocalTrackPublication = function(_TrackPublication) {
  function LocalTrackPublication2(kind, ti, track, loggerOptions) {
    var _this;
    _classCallCheck(this, LocalTrackPublication2);
    _this = _callSuper(this, LocalTrackPublication2, [kind, ti.sid, ti.name, loggerOptions]);
    _this.track = void 0;
    _this.handleTrackEnded = function() {
      _this.emit(TrackEvent.Ended);
    };
    _this.updateInfo(ti);
    _this.setTrack(track);
    return _this;
  }
  _inherits(LocalTrackPublication2, _TrackPublication);
  return _createClass(LocalTrackPublication2, [{
    key: "isUpstreamPaused",
    get: function get2() {
      var _a;
      return (_a = this.track) === null || _a === void 0 ? void 0 : _a.isUpstreamPaused;
    }
  }, {
    key: "setTrack",
    value: function setTrack(track) {
      if (this.track) {
        this.track.off(TrackEvent.Ended, this.handleTrackEnded);
      }
      _superPropGet(LocalTrackPublication2, "setTrack", this, 3)([track]);
      if (track) {
        track.on(TrackEvent.Ended, this.handleTrackEnded);
      }
    }
  }, {
    key: "isMuted",
    get: function get2() {
      if (this.track) {
        return this.track.isMuted;
      }
      return _superPropGet(LocalTrackPublication2, "isMuted", this, 1);
    }
  }, {
    key: "audioTrack",
    get: function get2() {
      return _superPropGet(LocalTrackPublication2, "audioTrack", this, 1);
    }
  }, {
    key: "videoTrack",
    get: function get2() {
      return _superPropGet(LocalTrackPublication2, "videoTrack", this, 1);
    }
    /**
     * Mute the track associated with this publication
     */
  }, {
    key: "mute",
    value: function mute() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee() {
        var _a;
        return _regenerator().w(function(_context) {
          while (1) switch (_context.n) {
            case 0:
              return _context.a(2, (_a = this.track) === null || _a === void 0 ? void 0 : _a.mute());
          }
        }, _callee, this);
      }));
    }
    /**
     * Unmute track associated with this publication
     */
  }, {
    key: "unmute",
    value: function unmute() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee2() {
        var _a;
        return _regenerator().w(function(_context2) {
          while (1) switch (_context2.n) {
            case 0:
              return _context2.a(2, (_a = this.track) === null || _a === void 0 ? void 0 : _a.unmute());
          }
        }, _callee2, this);
      }));
    }
    /**
     * Pauses the media stream track associated with this publication from being sent to the server
     * and signals "muted" event to other participants
     * Useful if you want to pause the stream without pausing the local media stream track
     */
  }, {
    key: "pauseUpstream",
    value: function pauseUpstream() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee3() {
        var _a;
        return _regenerator().w(function(_context3) {
          while (1) switch (_context3.n) {
            case 0:
              _context3.n = 1;
              return (_a = this.track) === null || _a === void 0 ? void 0 : _a.pauseUpstream();
            case 1:
              return _context3.a(2);
          }
        }, _callee3, this);
      }));
    }
    /**
     * Resumes sending the media stream track associated with this publication to the server after a call to [[pauseUpstream()]]
     * and signals "unmuted" event to other participants (unless the track is explicitly muted)
     */
  }, {
    key: "resumeUpstream",
    value: function resumeUpstream() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee4() {
        var _a;
        return _regenerator().w(function(_context4) {
          while (1) switch (_context4.n) {
            case 0:
              _context4.n = 1;
              return (_a = this.track) === null || _a === void 0 ? void 0 : _a.resumeUpstream();
            case 1:
              return _context4.a(2);
          }
        }, _callee4, this);
      }));
    }
  }, {
    key: "getTrackFeatures",
    value: function getTrackFeatures() {
      var _a;
      if (this.track instanceof LocalAudioTrack) {
        var settings = this.track.getSourceTrackSettings();
        var features = /* @__PURE__ */ new Set();
        if (settings.autoGainControl) {
          features.add(AudioTrackFeature.TF_AUTO_GAIN_CONTROL);
        }
        if (settings.echoCancellation) {
          features.add(AudioTrackFeature.TF_ECHO_CANCELLATION);
        }
        if (settings.noiseSuppression) {
          features.add(AudioTrackFeature.TF_NOISE_SUPPRESSION);
        }
        if (settings.channelCount && settings.channelCount > 1) {
          features.add(AudioTrackFeature.TF_STEREO);
        }
        if (!((_a = this.options) === null || _a === void 0 ? void 0 : _a.dtx)) {
          features.add(AudioTrackFeature.TF_NO_DTX);
        }
        if (this.track.enhancedNoiseCancellation) {
          features.add(AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION);
        }
        return Array.from(features.values());
      } else return [];
    }
  }]);
}(TrackPublication);
var ConnectionQuality;
(function(ConnectionQuality2) {
  ConnectionQuality2["Excellent"] = "excellent";
  ConnectionQuality2["Good"] = "good";
  ConnectionQuality2["Poor"] = "poor";
  ConnectionQuality2["Lost"] = "lost";
  ConnectionQuality2["Unknown"] = "unknown";
})(ConnectionQuality || (ConnectionQuality = {}));
function qualityFromProto(q) {
  switch (q) {
    case ConnectionQuality$1.EXCELLENT:
      return ConnectionQuality.Excellent;
    case ConnectionQuality$1.GOOD:
      return ConnectionQuality.Good;
    case ConnectionQuality$1.POOR:
      return ConnectionQuality.Poor;
    case ConnectionQuality$1.LOST:
      return ConnectionQuality.Lost;
    default:
      return ConnectionQuality.Unknown;
  }
}
var Participant = function(_EventEmitter) {
  function Participant2(sid, identity, name, metadata, attributes, loggerOptions) {
    var _this;
    var kind = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : ParticipantInfo_Kind.STANDARD;
    _classCallCheck(this, Participant2);
    var _a;
    _this = _callSuper(this, Participant2);
    _this.audioLevel = 0;
    _this.isSpeaking = false;
    _this._connectionQuality = ConnectionQuality.Unknown;
    _this.log = livekitLogger;
    _this.log = getLogger((_a = loggerOptions === null || loggerOptions === void 0 ? void 0 : loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Participant);
    _this.loggerOptions = loggerOptions;
    _this.setMaxListeners(100);
    _this.sid = sid;
    _this.identity = identity;
    _this.name = name;
    _this.metadata = metadata;
    _this.audioTrackPublications = /* @__PURE__ */ new Map();
    _this.videoTrackPublications = /* @__PURE__ */ new Map();
    _this.trackPublications = /* @__PURE__ */ new Map();
    _this._kind = kind;
    _this._attributes = attributes !== null && attributes !== void 0 ? attributes : {};
    return _this;
  }
  _inherits(Participant2, _EventEmitter);
  return _createClass(Participant2, [{
    key: "logContext",
    get: function get2() {
      var _a, _b;
      return Object.assign({}, (_b = (_a = this.loggerOptions) === null || _a === void 0 ? void 0 : _a.loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));
    }
  }, {
    key: "isEncrypted",
    get: function get2() {
      return this.trackPublications.size > 0 && Array.from(this.trackPublications.values()).every(function(tr) {
        return tr.isEncrypted;
      });
    }
  }, {
    key: "isAgent",
    get: function get2() {
      var _a;
      return ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.agent) || this.kind === ParticipantInfo_Kind.AGENT;
    }
  }, {
    key: "kind",
    get: function get2() {
      return this._kind;
    }
    /** participant attributes, similar to metadata, but as a key/value map */
  }, {
    key: "attributes",
    get: function get2() {
      return Object.freeze(Object.assign({}, this._attributes));
    }
  }, {
    key: "getTrackPublications",
    value: function getTrackPublications() {
      return Array.from(this.trackPublications.values());
    }
    /**
     * Finds the first track that matches the source filter, for example, getting
     * the user's camera track with getTrackBySource(Track.Source.Camera).
     */
  }, {
    key: "getTrackPublication",
    value: function getTrackPublication(source) {
      var _iterator = _createForOfIteratorHelper(this.trackPublications), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var _step$value = _slicedToArray(_step.value, 2), pub = _step$value[1];
          if (pub.source === source) {
            return pub;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    /**
     * Finds the first track that matches the track's name.
     */
  }, {
    key: "getTrackPublicationByName",
    value: function getTrackPublicationByName(name) {
      var _iterator2 = _createForOfIteratorHelper(this.trackPublications), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var _step2$value = _slicedToArray(_step2.value, 2), pub = _step2$value[1];
          if (pub.trackName === name) {
            return pub;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  }, {
    key: "connectionQuality",
    get: function get2() {
      return this._connectionQuality;
    }
  }, {
    key: "isCameraEnabled",
    get: function get2() {
      var _a;
      var track = this.getTrackPublication(Track.Source.Camera);
      return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a !== void 0 ? _a : true);
    }
  }, {
    key: "isMicrophoneEnabled",
    get: function get2() {
      var _a;
      var track = this.getTrackPublication(Track.Source.Microphone);
      return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a !== void 0 ? _a : true);
    }
  }, {
    key: "isScreenShareEnabled",
    get: function get2() {
      var track = this.getTrackPublication(Track.Source.ScreenShare);
      return !!track;
    }
  }, {
    key: "isLocal",
    get: function get2() {
      return false;
    }
    /** when participant joined the room */
  }, {
    key: "joinedAt",
    get: function get2() {
      if (this.participantInfo) {
        return new Date(Number.parseInt(this.participantInfo.joinedAt.toString()) * 1e3);
      }
      return /* @__PURE__ */ new Date();
    }
    /** @internal */
  }, {
    key: "updateInfo",
    value: function updateInfo(info) {
      if (this.participantInfo && this.participantInfo.sid === info.sid && this.participantInfo.version > info.version) {
        return false;
      }
      this.identity = info.identity;
      this.sid = info.sid;
      this._setName(info.name);
      this._setMetadata(info.metadata);
      this._setAttributes(info.attributes);
      if (info.permission) {
        this.setPermissions(info.permission);
      }
      this.participantInfo = info;
      this.log.trace("update participant info", Object.assign(Object.assign({}, this.logContext), {
        info
      }));
      return true;
    }
    /**
     * Updates metadata from server
     **/
  }, {
    key: "_setMetadata",
    value: function _setMetadata(md) {
      var changed = this.metadata !== md;
      var prevMetadata = this.metadata;
      this.metadata = md;
      if (changed) {
        this.emit(ParticipantEvent.ParticipantMetadataChanged, prevMetadata);
      }
    }
  }, {
    key: "_setName",
    value: function _setName(name) {
      var changed = this.name !== name;
      this.name = name;
      if (changed) {
        this.emit(ParticipantEvent.ParticipantNameChanged, name);
      }
    }
    /**
     * Updates metadata from server
     **/
  }, {
    key: "_setAttributes",
    value: function _setAttributes(attributes) {
      var diff = diffAttributes(this.attributes, attributes);
      this._attributes = attributes;
      if (Object.keys(diff).length > 0) {
        this.emit(ParticipantEvent.AttributesChanged, diff);
      }
    }
    /** @internal */
  }, {
    key: "setPermissions",
    value: function setPermissions(permissions) {
      var _this2 = this;
      var _a, _b, _c, _d, _e, _f;
      var prevPermissions = this.permissions;
      var changed = permissions.canPublish !== ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.canPublish) || permissions.canSubscribe !== ((_b = this.permissions) === null || _b === void 0 ? void 0 : _b.canSubscribe) || permissions.canPublishData !== ((_c = this.permissions) === null || _c === void 0 ? void 0 : _c.canPublishData) || permissions.hidden !== ((_d = this.permissions) === null || _d === void 0 ? void 0 : _d.hidden) || permissions.recorder !== ((_e = this.permissions) === null || _e === void 0 ? void 0 : _e.recorder) || permissions.canPublishSources.length !== this.permissions.canPublishSources.length || permissions.canPublishSources.some(function(value, index) {
        var _a2;
        return value !== ((_a2 = _this2.permissions) === null || _a2 === void 0 ? void 0 : _a2.canPublishSources[index]);
      }) || permissions.canSubscribeMetrics !== ((_f = this.permissions) === null || _f === void 0 ? void 0 : _f.canSubscribeMetrics);
      this.permissions = permissions;
      if (changed) {
        this.emit(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions, permissions);
      }
      return changed;
    }
    /** @internal */
  }, {
    key: "setIsSpeaking",
    value: function setIsSpeaking(speaking) {
      if (speaking === this.isSpeaking) {
        return;
      }
      this.isSpeaking = speaking;
      if (speaking) {
        this.lastSpokeAt = /* @__PURE__ */ new Date();
      }
      this.emit(ParticipantEvent.IsSpeakingChanged, speaking);
    }
    /** @internal */
    // for improving the video quality, need to limit the sebsequent calls to this method
    // to once in 15 seconds
  }, {
    key: "setConnectionQuality",
    value: function setConnectionQuality(q) {
      var _this3 = this;
      this._lastProtoQuality = q;
      if (this._qualityChangeTimeout) {
        clearTimeout(this._qualityChangeTimeout);
      }
      this._qualityChangeTimeout = setTimeout(function() {
        var newQuality = qualityFromProto(_this3._lastProtoQuality);
        var prevQuality = _this3._connectionQuality;
        if (prevQuality !== newQuality) {
          _this3._connectionQuality = newQuality;
          console.log("Connection quality changed from ".concat(prevQuality, " to ").concat(newQuality));
          _this3.emit(ParticipantEvent.ConnectionQualityChanged, newQuality);
        }
        _this3._qualityChangeTimeout = void 0;
      }, 15e3);
    }
    /**
     * @internal
     */
  }, {
    key: "setAudioContext",
    value: function setAudioContext(ctx) {
      this.audioContext = ctx;
      this.audioTrackPublications.forEach(function(track) {
        return (track.track instanceof RemoteAudioTrack || track.track instanceof LocalAudioTrack) && track.track.setAudioContext(ctx);
      });
    }
  }, {
    key: "addTrackPublication",
    value: function addTrackPublication(publication) {
      var _this4 = this;
      publication.on(TrackEvent.Muted, function() {
        _this4.emit(ParticipantEvent.TrackMuted, publication);
      });
      publication.on(TrackEvent.Unmuted, function() {
        _this4.emit(ParticipantEvent.TrackUnmuted, publication);
      });
      var pub = publication;
      if (pub.track) {
        pub.track.sid = publication.trackSid;
      }
      this.trackPublications.set(publication.trackSid, publication);
      switch (publication.kind) {
        case Track.Kind.Audio:
          this.audioTrackPublications.set(publication.trackSid, publication);
          break;
        case Track.Kind.Video:
          this.videoTrackPublications.set(publication.trackSid, publication);
          break;
      }
    }
  }]);
}(eventsExports.EventEmitter);
function trackPermissionToProto(perms) {
  var _a, _b, _c;
  if (!perms.participantSid && !perms.participantIdentity) {
    throw new Error("Invalid track permission, must provide at least one of participantIdentity and participantSid");
  }
  return new TrackPermission({
    participantIdentity: (_a = perms.participantIdentity) !== null && _a !== void 0 ? _a : "",
    participantSid: (_b = perms.participantSid) !== null && _b !== void 0 ? _b : "",
    allTracks: (_c = perms.allowAll) !== null && _c !== void 0 ? _c : false,
    trackSids: perms.allowedTrackSids || []
  });
}
var LocalParticipant = function(_Participant) {
  function LocalParticipant2(sid, identity, engine, options) {
    var _this;
    _classCallCheck(this, LocalParticipant2);
    _this = _callSuper(this, LocalParticipant2, [sid, identity, void 0, void 0, void 0, {
      loggerName: options.loggerName,
      loggerContextCb: function loggerContextCb() {
        return _this.engine.logContext;
      }
    }]);
    _this.pendingPublishing = /* @__PURE__ */ new Set();
    _this.pendingPublishPromises = /* @__PURE__ */ new Map();
    _this.participantTrackPermissions = [];
    _this.allParticipantsAllowedToSubscribe = true;
    _this.encryptionType = Encryption_Type.NONE;
    _this.audioMuted = false;
    _this.videoMuted = false;
    _this.enabledPublishVideoCodecs = [];
    _this.rpcHandlers = /* @__PURE__ */ new Map();
    _this.pendingAcks = /* @__PURE__ */ new Map();
    _this.pendingResponses = /* @__PURE__ */ new Map();
    _this.handleReconnecting = function() {
      if (!_this.reconnectFuture) {
        _this.reconnectFuture = new Future();
      }
    };
    _this.handleReconnected = function() {
      var _a, _b;
      (_b = (_a = _this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.resolve) === null || _b === void 0 ? void 0 : _b.call(_a);
      _this.reconnectFuture = void 0;
      _this.updateTrackSubscriptionPermissions();
    };
    _this.handleDisconnected = function() {
      var _a, _b;
      if (_this.reconnectFuture) {
        _this.reconnectFuture.promise["catch"](function(e) {
          return _this.log.warn(e.message, _this.logContext);
        });
        (_b = (_a = _this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.reject) === null || _b === void 0 ? void 0 : _b.call(_a, "Got disconnected during reconnection attempt");
        _this.reconnectFuture = void 0;
      }
    };
    _this.handleSignalRequestResponse = function(response) {
      var requestId = response.requestId, reason = response.reason, message = response.message;
      var targetRequest = _this.pendingSignalRequests.get(requestId);
      if (targetRequest) {
        if (reason !== RequestResponse_Reason.OK) {
          targetRequest.reject(new SignalRequestError(message, reason));
        }
        _this.pendingSignalRequests["delete"](requestId);
      }
    };
    _this.handleDataPacket = function(packet) {
      switch (packet.value["case"]) {
        case "rpcRequest":
          var rpcRequest = packet.value.value;
          _this.handleIncomingRpcRequest(packet.participantIdentity, rpcRequest.id, rpcRequest.method, rpcRequest.payload, rpcRequest.responseTimeoutMs);
          break;
        case "rpcResponse":
          var rpcResponse = packet.value.value;
          var payload = null;
          var error = null;
          if (rpcResponse.value["case"] === "payload") {
            payload = rpcResponse.value.value;
          } else if (rpcResponse.value["case"] === "error") {
            error = RpcError.fromProto(rpcResponse.value.value);
          }
          _this.handleIncomingRpcResponse(rpcResponse.requestId, payload, error);
          break;
        case "rpcAck":
          var rpcAck = packet.value.value;
          _this.handleIncomingRpcAck(rpcAck.requestId);
          break;
      }
    };
    _this.updateTrackSubscriptionPermissions = function() {
      _this.log.debug("updating track subscription permissions", Object.assign(Object.assign({}, _this.logContext), {
        allParticipantsAllowed: _this.allParticipantsAllowedToSubscribe,
        participantTrackPermissions: _this.participantTrackPermissions
      }));
      _this.engine.client.sendUpdateSubscriptionPermissions(_this.allParticipantsAllowedToSubscribe, _this.participantTrackPermissions.map(function(p) {
        return trackPermissionToProto(p);
      }));
    };
    _this.onTrackUnmuted = function(track) {
      _this.onTrackMuted(track, track.isUpstreamPaused);
    };
    _this.onTrackMuted = function(track, muted) {
      if (muted === void 0) {
        muted = true;
      }
      if (!track.sid) {
        _this.log.error("could not update mute status for unpublished track", Object.assign(Object.assign({}, _this.logContext), getLogContextFromTrack(track)));
        return;
      }
      if (track.kind == Track.Kind.Audio) {
        if (muted) {
          sessionStorage.setItem("isAudioMuted", "true");
        } else {
          sessionStorage.setItem("isAudioMuted", "false");
        }
      } else {
        if (muted) {
          sessionStorage.setItem("isVideoMuted", "true");
        } else {
          sessionStorage.setItem("isVideoMuted", "false");
        }
      }
      _this.engine.updateMuteStatus(track.sid, muted);
    };
    _this.onTrackUpstreamPaused = function(track) {
      _this.log.debug("upstream paused", Object.assign(Object.assign({}, _this.logContext), getLogContextFromTrack(track)));
      _this.onTrackMuted(track, true);
    };
    _this.onTrackUpstreamResumed = function(track) {
      _this.log.debug("upstream resumed", Object.assign(Object.assign({}, _this.logContext), getLogContextFromTrack(track)));
      _this.onTrackMuted(track, track.isMuted);
    };
    _this.onTrackFeatureUpdate = function(track) {
      var pub = _this.audioTrackPublications.get(track.sid);
      if (!pub) {
        _this.log.warn("Could not update local audio track settings, missing publication for track ".concat(track.sid), _this.logContext);
        return;
      }
      _this.engine.client.sendUpdateLocalAudioTrack(pub.trackSid, pub.getTrackFeatures());
    };
    _this.handleSubscribedQualityUpdate = function(update) {
      return __awaiter(_this, void 0, void 0, _regenerator().m(function _callee() {
        var _a, e_1, _b, _c, _d, _e, pub, newCodecs, _f, newCodecs_1, newCodecs_1_1, codec, _t;
        return _regenerator().w(function(_context) {
          while (1) switch (_context.n) {
            case 0:
              if ((_d = this.roomOptions) === null || _d === void 0 ? void 0 : _d.dynacast) {
                _context.n = 1;
                break;
              }
              return _context.a(2);
            case 1:
              pub = this.videoTrackPublications.get(update.trackSid);
              if (pub) {
                _context.n = 2;
                break;
              }
              this.log.warn("received subscribed quality update for unknown track", Object.assign(Object.assign({}, this.logContext), {
                trackSid: update.trackSid
              }));
              return _context.a(2);
            case 2:
              if (!(update.subscribedCodecs.length > 0)) {
                _context.n = 17;
                break;
              }
              if (pub.videoTrack) {
                _context.n = 3;
                break;
              }
              return _context.a(2);
            case 3:
              _context.n = 4;
              return pub.videoTrack.setPublishingCodecs(update.subscribedCodecs);
            case 4:
              newCodecs = _context.v;
              _context.p = 5;
              _f = true, newCodecs_1 = __asyncValues(newCodecs);
            case 6:
              _context.n = 7;
              return newCodecs_1.next();
            case 7:
              newCodecs_1_1 = _context.v;
              _a = newCodecs_1_1.done;
              if (_a) {
                _context.n = 9;
                break;
              }
              _c = newCodecs_1_1.value;
              _f = false;
              codec = _c;
              if (!isBackupCodec(codec)) {
                _context.n = 8;
                break;
              }
              this.log.debug("publish ".concat(codec, " for ").concat(pub.videoTrack.sid), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(pub)));
              _context.n = 8;
              return this.publishAdditionalCodecForTrack(pub.videoTrack, codec, pub.options);
            case 8:
              _f = true;
              _context.n = 6;
              break;
            case 9:
              _context.n = 11;
              break;
            case 10:
              _context.p = 10;
              _t = _context.v;
              e_1 = {
                error: _t
              };
            case 11:
              _context.p = 11;
              _context.p = 12;
              if (!(!_f && !_a && (_b = newCodecs_1["return"]))) {
                _context.n = 13;
                break;
              }
              _context.n = 13;
              return _b.call(newCodecs_1);
            case 13:
              _context.p = 13;
              if (!e_1) {
                _context.n = 14;
                break;
              }
              throw e_1.error;
            case 14:
              return _context.f(13);
            case 15:
              return _context.f(11);
            case 16:
              _context.n = 18;
              break;
            case 17:
              if (!(update.subscribedQualities.length > 0)) {
                _context.n = 18;
                break;
              }
              _context.n = 18;
              return (_e = pub.videoTrack) === null || _e === void 0 ? void 0 : _e.setPublishingLayers(update.subscribedQualities);
            case 18:
              return _context.a(2);
          }
        }, _callee, this, [[12, , 13, 15], [5, 10, 11, 16]]);
      }));
    };
    _this.handleLocalTrackUnpublished = function(unpublished) {
      var track = _this.trackPublications.get(unpublished.trackSid);
      if (!track) {
        _this.log.warn("received unpublished event for unknown track", Object.assign(Object.assign({}, _this.logContext), {
          trackSid: unpublished.trackSid
        }));
        return;
      }
      _this.unpublishTrack(track.track);
    };
    _this.handleTrackEnded = function(track) {
      return __awaiter(_this, void 0, void 0, _regenerator().m(function _callee2() {
        var currentPermissions;
        return _regenerator().w(function(_context2) {
          while (1) switch (_context2.n) {
            case 0:
              if (!(track.source === Track.Source.ScreenShare || track.source === Track.Source.ScreenShareAudio)) {
                _context2.n = 1;
                break;
              }
              this.log.debug("unpublishing local track due to TrackEnded", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
              this.unpublishTrack(track);
              _context2.n = 12;
              break;
            case 1:
              if (!track.isUserProvided) {
                _context2.n = 3;
                break;
              }
              _context2.n = 2;
              return track.mute();
            case 2:
              _context2.n = 12;
              break;
            case 3:
              if (!(track instanceof LocalAudioTrack || track instanceof LocalVideoTrack)) {
                _context2.n = 12;
                break;
              }
              _context2.p = 4;
              if (!isWeb()) {
                _context2.n = 9;
                break;
              }
              _context2.p = 5;
              _context2.n = 6;
              return navigator === null || navigator === void 0 ? void 0 : navigator.permissions.query({
                // the permission query for camera and microphone currently not supported in Safari and Firefox
                // @ts-ignore
                name: track.source === Track.Source.Camera ? "camera" : "microphone"
              });
            case 6:
              currentPermissions = _context2.v;
              if (!(currentPermissions && currentPermissions.state === "denied")) {
                _context2.n = 7;
                break;
              }
              this.log.warn("user has revoked access to ".concat(track.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
              currentPermissions.onchange = function() {
                if (currentPermissions.state !== "denied") {
                  if (!track.isMuted) {
                    track.restartTrack();
                  }
                  currentPermissions.onchange = null;
                }
              };
              throw new Error("GetUserMedia Permission denied");
            case 7:
              _context2.n = 9;
              break;
            case 8:
              _context2.p = 8;
              _context2.v;
            case 9:
              if (track.isMuted) {
                _context2.n = 10;
                break;
              }
              this.log.debug("track ended, attempting to use a different device", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
              _context2.n = 10;
              return track.restartTrack();
            case 10:
              _context2.n = 12;
              break;
            case 11:
              _context2.p = 11;
              _context2.v;
              this.log.warn("could not restart track, muting instead", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
              _context2.n = 12;
              return track.mute();
            case 12:
              return _context2.a(2);
          }
        }, _callee2, this, [[5, 8], [4, 11]]);
      }));
    };
    _this.audioTrackPublications = /* @__PURE__ */ new Map();
    _this.videoTrackPublications = /* @__PURE__ */ new Map();
    _this.trackPublications = /* @__PURE__ */ new Map();
    _this.engine = engine;
    _this.roomOptions = options;
    _this.setupEngine(engine);
    _this.activeDeviceMap = /* @__PURE__ */ new Map([["audioinput", "default"], ["videoinput", "default"], ["audiooutput", "default"]]);
    _this.pendingSignalRequests = /* @__PURE__ */ new Map();
    return _this;
  }
  _inherits(LocalParticipant2, _Participant);
  return _createClass(LocalParticipant2, [{
    key: "lastCameraError",
    get: function get2() {
      return this.cameraError;
    }
  }, {
    key: "lastMicrophoneError",
    get: function get2() {
      return this.microphoneError;
    }
  }, {
    key: "isE2EEEnabled",
    get: function get2() {
      return this.encryptionType !== Encryption_Type.NONE;
    }
  }, {
    key: "getTrackPublication",
    value: function getTrackPublication(source) {
      var track = _superPropGet(LocalParticipant2, "getTrackPublication", this, 3)([source]);
      if (track) {
        return track;
      }
    }
  }, {
    key: "getTrackPublicationByName",
    value: function getTrackPublicationByName(name) {
      var track = _superPropGet(LocalParticipant2, "getTrackPublicationByName", this, 3)([name]);
      if (track) {
        return track;
      }
    }
    /**
     * @internal
     */
  }, {
    key: "setupEngine",
    value: function setupEngine(engine) {
      var _this2 = this;
      this.engine = engine;
      this.engine.on(EngineEvent.RemoteMute, function(trackSid, muted) {
        var pub = _this2.trackPublications.get(trackSid);
        if (!pub || !pub.track) {
          return;
        }
        if (muted) {
          if (pub.kind == "audio") {
            _this2.audioMuted = true;
            sessionStorage.setItem("isAudioMuted", "true");
          } else {
            _this2.videoMuted = true;
            sessionStorage.setItem("isVideoMuted", "true");
          }
          pub.mute();
        } else {
          if (pub.kind == "audio") {
            sessionStorage.setItem("isAudioMuted", "false");
          } else {
            sessionStorage.setItem("isVideoMuted", "false");
          }
          pub.unmute();
        }
      });
      this.engine.on(EngineEvent.Connected, this.handleReconnected).on(EngineEvent.SignalRestarted, this.handleReconnected).on(EngineEvent.SignalResumed, this.handleReconnected).on(EngineEvent.Restarting, this.handleReconnecting).on(EngineEvent.Resuming, this.handleReconnecting).on(EngineEvent.LocalTrackUnpublished, this.handleLocalTrackUnpublished).on(EngineEvent.SubscribedQualityUpdate, this.handleSubscribedQualityUpdate).on(EngineEvent.Disconnected, this.handleDisconnected).on(EngineEvent.SignalRequestResponse, this.handleSignalRequestResponse).on(EngineEvent.DataPacketReceived, this.handleDataPacket);
    }
    /**
     * Sets and updates the metadata of the local participant.
     * Note: this requires `canUpdateOwnMetadata` permission.
     * method will throw if the user doesn't have the required permissions
     * @param metadata
     */
  }, {
    key: "setMetadata",
    value: function setMetadata(metadata) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee3() {
        return _regenerator().w(function(_context3) {
          while (1) switch (_context3.n) {
            case 0:
              _context3.n = 1;
              return this.requestMetadataUpdate({
                metadata
              });
            case 1:
              return _context3.a(2);
          }
        }, _callee3, this);
      }));
    }
    /**
     * Sets and updates the name of the local participant.
     * Note: this requires `canUpdateOwnMetadata` permission.
     * method will throw if the user doesn't have the required permissions
     * @param metadata
     */
  }, {
    key: "setName",
    value: function setName(name) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee4() {
        return _regenerator().w(function(_context4) {
          while (1) switch (_context4.n) {
            case 0:
              _context4.n = 1;
              return this.requestMetadataUpdate({
                name
              });
            case 1:
              return _context4.a(2);
          }
        }, _callee4, this);
      }));
    }
    /**
     * Set or update participant attributes. It will make updates only to keys that
     * are present in `attributes`, and will not override others.
     * Note: this requires `canUpdateOwnMetadata` permission.
     * @param attributes attributes to update
     */
  }, {
    key: "setAttributes",
    value: function setAttributes(attributes) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee5() {
        return _regenerator().w(function(_context5) {
          while (1) switch (_context5.n) {
            case 0:
              _context5.n = 1;
              return this.requestMetadataUpdate({
                attributes
              });
            case 1:
              return _context5.a(2);
          }
        }, _callee5, this);
      }));
    }
  }, {
    key: "requestMetadataUpdate",
    value: function requestMetadataUpdate(_a) {
      return __awaiter(this, arguments, void 0, function(_ref) {
        var _this3 = this;
        var metadata = _ref.metadata, name = _ref.name, attributes = _ref.attributes;
        return _regenerator().m(function _callee7() {
          return _regenerator().w(function(_context7) {
            while (1) switch (_context7.n) {
              case 0:
                return _context7.a(2, new Promise(function(resolve, _reject) {
                  return __awaiter(_this3, void 0, void 0, _regenerator().m(function _callee6() {
                    var _this4 = this;
                    var _a2, _b, isRejected, requestId, startTime, _t4;
                    return _regenerator().w(function(_context6) {
                      while (1) switch (_context6.n) {
                        case 0:
                          _context6.p = 0;
                          isRejected = false;
                          _context6.n = 1;
                          return this.engine.client.sendUpdateLocalMetadata((_a2 = metadata !== null && metadata !== void 0 ? metadata : this.metadata) !== null && _a2 !== void 0 ? _a2 : "", (_b = name !== null && name !== void 0 ? name : this.name) !== null && _b !== void 0 ? _b : "", attributes);
                        case 1:
                          requestId = _context6.v;
                          startTime = performance.now();
                          this.pendingSignalRequests.set(requestId, {
                            resolve,
                            reject: function reject(reason) {
                              _reject(reason);
                              isRejected = true;
                            },
                            values: {
                              name,
                              metadata,
                              attributes
                            }
                          });
                        case 2:
                          if (!(performance.now() - startTime < 5e3 && !isRejected)) {
                            _context6.n = 5;
                            break;
                          }
                          if (!((!name || this.name === name) && (!metadata || this.metadata === metadata) && (!attributes || Object.entries(attributes).every(function(_ref2) {
                            var _ref3 = _slicedToArray(_ref2, 2), key = _ref3[0], value = _ref3[1];
                            return _this4.attributes[key] === value || value === "" && !_this4.attributes[key];
                          })))) {
                            _context6.n = 3;
                            break;
                          }
                          this.pendingSignalRequests["delete"](requestId);
                          resolve();
                          return _context6.a(2);
                        case 3:
                          _context6.n = 4;
                          return sleep(50);
                        case 4:
                          _context6.n = 2;
                          break;
                        case 5:
                          _reject(new SignalRequestError("Request to update local metadata timed out", "TimeoutError"));
                          _context6.n = 7;
                          break;
                        case 6:
                          _context6.p = 6;
                          _t4 = _context6.v;
                          if (_t4 instanceof Error) _reject(_t4);
                        case 7:
                          return _context6.a(2);
                      }
                    }, _callee6, this, [[0, 6]]);
                  }));
                }));
            }
          }, _callee7);
        })();
      });
    }
    /**
     * Enable or disable a participant's camera track.
     *
     * If a track has already published, it'll mute or unmute the track.
     * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise
     */
  }, {
    key: "setCameraEnabled",
    value: function setCameraEnabled(enabled, options, publishOptions) {
      return this.setTrackEnabled(Track.Source.Camera, enabled, options, publishOptions);
    }
    /**
     * Enable or disable a participant's microphone track.
     *
     * If a track has already published, it'll mute or unmute the track.
     * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise
     */
  }, {
    key: "setMicrophoneEnabled",
    value: function setMicrophoneEnabled(enabled, options, publishOptions) {
      return this.setTrackEnabled(Track.Source.Microphone, enabled, options, publishOptions);
    }
    /**
     * Start or stop sharing a participant's screen
     * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise
     */
  }, {
    key: "setScreenShareEnabled",
    value: function setScreenShareEnabled(enabled, options, publishOptions) {
      return this.setTrackEnabled(Track.Source.ScreenShare, enabled, options, publishOptions);
    }
    /** @internal */
  }, {
    key: "setPermissions",
    value: function setPermissions(permissions) {
      var prevPermissions = this.permissions;
      var changed = _superPropGet(LocalParticipant2, "setPermissions", this, 3)([permissions]);
      if (changed && prevPermissions) {
        this.emit(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions);
      }
      return changed;
    }
    /** @internal */
  }, {
    key: "setE2EEEnabled",
    value: function setE2EEEnabled(enabled) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee8() {
        return _regenerator().w(function(_context8) {
          while (1) switch (_context8.n) {
            case 0:
              this.encryptionType = enabled ? Encryption_Type.GCM : Encryption_Type.NONE;
              _context8.n = 1;
              return this.republishAllTracks(void 0, false);
            case 1:
              return _context8.a(2);
          }
        }, _callee8, this);
      }));
    }
  }, {
    key: "setTrackEnabled",
    value: function setTrackEnabled(source, enabled, options, publishOptions) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee9() {
        var _a, _b, track, localTracks, pendingTrack, publishPromises, _iterator, _step, localTrack, publishedTracks, _publishedTracks, screenAudioTrack, _t5, _t6, _t7;
        return _regenerator().w(function(_context9) {
          while (1) switch (_context9.n) {
            case 0:
              this.log.debug("setTrackEnabled", Object.assign(Object.assign({}, this.logContext), {
                source,
                enabled
              }));
              if (!this.republishPromise) {
                _context9.n = 1;
                break;
              }
              _context9.n = 1;
              return this.republishPromise;
            case 1:
              track = this.getTrackPublication(source);
              if (!enabled) {
                _context9.n = 21;
                break;
              }
              if (!(track && track.track)) {
                _context9.n = 2;
                break;
              }
              this.onTrackMuted(track.track, false);
              _context9.n = 20;
              break;
            case 2:
              if (!this.pendingPublishing.has(source)) {
                _context9.n = 5;
                break;
              }
              _context9.n = 3;
              return this.waitForPendingPublicationOfSource(source);
            case 3:
              pendingTrack = _context9.v;
              if (!pendingTrack) {
                this.log.info("waiting for pending publication promise timed out", Object.assign(Object.assign({}, this.logContext), {
                  source
                }));
              }
              _context9.n = 4;
              return pendingTrack === null || pendingTrack === void 0 ? void 0 : pendingTrack.unmute();
            case 4:
              return _context9.a(2, pendingTrack);
            case 5:
              this.pendingPublishing.add(source);
              _context9.p = 6;
              _t5 = source;
              _context9.n = _t5 === Track.Source.Camera ? 7 : _t5 === Track.Source.Microphone ? 9 : _t5 === Track.Source.ScreenShare ? 11 : 13;
              break;
            case 7:
              _context9.n = 8;
              return this.createTracks({
                video: (_a = options) !== null && _a !== void 0 ? _a : true
              });
            case 8:
              localTracks = _context9.v;
              return _context9.a(3, 14);
            case 9:
              _context9.n = 10;
              return this.createTracks({
                audio: (_b = options) !== null && _b !== void 0 ? _b : true
              });
            case 10:
              localTracks = _context9.v;
              return _context9.a(3, 14);
            case 11:
              _context9.n = 12;
              return this.createScreenTracks(Object.assign({}, options));
            case 12:
              localTracks = _context9.v;
              return _context9.a(3, 14);
            case 13:
              throw new TrackInvalidError(source);
            case 14:
              _context9.n = 16;
              break;
            case 15:
              _context9.p = 15;
              _t6 = _context9.v;
              localTracks === null || localTracks === void 0 ? void 0 : localTracks.forEach(function(tr) {
                tr.stop();
              });
              if (_t6 instanceof Error) {
                this.emit(ParticipantEvent.MediaDevicesError, _t6);
              }
              this.pendingPublishing["delete"](source);
              throw _t6;
            case 16:
              _context9.p = 16;
              publishPromises = [];
              _iterator = _createForOfIteratorHelper(localTracks);
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                  localTrack = _step.value;
                  this.log.info("publishing track", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(localTrack)));
                  publishPromises.push(this.publishTrack(localTrack, publishOptions));
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
              _context9.n = 17;
              return Promise.all(publishPromises);
            case 17:
              publishedTracks = _context9.v;
              _publishedTracks = _slicedToArray(publishedTracks, 1);
              track = _publishedTracks[0];
              _context9.n = 19;
              break;
            case 18:
              _context9.p = 18;
              _t7 = _context9.v;
              localTracks === null || localTracks === void 0 ? void 0 : localTracks.forEach(function(tr) {
                tr.stop();
              });
              throw _t7;
            case 19:
              _context9.p = 19;
              this.pendingPublishing["delete"](source);
              return _context9.f(19);
            case 20:
              _context9.n = 26;
              break;
            case 21:
              if (!(!(track === null || track === void 0 ? void 0 : track.track) && this.pendingPublishing.has(source))) {
                _context9.n = 23;
                break;
              }
              _context9.n = 22;
              return this.waitForPendingPublicationOfSource(source);
            case 22:
              track = _context9.v;
              if (!track) {
                this.log.info("waiting for pending publication promise timed out", Object.assign(Object.assign({}, this.logContext), {
                  source
                }));
              }
            case 23:
              if (!(track && track.track)) {
                _context9.n = 26;
                break;
              }
              if (!(source === Track.Source.ScreenShare)) {
                _context9.n = 25;
                break;
              }
              _context9.n = 24;
              return this.unpublishTrack(track.track);
            case 24:
              track = _context9.v;
              screenAudioTrack = this.getTrackPublication(Track.Source.ScreenShareAudio);
              if (screenAudioTrack && screenAudioTrack.track) {
                this.unpublishTrack(screenAudioTrack.track);
              }
              _context9.n = 26;
              break;
            case 25:
              if (track.source == "microphone") {
                this.audioMuted = true;
              }
              if (track.source == "camera") {
                this.videoMuted = true;
              }
              this.onTrackMuted(track.track, true);
            case 26:
              return _context9.a(2, track);
          }
        }, _callee9, this, [[16, 18, 19, 20], [6, 15]]);
      }));
    }
    /**
     * Publish both camera and microphone at the same time. This is useful for
     * displaying a single Permission Dialog box to the end user.
     */
  }, {
    key: "enableCameraAndMicrophone",
    value: function enableCameraAndMicrophone() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee0() {
        var _this5 = this;
        var tracks;
        return _regenerator().w(function(_context0) {
          while (1) switch (_context0.n) {
            case 0:
              if (!(this.pendingPublishing.has(Track.Source.Camera) || this.pendingPublishing.has(Track.Source.Microphone))) {
                _context0.n = 1;
                break;
              }
              return _context0.a(2);
            case 1:
              this.pendingPublishing.add(Track.Source.Camera);
              this.pendingPublishing.add(Track.Source.Microphone);
              _context0.p = 2;
              _context0.n = 3;
              return this.createTracks({
                audio: true,
                video: true
              });
            case 3:
              tracks = _context0.v;
              _context0.n = 4;
              return Promise.all(tracks.map(function(track) {
                return _this5.publishTrack(track);
              }));
            case 4:
              _context0.p = 4;
              this.pendingPublishing["delete"](Track.Source.Camera);
              this.pendingPublishing["delete"](Track.Source.Microphone);
              return _context0.f(4);
            case 5:
              return _context0.a(2);
          }
        }, _callee0, this, [[2, , 4, 5]]);
      }));
    }
    /**
     * Create local camera and/or microphone tracks
     * @param options
     * @returns
     */
  }, {
    key: "createTracks",
    value: function createTracks(options) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee10() {
        var _this6 = this;
        var _a, _b, _extractProcessorsFro, audioProcessor, videoProcessor, optionsWithoutProcessor, mergedOptions, constraints, stream, _t8;
        return _regenerator().w(function(_context10) {
          while (1) switch (_context10.n) {
            case 0:
              options !== null && options !== void 0 ? options : options = {};
              _extractProcessorsFro = extractProcessorsFromOptions(options), audioProcessor = _extractProcessorsFro.audioProcessor, videoProcessor = _extractProcessorsFro.videoProcessor, optionsWithoutProcessor = _extractProcessorsFro.optionsWithoutProcessor;
              mergedOptions = mergeDefaultOptions(optionsWithoutProcessor, (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.audioCaptureDefaults, (_b = this.roomOptions) === null || _b === void 0 ? void 0 : _b.videoCaptureDefaults);
              constraints = constraintsForOptions(mergedOptions);
              _context10.p = 1;
              _context10.n = 2;
              return navigator.mediaDevices.getUserMedia(constraints);
            case 2:
              stream = _context10.v;
              _context10.n = 4;
              break;
            case 3:
              _context10.p = 3;
              _t8 = _context10.v;
              if (_t8 instanceof Error) {
                if (constraints.audio) {
                  this.microphoneError = _t8;
                }
                if (constraints.video) {
                  this.cameraError = _t8;
                }
              }
              throw _t8;
            case 4:
              if (constraints.audio) {
                this.microphoneError = void 0;
                this.emit(ParticipantEvent.AudioStreamAcquired);
              }
              if (constraints.video) {
                this.cameraError = void 0;
              }
              return _context10.a(2, Promise.all(stream.getTracks().map(function(mediaStreamTrack) {
                return __awaiter(_this6, void 0, void 0, _regenerator().m(function _callee1() {
                  var _this7 = this;
                  var isAudio, trackConstraints, conOrBool, track;
                  return _regenerator().w(function(_context1) {
                    while (1) switch (_context1.n) {
                      case 0:
                        isAudio = mediaStreamTrack.kind === "audio";
                        isAudio ? mergedOptions.audio : mergedOptions.video;
                        conOrBool = isAudio ? constraints.audio : constraints.video;
                        if (typeof conOrBool !== "boolean") {
                          trackConstraints = conOrBool;
                        }
                        track = mediaTrackToLocalTrack(mediaStreamTrack, trackConstraints, {
                          loggerName: this.roomOptions.loggerName,
                          loggerContextCb: function loggerContextCb() {
                            return _this7.logContext;
                          }
                        });
                        if (track.kind === Track.Kind.Video) {
                          track.source = Track.Source.Camera;
                        } else if (track.kind === Track.Kind.Audio) {
                          track.source = Track.Source.Microphone;
                          track.setAudioContext(this.audioContext);
                        }
                        track.mediaStream = stream;
                        if (!(track instanceof LocalAudioTrack && audioProcessor)) {
                          _context1.n = 2;
                          break;
                        }
                        _context1.n = 1;
                        return track.setProcessor(audioProcessor);
                      case 1:
                        _context1.n = 3;
                        break;
                      case 2:
                        if (!(track instanceof LocalVideoTrack && videoProcessor)) {
                          _context1.n = 3;
                          break;
                        }
                        _context1.n = 3;
                        return track.setProcessor(videoProcessor);
                      case 3:
                        return _context1.a(2, track);
                    }
                  }, _callee1, this);
                }));
              })));
          }
        }, _callee10, this, [[1, 3]]);
      }));
    }
    /**
     * Creates a screen capture tracks with getDisplayMedia().
     * A LocalVideoTrack is always created and returned.
     * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.
     */
  }, {
    key: "createScreenTracks",
    value: function createScreenTracks(options) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee11() {
        var _this8 = this;
        var constraints, stream, tracks, screenVideo, localTracks, screenAudio;
        return _regenerator().w(function(_context11) {
          while (1) switch (_context11.n) {
            case 0:
              if (options === void 0) {
                options = {};
              }
              if (!(navigator.mediaDevices.getDisplayMedia === void 0)) {
                _context11.n = 1;
                break;
              }
              throw new DeviceUnsupportedError("getDisplayMedia not supported");
            case 1:
              if (options.resolution === void 0 && !isSafari17()) {
                options.resolution = ScreenSharePresets.h1080fps30.resolution;
              }
              constraints = screenCaptureToDisplayMediaStreamOptions(options);
              _context11.n = 2;
              return navigator.mediaDevices.getDisplayMedia(constraints);
            case 2:
              stream = _context11.v;
              tracks = stream.getVideoTracks();
              if (!(tracks.length === 0)) {
                _context11.n = 3;
                break;
              }
              throw new TrackInvalidError("no video track found");
            case 3:
              screenVideo = new LocalVideoTrack(tracks[0], void 0, false, {
                loggerName: this.roomOptions.loggerName,
                loggerContextCb: function loggerContextCb() {
                  return _this8.logContext;
                }
              });
              screenVideo.source = Track.Source.ScreenShare;
              if (options.contentHint) {
                screenVideo.mediaStreamTrack.contentHint = options.contentHint;
              }
              localTracks = [screenVideo];
              if (stream.getAudioTracks().length > 0) {
                this.emit(ParticipantEvent.AudioStreamAcquired);
                screenAudio = new LocalAudioTrack(stream.getAudioTracks()[0], void 0, false, this.audioContext, {
                  loggerName: this.roomOptions.loggerName,
                  loggerContextCb: function loggerContextCb() {
                    return _this8.logContext;
                  }
                });
                screenAudio.source = Track.Source.ScreenShareAudio;
                localTracks.push(screenAudio);
              }
              return _context11.a(2, localTracks);
          }
        }, _callee11, this);
      }));
    }
    /**
     * Publish a new track to the room
     * @param track
     * @param options
     */
  }, {
    key: "publishTrack",
    value: function publishTrack(track, options) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee12() {
        return _regenerator().w(function(_context12) {
          while (1) switch (_context12.n) {
            case 0:
              return _context12.a(2, this.publishOrRepublishTrack(track, options));
          }
        }, _callee12, this);
      }));
    }
  }, {
    key: "publishOrRepublishTrack",
    value: function publishOrRepublishTrack(track_1, options_1) {
      return __awaiter(this, arguments, void 0, function(track, options) {
        var _this9 = this;
        var isRepublish = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        return _regenerator().m(function _callee13() {
          var _a, _b, _c, _d, defaultConstraints, deviceKind, existingPublication, isStereoInput, isStereo, opts, publishPromise, publication, _t9, _t0, _t1;
          return _regenerator().w(function(_context13) {
            while (1) switch (_context13.n) {
              case 0:
                if (track instanceof LocalAudioTrack) {
                  track.setAudioContext(_this9.audioContext);
                }
                _context13.n = 1;
                return (_a = _this9.reconnectFuture) === null || _a === void 0 ? void 0 : _a.promise;
              case 1:
                if (!(_this9.republishPromise && !isRepublish)) {
                  _context13.n = 2;
                  break;
                }
                _context13.n = 2;
                return _this9.republishPromise;
              case 2:
                if (!(track instanceof LocalTrack && _this9.pendingPublishPromises.has(track))) {
                  _context13.n = 3;
                  break;
                }
                _context13.n = 3;
                return _this9.pendingPublishPromises.get(track);
              case 3:
                if (!(track instanceof MediaStreamTrack)) {
                  _context13.n = 4;
                  break;
                }
                defaultConstraints = track.getConstraints();
                _context13.n = 9;
                break;
              case 4:
                defaultConstraints = track.constraints;
                deviceKind = void 0;
                _t9 = track.source;
                _context13.n = _t9 === Track.Source.Microphone ? 5 : _t9 === Track.Source.Camera ? 6 : 7;
                break;
              case 5:
                deviceKind = "audioinput";
                return _context13.a(3, 8);
              case 6:
                deviceKind = "videoinput";
              case 7:
                return _context13.a(3, 8);
              case 8:
                if (deviceKind && _this9.activeDeviceMap.has(deviceKind)) {
                  defaultConstraints = Object.assign(Object.assign({}, defaultConstraints), {
                    deviceId: _this9.activeDeviceMap.get(deviceKind)
                  });
                }
              case 9:
                if (!(track instanceof MediaStreamTrack)) {
                  _context13.n = 14;
                  break;
                }
                _t0 = track.kind;
                _context13.n = _t0 === "audio" ? 10 : _t0 === "video" ? 11 : 12;
                break;
              case 10:
                track = new LocalAudioTrack(track, defaultConstraints, true, _this9.audioContext, {
                  loggerName: _this9.roomOptions.loggerName,
                  loggerContextCb: function loggerContextCb() {
                    return _this9.logContext;
                  }
                });
                return _context13.a(3, 13);
              case 11:
                track = new LocalVideoTrack(track, defaultConstraints, true, {
                  loggerName: _this9.roomOptions.loggerName,
                  loggerContextCb: function loggerContextCb() {
                    return _this9.logContext;
                  }
                });
                return _context13.a(3, 13);
              case 12:
                throw new TrackInvalidError("unsupported MediaStreamTrack kind ".concat(track.kind));
              case 13:
                _context13.n = 15;
                break;
              case 14:
                track.updateLoggerOptions({
                  loggerName: _this9.roomOptions.loggerName,
                  loggerContextCb: function loggerContextCb() {
                    return _this9.logContext;
                  }
                });
              case 15:
                _this9.trackPublications.forEach(function(publication2) {
                  if (!publication2.track) {
                    return;
                  }
                  if (publication2.track === track) {
                    existingPublication = publication2;
                  }
                });
                if (!existingPublication) {
                  _context13.n = 16;
                  break;
                }
                _this9.log.warn("track has already been published, skipping", Object.assign(Object.assign({}, _this9.logContext), getLogContextFromTrack(existingPublication)));
                return _context13.a(2, existingPublication);
              case 16:
                isStereoInput = "channelCount" in track.mediaStreamTrack.getSettings() && // @ts-ignore `channelCount` on getSettings() is currently only available for Safari, but is generally the best way to determine a stereo track https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings/channelCount
                track.mediaStreamTrack.getSettings().channelCount === 2 || track.mediaStreamTrack.getConstraints().channelCount === 2;
                isStereo = (_b = options === null || options === void 0 ? void 0 : options.forceStereo) !== null && _b !== void 0 ? _b : isStereoInput;
                if (isStereo) {
                  if (!options) {
                    options = {};
                  }
                  if (options.dtx === void 0) {
                    _this9.log.info("Opus DTX will be disabled for stereo tracks by default. Enable them explicitly to make it work.", Object.assign(Object.assign({}, _this9.logContext), getLogContextFromTrack(track)));
                  }
                  if (options.red === void 0) {
                    _this9.log.info("Opus RED will be disabled for stereo tracks by default. Enable them explicitly to make it work.");
                  }
                  (_c = options.dtx) !== null && _c !== void 0 ? _c : options.dtx = false;
                  (_d = options.red) !== null && _d !== void 0 ? _d : options.red = false;
                }
                opts = Object.assign(Object.assign({}, _this9.roomOptions.publishDefaults), options);
                if (!isE2EESimulcastSupported() && _this9.roomOptions.e2ee) {
                  _this9.log.info("End-to-end encryption is set up, simulcast publishing will be disabled on Safari versions and iOS browsers running iOS < v17.2", Object.assign({}, _this9.logContext));
                  opts.simulcast = false;
                }
                if (opts.source) {
                  track.source = opts.source;
                }
                publishPromise = _this9.publish(track, opts, isStereo);
                _this9.pendingPublishPromises.set(track, publishPromise);
                _context13.p = 17;
                _context13.n = 18;
                return publishPromise;
              case 18:
                publication = _context13.v;
                return _context13.a(2, publication);
              case 19:
                _context13.p = 19;
                _t1 = _context13.v;
                throw _t1;
              case 20:
                _context13.p = 20;
                _this9.pendingPublishPromises["delete"](track);
                return _context13.f(20);
              case 21:
                return _context13.a(2);
            }
          }, _callee13, null, [[17, 19, 20, 21]]);
        })();
      });
    }
  }, {
    key: "publish",
    value: function publish(track, opts, isStereo) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee15() {
        var _this0 = this;
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, existingTrackOfSource, videoCodec, req, encodings, videoEncoding, dims, defaultRes, negotiate, ti, rets, primaryCodecMime, updatedCodec, publication;
        return _regenerator().w(function(_context15) {
          while (1) switch (_context15.n) {
            case 0:
              existingTrackOfSource = Array.from(this.trackPublications.values()).find(function(publishedTrack) {
                return track instanceof LocalTrack && publishedTrack.source === track.source;
              });
              if (existingTrackOfSource && track.source !== Track.Source.Unknown) {
                this.log.info("publishing a second track with the same source: ".concat(track.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
              }
              if (opts.stopMicTrackOnMute && track instanceof LocalAudioTrack) {
                track.stopOnMute = true;
              }
              if (track.source === Track.Source.ScreenShare && isFireFox()) {
                opts.simulcast = false;
              }
              if (opts.videoCodec === "av1" && !supportsAV1()) {
                opts.videoCodec = void 0;
              }
              if (opts.videoCodec === "vp9" && !supportsVP9()) {
                opts.videoCodec = void 0;
              }
              if (opts.videoCodec === void 0) {
                opts.videoCodec = defaultVideoCodec;
              }
              if (this.enabledPublishVideoCodecs.length > 0) {
                if (!this.enabledPublishVideoCodecs.some(function(c) {
                  return opts.videoCodec === mimeTypeToVideoCodecString(c.mime);
                })) {
                  opts.videoCodec = mimeTypeToVideoCodecString(this.enabledPublishVideoCodecs[0].mime);
                }
              }
              videoCodec = opts.videoCodec;
              track.on(TrackEvent.Muted, this.onTrackMuted);
              track.on(TrackEvent.Unmuted, this.onTrackUnmuted);
              track.on(TrackEvent.Ended, this.handleTrackEnded);
              track.on(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);
              track.on(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);
              track.on(TrackEvent.AudioTrackFeatureUpdate, this.onTrackFeatureUpdate);
              req = new AddTrackRequest({
                // get local track id for use during publishing
                cid: track.mediaStreamTrack.id,
                name: opts.name,
                type: Track.kindToProto(track.kind),
                muted: track.isMuted,
                source: Track.sourceToProto(track.source),
                disableDtx: !((_a = opts.dtx) !== null && _a !== void 0 ? _a : true),
                encryption: this.encryptionType,
                stereo: isStereo,
                disableRed: this.isE2EEEnabled || !((_b = opts.red) !== null && _b !== void 0 ? _b : true),
                stream: opts === null || opts === void 0 ? void 0 : opts.stream
              });
              if (!(track.kind === Track.Kind.Video)) {
                _context15.n = 5;
                break;
              }
              dims = {
                width: 0,
                height: 0
              };
              _context15.p = 1;
              _context15.n = 2;
              return track.waitForDimensions();
            case 2:
              dims = _context15.v;
              _context15.n = 4;
              break;
            case 3:
              _context15.p = 3;
              _context15.v;
              defaultRes = (_d = (_c = this.roomOptions.videoCaptureDefaults) === null || _c === void 0 ? void 0 : _c.resolution) !== null && _d !== void 0 ? _d : VideoPresets.h720.resolution;
              dims = {
                width: defaultRes.width,
                height: defaultRes.height
              };
              this.log.error("could not determine track dimensions, using defaults", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)), {
                dims
              }));
            case 4:
              req.width = dims.width;
              req.height = dims.height;
              if (track instanceof LocalVideoTrack) {
                if (isSVCCodec(videoCodec)) {
                  if (track.source === Track.Source.ScreenShare) {
                    opts.scalabilityMode = "L1T3";
                    if ("contentHint" in track.mediaStreamTrack) {
                      track.mediaStreamTrack.contentHint = "motion";
                      this.log.info("forcing contentHint to motion for screenshare with SVC codecs", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
                    }
                  }
                  opts.scalabilityMode = (_e = opts.scalabilityMode) !== null && _e !== void 0 ? _e : "L3T3_KEY";
                }
                req.simulcastCodecs = [new SimulcastCodec({
                  codec: videoCodec,
                  cid: track.mediaStreamTrack.id
                })];
                if (opts.backupCodec === true) {
                  opts.backupCodec = {
                    codec: defaultVideoCodec
                  };
                }
                if (opts.backupCodec && videoCodec !== opts.backupCodec.codec && // TODO remove this once e2ee is supported for backup codecs
                req.encryption === Encryption_Type.NONE) {
                  if (!this.roomOptions.dynacast) {
                    this.roomOptions.dynacast = true;
                  }
                  req.simulcastCodecs.push(new SimulcastCodec({
                    codec: opts.backupCodec.codec,
                    cid: ""
                  }));
                } else if (opts.videoCodec) {
                  req.simulcastCodecs = [new SimulcastCodec({
                    codec: opts.videoCodec,
                    cid: track.mediaStreamTrack.id
                  })];
                }
              }
              encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, req.width, req.height, opts);
              req.layers = videoLayersFromEncodings(req.width, req.height, encodings, isSVCCodec(opts.videoCodec));
              if (encodings.length == 1) {
                videoEncoding = determineAppropriateEncoding(track.source === Track.Source.ScreenShare, req.width, req.height, opts.videoCodec);
                encodings = [{
                  maxBitrate: videoEncoding.maxBitrate,
                  maxFramerate: videoEncoding.maxFramerate,
                  active: true
                }];
              }
              _context15.n = 6;
              break;
            case 5:
              if (track.kind === Track.Kind.Audio && opts.audioBitrate) {
                encodings = [{
                  maxBitrate: (_f = opts.audioPreset) === null || _f === void 0 ? void 0 : _f.maxBitrate,
                  priority: (_h = (_g = opts.audioPreset) === null || _g === void 0 ? void 0 : _g.priority) !== null && _h !== void 0 ? _h : "high",
                  networkPriority: (_k = (_j = opts.audioPreset) === null || _j === void 0 ? void 0 : _j.priority) !== null && _k !== void 0 ? _k : "high"
                }];
              }
            case 6:
              if (!(!this.engine || this.engine.isClosed)) {
                _context15.n = 7;
                break;
              }
              throw new UnexpectedConnectionState("cannot publish track when not connected");
            case 7:
              negotiate = function negotiate2() {
                return __awaiter(_this0, void 0, void 0, _regenerator().m(function _callee14() {
                  var _a2, _b2, _c2, trackTransceiver, _iterator2, _step2, transceiver, _t10;
                  return _regenerator().w(function(_context14) {
                    while (1) switch (_context14.n) {
                      case 0:
                        if (this.engine.pcManager) {
                          _context14.n = 1;
                          break;
                        }
                        throw new UnexpectedConnectionState("pcManager is not ready");
                      case 1:
                        _context14.n = 2;
                        return this.engine.createSender(track, opts, encodings);
                      case 2:
                        track.sender = _context14.v;
                        if (track instanceof LocalVideoTrack) {
                          (_a2 = opts.degradationPreference) !== null && _a2 !== void 0 ? _a2 : opts.degradationPreference = getDefaultDegradationPreference(track);
                          track.setDegradationPreference(opts.degradationPreference);
                        }
                        if (!encodings) {
                          _context14.n = 11;
                          break;
                        }
                        if (!(isFireFox() && track.kind === Track.Kind.Audio)) {
                          _context14.n = 10;
                          break;
                        }
                        trackTransceiver = void 0;
                        _iterator2 = _createForOfIteratorHelper(this.engine.pcManager.publisher.getTransceivers());
                        _context14.p = 3;
                        _iterator2.s();
                      case 4:
                        if ((_step2 = _iterator2.n()).done) {
                          _context14.n = 6;
                          break;
                        }
                        transceiver = _step2.value;
                        if (!(transceiver.sender === track.sender)) {
                          _context14.n = 5;
                          break;
                        }
                        trackTransceiver = transceiver;
                        return _context14.a(3, 6);
                      case 5:
                        _context14.n = 4;
                        break;
                      case 6:
                        _context14.n = 8;
                        break;
                      case 7:
                        _context14.p = 7;
                        _t10 = _context14.v;
                        _iterator2.e(_t10);
                      case 8:
                        _context14.p = 8;
                        _iterator2.f();
                        return _context14.f(8);
                      case 9:
                        if (trackTransceiver) {
                          this.engine.pcManager.publisher.setTrackCodecBitrate({
                            transceiver: trackTransceiver,
                            codec: "opus",
                            maxbr: ((_b2 = encodings[0]) === null || _b2 === void 0 ? void 0 : _b2.maxBitrate) ? encodings[0].maxBitrate / 1e3 : 0
                          });
                        }
                        _context14.n = 11;
                        break;
                      case 10:
                        if (track.codec && isSVCCodec(track.codec) && ((_c2 = encodings[0]) === null || _c2 === void 0 ? void 0 : _c2.maxBitrate)) {
                          this.engine.pcManager.publisher.setTrackCodecBitrate({
                            cid: req.cid,
                            codec: track.codec,
                            maxbr: encodings[0].maxBitrate / 1e3
                          });
                        }
                      case 11:
                        _context14.n = 12;
                        return this.engine.negotiate();
                      case 12:
                        return _context14.a(2);
                    }
                  }, _callee14, this, [[3, 7, 8, 9]]);
                }));
              };
              if (!(this.enabledPublishVideoCodecs.length > 0)) {
                _context15.n = 9;
                break;
              }
              _context15.n = 8;
              return Promise.all([this.engine.addTrack(req), negotiate()]);
            case 8:
              rets = _context15.v;
              ti = rets[0];
              _context15.n = 11;
              break;
            case 9:
              _context15.n = 10;
              return this.engine.addTrack(req);
            case 10:
              ti = _context15.v;
              ti.codecs.forEach(function(codec) {
                if (primaryCodecMime === void 0) {
                  primaryCodecMime = codec.mimeType;
                }
              });
              if (primaryCodecMime && track.kind === Track.Kind.Video) {
                updatedCodec = mimeTypeToVideoCodecString(primaryCodecMime);
                if (updatedCodec !== videoCodec) {
                  this.log.debug("falling back to server selected codec", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)), {
                    codec: updatedCodec
                  }));
                  opts.videoCodec = updatedCodec;
                  encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, req.width, req.height, opts);
                }
              }
              _context15.n = 11;
              return negotiate();
            case 11:
              publication = new LocalTrackPublication(track.kind, ti, track, {
                loggerName: this.roomOptions.loggerName,
                loggerContextCb: function loggerContextCb() {
                  return _this0.logContext;
                }
              });
              publication.options = opts;
              track.sid = ti.sid;
              this.log.debug("publishing ".concat(track.kind, " with encodings"), Object.assign(Object.assign({}, this.logContext), {
                encodings,
                trackInfo: ti
              }));
              if (track instanceof LocalVideoTrack) {
                track.startMonitor(this.engine.client);
              } else if (track instanceof LocalAudioTrack) {
                track.startMonitor();
              }
              this.addTrackPublication(publication);
              this.emit(ParticipantEvent.LocalTrackPublished, publication);
              return _context15.a(2, publication);
          }
        }, _callee15, this, [[1, 3]]);
      }));
    }
  }, {
    key: "isLocal",
    get: function get2() {
      return true;
    }
    /** @internal
     * publish additional codec to existing track
     */
  }, {
    key: "publishAdditionalCodecForTrack",
    value: function publishAdditionalCodecForTrack(track, videoCodec, options) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee17() {
        var _this1 = this;
        var _a, existingPublication, opts, encodings, simulcastTrack, req, negotiate, rets, ti;
        return _regenerator().w(function(_context17) {
          while (1) switch (_context17.n) {
            case 0:
              if (!(this.encryptionType !== Encryption_Type.NONE)) {
                _context17.n = 1;
                break;
              }
              return _context17.a(2);
            case 1:
              this.trackPublications.forEach(function(publication) {
                if (!publication.track) {
                  return;
                }
                if (publication.track === track) {
                  existingPublication = publication;
                }
              });
              if (existingPublication) {
                _context17.n = 2;
                break;
              }
              throw new TrackInvalidError("track is not published");
            case 2:
              if (track instanceof LocalVideoTrack) {
                _context17.n = 3;
                break;
              }
              throw new TrackInvalidError("track is not a video track");
            case 3:
              opts = Object.assign(Object.assign({}, (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.publishDefaults), options);
              encodings = computeTrackBackupEncodings(track, videoCodec, opts);
              if (encodings) {
                _context17.n = 4;
                break;
              }
              this.log.info("backup codec has been disabled, ignoring request to add additional codec for track", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
              return _context17.a(2);
            case 4:
              simulcastTrack = track.addSimulcastTrack(videoCodec, encodings);
              if (simulcastTrack) {
                _context17.n = 5;
                break;
              }
              return _context17.a(2);
            case 5:
              req = new AddTrackRequest({
                cid: simulcastTrack.mediaStreamTrack.id,
                type: Track.kindToProto(track.kind),
                muted: track.isMuted,
                source: Track.sourceToProto(track.source),
                sid: track.sid,
                simulcastCodecs: [{
                  codec: opts.videoCodec,
                  cid: simulcastTrack.mediaStreamTrack.id
                }]
              });
              req.layers = videoLayersFromEncodings(req.width, req.height, encodings);
              if (!(!this.engine || this.engine.isClosed)) {
                _context17.n = 6;
                break;
              }
              throw new UnexpectedConnectionState("cannot publish track when not connected");
            case 6:
              negotiate = function negotiate2() {
                return __awaiter(_this1, void 0, void 0, _regenerator().m(function _callee16() {
                  var transceiverInit;
                  return _regenerator().w(function(_context16) {
                    while (1) switch (_context16.n) {
                      case 0:
                        transceiverInit = {
                          direction: "sendonly"
                        };
                        if (encodings) {
                          transceiverInit.sendEncodings = encodings;
                        }
                        _context16.n = 1;
                        return this.engine.createSimulcastSender(track, simulcastTrack, opts, encodings);
                      case 1:
                        _context16.n = 2;
                        return this.engine.negotiate();
                      case 2:
                        return _context16.a(2);
                    }
                  }, _callee16, this);
                }));
              };
              _context17.n = 7;
              return Promise.all([this.engine.addTrack(req), negotiate()]);
            case 7:
              rets = _context17.v;
              ti = rets[0];
              this.log.debug("published ".concat(videoCodec, " for track ").concat(track.sid), Object.assign(Object.assign({}, this.logContext), {
                encodings,
                trackInfo: ti
              }));
            case 8:
              return _context17.a(2);
          }
        }, _callee17, this);
      }));
    }
  }, {
    key: "unpublishTrack",
    value: function unpublishTrack(track, stopOnUnpublish) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee18() {
        var _a, _b, publishPromise, publication, pubLogContext, trackSender, negotiationNeeded, _iterator3, _step3, transceiver, _iterator4, _step4, _step4$value, trackInfo, _t12;
        return _regenerator().w(function(_context18) {
          while (1) switch (_context18.n) {
            case 0:
              if (!(track instanceof LocalTrack)) {
                _context18.n = 1;
                break;
              }
              publishPromise = this.pendingPublishPromises.get(track);
              if (!publishPromise) {
                _context18.n = 1;
                break;
              }
              this.log.info("awaiting publish promise before attempting to unpublish", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));
              _context18.n = 1;
              return publishPromise;
            case 1:
              publication = this.getPublicationForTrack(track);
              pubLogContext = publication ? getLogContextFromTrack(publication) : void 0;
              this.log.debug("unpublishing track", Object.assign(Object.assign({}, this.logContext), pubLogContext));
              if (!(!publication || !publication.track)) {
                _context18.n = 2;
                break;
              }
              this.log.warn("track was not unpublished because no publication was found", Object.assign(Object.assign({}, this.logContext), pubLogContext));
              return _context18.a(2, void 0);
            case 2:
              track = publication.track;
              track.off(TrackEvent.Muted, this.onTrackMuted);
              track.off(TrackEvent.Unmuted, this.onTrackUnmuted);
              track.off(TrackEvent.Ended, this.handleTrackEnded);
              track.off(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);
              track.off(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);
              track.off(TrackEvent.AudioTrackFeatureUpdate, this.onTrackFeatureUpdate);
              trackSender = track.sender;
              track.sender = void 0;
              if (!(track.isUpstreamPaused && track.mediaStreamTrack && trackSender)) {
                _context18.n = 3;
                break;
              }
              _context18.n = 3;
              return trackSender.replaceTrack(track.mediaStreamTrack);
            case 3:
              if (stopOnUnpublish === void 0) {
                stopOnUnpublish = (_b = (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.stopLocalTrackOnUnpublish) !== null && _b !== void 0 ? _b : true;
              }
              if (stopOnUnpublish) {
                track.stop();
              } else {
                track.stopMonitor();
              }
              negotiationNeeded = false;
              if (this.engine.pcManager && this.engine.pcManager.currentState < PCTransportState.FAILED && trackSender) {
                try {
                  _iterator3 = _createForOfIteratorHelper(this.engine.pcManager.publisher.getTransceivers());
                  try {
                    for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
                      transceiver = _step3.value;
                      if (transceiver.sender === trackSender) {
                        transceiver.direction = "inactive";
                        negotiationNeeded = true;
                      }
                    }
                  } catch (err) {
                    _iterator3.e(err);
                  } finally {
                    _iterator3.f();
                  }
                  if (this.engine.removeTrack(trackSender)) {
                    negotiationNeeded = true;
                  }
                  if (track instanceof LocalVideoTrack) {
                    _iterator4 = _createForOfIteratorHelper(track.simulcastCodecs);
                    try {
                      for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
                        _step4$value = _slicedToArray(_step4.value, 2), trackInfo = _step4$value[1];
                        if (trackInfo.sender) {
                          if (this.engine.removeTrack(trackInfo.sender)) {
                            negotiationNeeded = true;
                          }
                          trackInfo.sender = void 0;
                        }
                      }
                    } catch (err) {
                      _iterator4.e(err);
                    } finally {
                      _iterator4.f();
                    }
                    track.simulcastCodecs.clear();
                  }
                } catch (e) {
                  this.log.warn("failed to unpublish track", Object.assign(Object.assign(Object.assign({}, this.logContext), pubLogContext), {
                    error: e
                  }));
                }
              }
              this.trackPublications["delete"](publication.trackSid);
              _t12 = publication.kind;
              _context18.n = _t12 === Track.Kind.Audio ? 4 : _t12 === Track.Kind.Video ? 5 : 6;
              break;
            case 4:
              this.audioTrackPublications["delete"](publication.trackSid);
              return _context18.a(3, 7);
            case 5:
              this.videoTrackPublications["delete"](publication.trackSid);
              return _context18.a(3, 7);
            case 6:
              return _context18.a(3, 7);
            case 7:
              this.emit(ParticipantEvent.LocalTrackUnpublished, publication);
              publication.setTrack(void 0);
              if (!negotiationNeeded) {
                _context18.n = 8;
                break;
              }
              _context18.n = 8;
              return this.engine.negotiate();
            case 8:
              return _context18.a(2, publication);
          }
        }, _callee18, this);
      }));
    }
  }, {
    key: "sendChatMessage",
    value: function sendChatMessage(text) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee19() {
        var msg, packet;
        return _regenerator().w(function(_context19) {
          while (1) switch (_context19.n) {
            case 0:
              msg = {
                id: crypto.randomUUID(),
                message: text,
                timestamp: Date.now()
              };
              packet = new DataPacket({
                value: {
                  "case": "chatMessage",
                  value: new ChatMessage(Object.assign(Object.assign({}, msg), {
                    timestamp: protoInt64.parse(msg.timestamp)
                  }))
                }
              });
              _context19.n = 1;
              return this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
            case 1:
              this.emit(ParticipantEvent.ChatMessage, msg);
              return _context19.a(2, msg);
          }
        }, _callee19, this);
      }));
    }
  }, {
    key: "editChatMessage",
    value: function editChatMessage(editText, originalMessage) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee20() {
        var msg, packet;
        return _regenerator().w(function(_context20) {
          while (1) switch (_context20.n) {
            case 0:
              msg = Object.assign(Object.assign({}, originalMessage), {
                message: editText,
                editTimestamp: Date.now()
              });
              packet = new DataPacket({
                value: {
                  "case": "chatMessage",
                  value: new ChatMessage(Object.assign(Object.assign({}, msg), {
                    timestamp: protoInt64.parse(msg.timestamp),
                    editTimestamp: protoInt64.parse(msg.editTimestamp)
                  }))
                }
              });
              _context20.n = 1;
              return this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
            case 1:
              this.emit(ParticipantEvent.ChatMessage, msg);
              return _context20.a(2, msg);
          }
        }, _callee20, this);
      }));
    }
  }, {
    key: "unpublishTracks",
    value: function unpublishTracks(tracks) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee21() {
        var _this10 = this;
        var results;
        return _regenerator().w(function(_context21) {
          while (1) switch (_context21.n) {
            case 0:
              _context21.n = 1;
              return Promise.all(tracks.map(function(track) {
                return _this10.unpublishTrack(track);
              }));
            case 1:
              results = _context21.v;
              return _context21.a(2, results.filter(function(track) {
                return track instanceof LocalTrackPublication;
              }));
          }
        }, _callee21);
      }));
    }
  }, {
    key: "republishAllTracks",
    value: function republishAllTracks(options_1) {
      return __awaiter(this, arguments, void 0, function(options) {
        var _this11 = this;
        var restartTracks = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        return _regenerator().m(function _callee24() {
          return _regenerator().w(function(_context24) {
            while (1) switch (_context24.n) {
              case 0:
                if (!_this11.republishPromise) {
                  _context24.n = 1;
                  break;
                }
                _context24.n = 1;
                return _this11.republishPromise;
              case 1:
                _this11.republishPromise = new Promise(function(resolve, reject) {
                  return __awaiter(_this11, void 0, void 0, _regenerator().m(function _callee23() {
                    var _this12 = this;
                    var localPubs, _t13;
                    return _regenerator().w(function(_context23) {
                      while (1) switch (_context23.n) {
                        case 0:
                          _context23.p = 0;
                          localPubs = [];
                          this.trackPublications.forEach(function(pub) {
                            if (pub.track) {
                              if (options) {
                                pub.options = Object.assign(Object.assign({}, pub.options), options);
                              }
                              localPubs.push(pub);
                            }
                          });
                          _context23.n = 1;
                          return Promise.all(localPubs.map(function(pub) {
                            return __awaiter(_this12, void 0, void 0, _regenerator().m(function _callee22() {
                              var track;
                              return _regenerator().w(function(_context22) {
                                while (1) switch (_context22.n) {
                                  case 0:
                                    track = pub.track;
                                    _context22.n = 1;
                                    return this.unpublishTrack(track, false);
                                  case 1:
                                    if (!(restartTracks && !track.isMuted && track.source !== Track.Source.ScreenShare && track.source !== Track.Source.ScreenShareAudio && (track instanceof LocalAudioTrack || track instanceof LocalVideoTrack) && !track.isUserProvided)) {
                                      _context22.n = 2;
                                      break;
                                    }
                                    this.log.debug("restarting existing track", Object.assign(Object.assign({}, this.logContext), {
                                      track: pub.trackSid
                                    }));
                                    _context22.n = 2;
                                    return track.restartTrack();
                                  case 2:
                                    _context22.n = 3;
                                    return this.publishOrRepublishTrack(track, pub.options, true);
                                  case 3:
                                    return _context22.a(2);
                                }
                              }, _callee22, this);
                            }));
                          }));
                        case 1:
                          resolve();
                          _context23.n = 3;
                          break;
                        case 2:
                          _context23.p = 2;
                          _t13 = _context23.v;
                          reject(_t13);
                        case 3:
                          _context23.p = 3;
                          this.republishPromise = void 0;
                          return _context23.f(3);
                        case 4:
                          return _context23.a(2);
                      }
                    }, _callee23, this, [[0, 2, 3, 4]]);
                  }));
                });
                _context24.n = 2;
                return _this11.republishPromise;
              case 2:
                return _context24.a(2);
            }
          }, _callee24);
        })();
      });
    }
    /**
     * Publish a new data payload to the room. Data will be forwarded to each
     * participant in the room if the destination field in publishOptions is empty
     *
     * @param data Uint8Array of the payload. To send string data, use TextEncoder.encode
     * @param options optionally specify a `reliable`, `topic` and `destination`
     */
  }, {
    key: "publishData",
    value: function publishData(data_1) {
      return __awaiter(this, arguments, void 0, function(data) {
        var _this13 = this;
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return _regenerator().m(function _callee25() {
          var kind, destinationIdentities, topic, packet;
          return _regenerator().w(function(_context25) {
            while (1) switch (_context25.n) {
              case 0:
                kind = options.reliable ? DataPacket_Kind.RELIABLE : DataPacket_Kind.LOSSY;
                destinationIdentities = options.destinationIdentities;
                topic = options.topic;
                packet = new DataPacket({
                  kind,
                  value: {
                    "case": "user",
                    value: new UserPacket({
                      participantIdentity: _this13.identity,
                      payload: data,
                      destinationIdentities,
                      destinationSids: destinationIdentities,
                      topic
                    })
                  }
                });
                _context25.n = 1;
                return _this13.engine.sendDataPacket(packet, kind);
              case 1:
                return _context25.a(2);
            }
          }, _callee25);
        })();
      });
    }
    /**
    * Publish SIP DTMF message to the room.
    *
    * @param code DTMF code
    * @param digit DTMF digit
    */
  }, {
    key: "publishDtmf",
    value: function publishDtmf(code, digit) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee26() {
        var packet;
        return _regenerator().w(function(_context26) {
          while (1) switch (_context26.n) {
            case 0:
              packet = new DataPacket({
                kind: DataPacket_Kind.RELIABLE,
                value: {
                  "case": "sipDtmf",
                  value: new SipDTMF({
                    code,
                    digit
                  })
                }
              });
              _context26.n = 1;
              return this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
            case 1:
              return _context26.a(2);
          }
        }, _callee26, this);
      }));
    }
    /**
     * Initiate an RPC call to a remote participant.
     * @param destinationIdentity - The `identity` of the destination participant
     * @param method - The method name to call
     * @param payload - The method payload
     * @param responseTimeoutMs - Timeout for receiving a response after initial connection
     * @returns A promise that resolves with the response payload or rejects with an error.
     * @throws Error on failure. Details in `message`.
     */
  }, {
    key: "performRpc",
    value: function performRpc(destinationIdentity_1, method_1, payload_1) {
      return __awaiter(this, arguments, void 0, function(destinationIdentity, method, payload) {
        var _this14 = this;
        var responseTimeoutMs = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1e4;
        return _regenerator().m(function _callee28() {
          var maxRoundTripLatencyMs;
          return _regenerator().w(function(_context28) {
            while (1) switch (_context28.n) {
              case 0:
                maxRoundTripLatencyMs = 2e3;
                return _context28.a(2, new Promise(function(_resolve, reject) {
                  return __awaiter(_this14, void 0, void 0, _regenerator().m(function _callee27() {
                    var _this15 = this;
                    var _a, _b, _c, _d, id, ackTimeoutId, responseTimeoutId;
                    return _regenerator().w(function(_context27) {
                      while (1) switch (_context27.n) {
                        case 0:
                          if (!(byteLength(payload) > MAX_PAYLOAD_BYTES)) {
                            _context27.n = 1;
                            break;
                          }
                          reject(RpcError.builtIn("REQUEST_PAYLOAD_TOO_LARGE"));
                          return _context27.a(2);
                        case 1:
                          if (!(((_b = (_a = this.engine.latestJoinResponse) === null || _a === void 0 ? void 0 : _a.serverInfo) === null || _b === void 0 ? void 0 : _b.version) && compareVersions((_d = (_c = this.engine.latestJoinResponse) === null || _c === void 0 ? void 0 : _c.serverInfo) === null || _d === void 0 ? void 0 : _d.version, "1.8.0") < 0)) {
                            _context27.n = 2;
                            break;
                          }
                          reject(RpcError.builtIn("UNSUPPORTED_SERVER"));
                          return _context27.a(2);
                        case 2:
                          id = crypto.randomUUID();
                          _context27.n = 3;
                          return this.publishRpcRequest(destinationIdentity, id, method, payload, responseTimeoutMs - maxRoundTripLatencyMs);
                        case 3:
                          ackTimeoutId = setTimeout(function() {
                            _this15.pendingAcks["delete"](id);
                            reject(RpcError.builtIn("CONNECTION_TIMEOUT"));
                            _this15.pendingResponses["delete"](id);
                            clearTimeout(responseTimeoutId);
                          }, maxRoundTripLatencyMs);
                          this.pendingAcks.set(id, {
                            resolve: function resolve() {
                              clearTimeout(ackTimeoutId);
                            },
                            participantIdentity: destinationIdentity
                          });
                          responseTimeoutId = setTimeout(function() {
                            _this15.pendingResponses["delete"](id);
                            reject(RpcError.builtIn("RESPONSE_TIMEOUT"));
                          }, responseTimeoutMs);
                          this.pendingResponses.set(id, {
                            resolve: function resolve(responsePayload, responseError) {
                              clearTimeout(responseTimeoutId);
                              if (_this15.pendingAcks.has(id)) {
                                console.warn("RPC response received before ack", id);
                                _this15.pendingAcks["delete"](id);
                                clearTimeout(ackTimeoutId);
                              }
                              if (responseError) {
                                reject(responseError);
                              } else {
                                _resolve(responsePayload !== null && responsePayload !== void 0 ? responsePayload : "");
                              }
                            },
                            participantIdentity: destinationIdentity
                          });
                        case 4:
                          return _context27.a(2);
                      }
                    }, _callee27, this);
                  }));
                }));
            }
          }, _callee28);
        })();
      });
    }
    /**
     * Establishes the participant as a receiver for calls of the specified RPC method.
     * Will overwrite any existing callback for the same method.
     *
     * @param method - The name of the indicated RPC method
     * @param handler - Will be invoked when an RPC request for this method is received
     * @returns A promise that resolves when the method is successfully registered
     *
     * @example
     * ```typescript
     * room.localParticipant?.registerRpcMethod(
     *   'greet',
     *   async (requestId: string, callerIdentity: string, payload: string, responseTimeoutMs: number) => {
     *     console.log(`Received greeting from ${callerIdentity}: ${payload}`);
     *     return `Hello, ${callerIdentity}!`;
     *   }
     * );
     * ```
     *
     * The handler receives the following parameters:
     * - `requestId`: A unique identifier for this RPC request
     * - `callerIdentity`: The identity of the RemoteParticipant who initiated the RPC call
     * - `payload`: The data sent by the caller (as a string)
     * - `responseTimeoutMs`: The maximum time available to return a response
     *
     * The handler should return a Promise that resolves to a string.
     * If unable to respond within `responseTimeoutMs`, the request will result in an error on the caller's side.
     *
     * You may throw errors of type `RpcError` with a string `message` in the handler,
     * and they will be received on the caller's side with the message intact.
     * Other errors thrown in your handler will not be transmitted as-is, and will instead arrive to the caller as `1500` ("Application Error").
     */
  }, {
    key: "registerRpcMethod",
    value: function registerRpcMethod(method, handler) {
      this.rpcHandlers.set(method, handler);
    }
    /**
     * Unregisters a previously registered RPC method.
     *
     * @param method - The name of the RPC method to unregister
     */
  }, {
    key: "unregisterRpcMethod",
    value: function unregisterRpcMethod(method) {
      this.rpcHandlers["delete"](method);
    }
    /**
     * Control who can subscribe to LocalParticipant's published tracks.
     *
     * By default, all participants can subscribe. This allows fine-grained control over
     * who is able to subscribe at a participant and track level.
     *
     * Note: if access is given at a track-level (i.e. both [allParticipantsAllowed] and
     * [ParticipantTrackPermission.allTracksAllowed] are false), any newer published tracks
     * will not grant permissions to any participants and will require a subsequent
     * permissions update to allow subscription.
     *
     * @param allParticipantsAllowed Allows all participants to subscribe all tracks.
     *  Takes precedence over [[participantTrackPermissions]] if set to true.
     *  By default this is set to true.
     * @param participantTrackPermissions Full list of individual permissions per
     *  participant/track. Any omitted participants will not receive any permissions.
     */
  }, {
    key: "setTrackSubscriptionPermissions",
    value: function setTrackSubscriptionPermissions(allParticipantsAllowed) {
      var participantTrackPermissions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      this.participantTrackPermissions = participantTrackPermissions;
      this.allParticipantsAllowedToSubscribe = allParticipantsAllowed;
      if (!this.engine.client.isDisconnected) {
        this.updateTrackSubscriptionPermissions();
      }
    }
  }, {
    key: "handleIncomingRpcAck",
    value: function handleIncomingRpcAck(requestId) {
      var handler = this.pendingAcks.get(requestId);
      if (handler) {
        handler.resolve();
        this.pendingAcks["delete"](requestId);
      } else {
        console.error("Ack received for unexpected RPC request", requestId);
      }
    }
  }, {
    key: "handleIncomingRpcResponse",
    value: function handleIncomingRpcResponse(requestId, payload, error) {
      var handler = this.pendingResponses.get(requestId);
      if (handler) {
        handler.resolve(payload, error);
        this.pendingResponses["delete"](requestId);
      } else {
        console.error("Response received for unexpected RPC request", requestId);
      }
    }
  }, {
    key: "handleIncomingRpcRequest",
    value: function handleIncomingRpcRequest(callerIdentity, requestId, method, payload, responseTimeoutMs) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee29() {
        var handler, responseError, responsePayload, response, _t14;
        return _regenerator().w(function(_context29) {
          while (1) switch (_context29.n) {
            case 0:
              _context29.n = 1;
              return this.publishRpcAck(callerIdentity, requestId);
            case 1:
              handler = this.rpcHandlers.get(method);
              if (handler) {
                _context29.n = 3;
                break;
              }
              _context29.n = 2;
              return this.publishRpcResponse(callerIdentity, requestId, null, RpcError.builtIn("UNSUPPORTED_METHOD"));
            case 2:
              return _context29.a(2);
            case 3:
              responseError = null;
              responsePayload = null;
              _context29.p = 4;
              _context29.n = 5;
              return handler(requestId, callerIdentity, payload, responseTimeoutMs);
            case 5:
              response = _context29.v;
              if (byteLength(response) > MAX_PAYLOAD_BYTES) {
                responseError = RpcError.builtIn("RESPONSE_PAYLOAD_TOO_LARGE");
                console.warn("RPC Response payload too large for ".concat(method));
              } else {
                responsePayload = response;
              }
              _context29.n = 7;
              break;
            case 6:
              _context29.p = 6;
              _t14 = _context29.v;
              if (_t14 instanceof RpcError) {
                responseError = _t14;
              } else {
                console.warn("Uncaught error returned by RPC handler for ".concat(method, ". Returning APPLICATION_ERROR instead."), _t14);
                responseError = RpcError.builtIn("APPLICATION_ERROR");
              }
            case 7:
              _context29.n = 8;
              return this.publishRpcResponse(callerIdentity, requestId, responsePayload, responseError);
            case 8:
              return _context29.a(2);
          }
        }, _callee29, this, [[4, 6]]);
      }));
    }
    /** @internal */
  }, {
    key: "publishRpcRequest",
    value: function publishRpcRequest(destinationIdentity, requestId, method, payload, responseTimeoutMs) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee30() {
        var packet;
        return _regenerator().w(function(_context30) {
          while (1) switch (_context30.n) {
            case 0:
              packet = new DataPacket({
                destinationIdentities: [destinationIdentity],
                kind: DataPacket_Kind.RELIABLE,
                value: {
                  "case": "rpcRequest",
                  value: new RpcRequest({
                    id: requestId,
                    method,
                    payload,
                    responseTimeoutMs
                  })
                }
              });
              _context30.n = 1;
              return this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
            case 1:
              return _context30.a(2);
          }
        }, _callee30, this);
      }));
    }
    /** @internal */
  }, {
    key: "publishRpcResponse",
    value: function publishRpcResponse(destinationIdentity, requestId, payload, error) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee31() {
        var packet;
        return _regenerator().w(function(_context31) {
          while (1) switch (_context31.n) {
            case 0:
              packet = new DataPacket({
                destinationIdentities: [destinationIdentity],
                kind: DataPacket_Kind.RELIABLE,
                value: {
                  "case": "rpcResponse",
                  value: new RpcResponse({
                    requestId,
                    value: error ? {
                      "case": "error",
                      value: error.toProto()
                    } : {
                      "case": "payload",
                      value: payload !== null && payload !== void 0 ? payload : ""
                    }
                  })
                }
              });
              _context31.n = 1;
              return this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
            case 1:
              return _context31.a(2);
          }
        }, _callee31, this);
      }));
    }
    /** @internal */
  }, {
    key: "publishRpcAck",
    value: function publishRpcAck(destinationIdentity, requestId) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee32() {
        var packet;
        return _regenerator().w(function(_context32) {
          while (1) switch (_context32.n) {
            case 0:
              packet = new DataPacket({
                destinationIdentities: [destinationIdentity],
                kind: DataPacket_Kind.RELIABLE,
                value: {
                  "case": "rpcAck",
                  value: new RpcAck({
                    requestId
                  })
                }
              });
              _context32.n = 1;
              return this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);
            case 1:
              return _context32.a(2);
          }
        }, _callee32, this);
      }));
    }
    /** @internal */
  }, {
    key: "handleParticipantDisconnected",
    value: function handleParticipantDisconnected(participantIdentity) {
      var _iterator5 = _createForOfIteratorHelper(this.pendingAcks), _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
          var _step5$value = _slicedToArray(_step5.value, 2), id = _step5$value[0], pendingIdentity = _step5$value[1].participantIdentity;
          if (pendingIdentity === participantIdentity) {
            this.pendingAcks["delete"](id);
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
      var _iterator6 = _createForOfIteratorHelper(this.pendingResponses), _step6;
      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
          var _step6$value = _slicedToArray(_step6.value, 2), _id = _step6$value[0], _step6$value$ = _step6$value[1], _pendingIdentity = _step6$value$.participantIdentity, resolve = _step6$value$.resolve;
          if (_pendingIdentity === participantIdentity) {
            resolve(null, RpcError.builtIn("RECIPIENT_DISCONNECTED"));
            this.pendingResponses["delete"](_id);
          }
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
    }
    /** @internal */
  }, {
    key: "setEnabledPublishCodecs",
    value: function setEnabledPublishCodecs(codecs) {
      this.enabledPublishVideoCodecs = codecs.filter(function(c) {
        return c.mime.split("/")[0].toLowerCase() === "video";
      });
    }
    /** @internal */
  }, {
    key: "updateInfo",
    value: function updateInfo(info) {
      var _this16 = this;
      if (info.sid !== this.sid) {
        return false;
      }
      if (!_superPropGet(LocalParticipant2, "updateInfo", this, 3)([info])) {
        return false;
      }
      info.tracks.forEach(function(ti) {
        var _a;
        var pub = _this16.trackPublications.get(ti.sid);
        if (pub) {
          console.log("Track type is: " + pub.kind + " & Sid is: " + ti.sid + " & Mute value is: " + ti.muted);
          var regex_ss = /^TR_VS.*/;
          var regex_ss_audio = /^TR_As.*/;
          if (regex_ss.test(ti.sid) || regex_ss_audio.test(ti.sid)) {
            return;
          }
          var localTrack = pub.track;
          if (pub.kind == Track.Kind.Audio) {
            if (sessionStorage.getItem("isAudioMuted") && sessionStorage.getItem("isAudioMuted") === "true") {
              _this16.log.debug("updating server audio mute state after reloading", Object.assign(Object.assign({}, _this16.logContext), {
                sid: ti.sid,
                muted: true
              }));
              _this16.engine.client.sendMuteTrack(ti.sid, true);
              _this16.audioMuted = true;
            }
            if (ti.muted) {
              if (localTrack instanceof LocalAudioTrack) {
                localTrack.mute().then(function() {
                  _this16.emit(ParticipantEvent.TrackMuted, pub);
                });
              }
            } else {
              if (_this16.audioMuted) {
                if (localTrack instanceof LocalAudioTrack) {
                  localTrack.unmute().then(function() {
                    _this16.emit(ParticipantEvent.TrackUnmuted, pub);
                  });
                }
              }
              _this16.audioMuted = false;
            }
          } else {
            if (!((_a = pub.track) === null || _a === void 0 ? void 0 : _a.isUpstreamPaused)) {
              if (sessionStorage.getItem("isVideoMuted") && sessionStorage.getItem("isVideoMuted") === "true") {
                _this16.log.debug("updating server video mute state after reloading", Object.assign(Object.assign({}, _this16.logContext), {
                  sid: ti.sid,
                  muted: true
                }));
                _this16.engine.client.sendMuteTrack(ti.sid, true);
                _this16.videoMuted = true;
              }
              if (ti.muted) {
                if (localTrack instanceof LocalVideoTrack) {
                  localTrack.mute().then(function() {
                    _this16.emit(ParticipantEvent.TrackMuted, pub);
                  });
                }
              } else {
                if (_this16.videoMuted) {
                  if (localTrack instanceof LocalVideoTrack) {
                    localTrack.unmute().then(function() {
                      _this16.emit(ParticipantEvent.TrackUnmuted, pub);
                    });
                  }
                }
                _this16.videoMuted = false;
              }
            }
          }
        }
      });
      return true;
    }
  }, {
    key: "getPublicationForTrack",
    value: function getPublicationForTrack(track) {
      var publication;
      this.trackPublications.forEach(function(pub) {
        var localTrack = pub.track;
        if (!localTrack) {
          return;
        }
        if (track instanceof MediaStreamTrack) {
          if (localTrack instanceof LocalAudioTrack || localTrack instanceof LocalVideoTrack) {
            if (localTrack.mediaStreamTrack === track) {
              publication = pub;
            }
          }
        } else if (track === localTrack) {
          publication = pub;
        }
      });
      return publication;
    }
  }, {
    key: "waitForPendingPublicationOfSource",
    value: function waitForPendingPublicationOfSource(source) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee33() {
        var waitForPendingTimeout, startTime, publishPromiseEntry;
        return _regenerator().w(function(_context33) {
          while (1) switch (_context33.n) {
            case 0:
              waitForPendingTimeout = 1e4;
              startTime = Date.now();
            case 1:
              if (!(Date.now() < startTime + waitForPendingTimeout)) {
                _context33.n = 4;
                break;
              }
              publishPromiseEntry = Array.from(this.pendingPublishPromises.entries()).find(function(_ref4) {
                var _ref5 = _slicedToArray(_ref4, 1), pendingTrack = _ref5[0];
                return pendingTrack.source === source;
              });
              if (!publishPromiseEntry) {
                _context33.n = 2;
                break;
              }
              return _context33.a(2, publishPromiseEntry[1]);
            case 2:
              _context33.n = 3;
              return sleep(20);
            case 3:
              _context33.n = 1;
              break;
            case 4:
              return _context33.a(2);
          }
        }, _callee33, this);
      }));
    }
  }]);
}(Participant);
var RemoteTrackPublication = function(_TrackPublication) {
  function RemoteTrackPublication2(kind, ti, autoSubscribe, loggerOptions) {
    var _this;
    _classCallCheck(this, RemoteTrackPublication2);
    _this = _callSuper(this, RemoteTrackPublication2, [kind, ti.sid, ti.name, loggerOptions]);
    _this.track = void 0;
    _this.allowed = true;
    _this.disabled = false;
    _this.currentVideoQuality = VideoQuality.HIGH;
    _this.handleEnded = function(track) {
      _this.setTrack(void 0);
      _this.emit(TrackEvent.Ended, track);
    };
    _this.handleVisibilityChange = function(visible) {
      _this.log.debug("adaptivestream video visibility ".concat(_this.trackSid, ", visible=").concat(visible), _this.logContext);
      _this.disabled = !visible;
      _this.emitTrackUpdate();
    };
    _this.handleVideoDimensionsChange = function(dimensions) {
      _this.log.debug("adaptivestream video dimensions ".concat(dimensions.width, "x").concat(dimensions.height), _this.logContext);
      _this.videoDimensions = dimensions;
      _this.emitTrackUpdate();
    };
    _this.subscribed = autoSubscribe;
    _this.updateInfo(ti);
    return _this;
  }
  _inherits(RemoteTrackPublication2, _TrackPublication);
  return _createClass(RemoteTrackPublication2, [{
    key: "setSubscribed",
    value: function setSubscribed(subscribed) {
      var prevStatus = this.subscriptionStatus;
      var prevPermission = this.permissionStatus;
      this.subscribed = subscribed;
      if (subscribed) {
        this.allowed = true;
      }
      var sub = new UpdateSubscription({
        trackSids: [this.trackSid],
        subscribe: this.subscribed,
        participantTracks: [new ParticipantTracks({
          // sending an empty participant id since TrackPublication doesn't keep it
          // this is filled in by the participant that receives this message
          participantSid: "",
          trackSids: [this.trackSid]
        })]
      });
      this.emit(TrackEvent.UpdateSubscription, sub);
      this.emitSubscriptionUpdateIfChanged(prevStatus);
      this.emitPermissionUpdateIfChanged(prevPermission);
    }
  }, {
    key: "subscriptionStatus",
    get: function get2() {
      if (this.subscribed === false) {
        return TrackPublication.SubscriptionStatus.Unsubscribed;
      }
      if (!_superPropGet(RemoteTrackPublication2, "isSubscribed", this, 1)) {
        return TrackPublication.SubscriptionStatus.Desired;
      }
      return TrackPublication.SubscriptionStatus.Subscribed;
    }
  }, {
    key: "permissionStatus",
    get: function get2() {
      return this.allowed ? TrackPublication.PermissionStatus.Allowed : TrackPublication.PermissionStatus.NotAllowed;
    }
    /**
     * Returns true if track is subscribed, and ready for playback
     */
  }, {
    key: "isSubscribed",
    get: function get2() {
      if (this.subscribed === false) {
        return false;
      }
      return _superPropGet(RemoteTrackPublication2, "isSubscribed", this, 1);
    }
    // returns client's desire to subscribe to a track, also true if autoSubscribe is enabled
  }, {
    key: "isDesired",
    get: function get2() {
      return this.subscribed !== false;
    }
  }, {
    key: "isEnabled",
    get: function get2() {
      return !this.disabled;
    }
    /**
     * disable server from sending down data for this track. this is useful when
     * the participant is off screen, you may disable streaming down their video
     * to reduce bandwidth requirements
     * @param enabled
     */
  }, {
    key: "setEnabled",
    value: function setEnabled(enabled) {
      if (!this.isManualOperationAllowed() || this.disabled === !enabled) {
        return;
      }
      this.disabled = !enabled;
      this.emitTrackUpdate();
    }
    /**
     * for tracks that support simulcasting, adjust subscribed quality
     *
     * This indicates the highest quality the client can accept. if network
     * bandwidth does not allow, server will automatically reduce quality to
     * optimize for uninterrupted video
     */
  }, {
    key: "setVideoQuality",
    value: function setVideoQuality(quality) {
      if (!this.isManualOperationAllowed() || this.currentVideoQuality === quality) {
        return;
      }
      this.currentVideoQuality = quality;
      this.videoDimensions = void 0;
      this.emitTrackUpdate();
    }
  }, {
    key: "setVideoDimensions",
    value: function setVideoDimensions(dimensions) {
      var _a, _b;
      if (!this.isManualOperationAllowed()) {
        return;
      }
      if (((_a = this.videoDimensions) === null || _a === void 0 ? void 0 : _a.width) === dimensions.width && ((_b = this.videoDimensions) === null || _b === void 0 ? void 0 : _b.height) === dimensions.height) {
        return;
      }
      if (this.track instanceof RemoteVideoTrack) {
        this.videoDimensions = dimensions;
      }
      this.currentVideoQuality = void 0;
      this.emitTrackUpdate();
    }
  }, {
    key: "setVideoFPS",
    value: function setVideoFPS(fps) {
      if (!this.isManualOperationAllowed()) {
        return;
      }
      if (!(this.track instanceof RemoteVideoTrack)) {
        return;
      }
      if (this.fps === fps) {
        return;
      }
      this.fps = fps;
      this.emitTrackUpdate();
    }
  }, {
    key: "videoQuality",
    get: function get2() {
      return this.currentVideoQuality;
    }
    /** @internal */
  }, {
    key: "setTrack",
    value: function setTrack(track) {
      var prevStatus = this.subscriptionStatus;
      var prevPermission = this.permissionStatus;
      var prevTrack = this.track;
      if (prevTrack === track) {
        return;
      }
      if (prevTrack) {
        prevTrack.off(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);
        prevTrack.off(TrackEvent.VisibilityChanged, this.handleVisibilityChange);
        prevTrack.off(TrackEvent.Ended, this.handleEnded);
        prevTrack.detach();
        prevTrack.stopMonitor();
        this.emit(TrackEvent.Unsubscribed, prevTrack);
      }
      _superPropGet(RemoteTrackPublication2, "setTrack", this, 3)([track]);
      if (track) {
        track.sid = this.trackSid;
        track.on(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);
        track.on(TrackEvent.VisibilityChanged, this.handleVisibilityChange);
        track.on(TrackEvent.Ended, this.handleEnded);
        this.emit(TrackEvent.Subscribed, track);
      }
      this.emitPermissionUpdateIfChanged(prevPermission);
      this.emitSubscriptionUpdateIfChanged(prevStatus);
    }
    /** @internal */
  }, {
    key: "setAllowed",
    value: function setAllowed(allowed) {
      var prevStatus = this.subscriptionStatus;
      var prevPermission = this.permissionStatus;
      this.allowed = allowed;
      this.emitPermissionUpdateIfChanged(prevPermission);
      this.emitSubscriptionUpdateIfChanged(prevStatus);
    }
    /** @internal */
  }, {
    key: "setSubscriptionError",
    value: function setSubscriptionError(error) {
      this.emit(TrackEvent.SubscriptionFailed, error);
    }
    /** @internal */
  }, {
    key: "updateInfo",
    value: function updateInfo(info) {
      _superPropGet(RemoteTrackPublication2, "updateInfo", this, 3)([info]);
      var prevMetadataMuted = this.metadataMuted;
      this.metadataMuted = info.muted;
      if (this.track) {
        this.track.setMuted(info.muted);
      } else if (prevMetadataMuted !== info.muted) {
        this.emit(info.muted ? TrackEvent.Muted : TrackEvent.Unmuted);
      }
    }
  }, {
    key: "emitSubscriptionUpdateIfChanged",
    value: function emitSubscriptionUpdateIfChanged(previousStatus) {
      var currentStatus = this.subscriptionStatus;
      if (previousStatus === currentStatus) {
        return;
      }
      this.emit(TrackEvent.SubscriptionStatusChanged, currentStatus, previousStatus);
    }
  }, {
    key: "emitPermissionUpdateIfChanged",
    value: function emitPermissionUpdateIfChanged(previousPermissionStatus) {
      var currentPermissionStatus = this.permissionStatus;
      if (currentPermissionStatus !== previousPermissionStatus) {
        this.emit(TrackEvent.SubscriptionPermissionChanged, this.permissionStatus, previousPermissionStatus);
      }
    }
  }, {
    key: "isManualOperationAllowed",
    value: function isManualOperationAllowed() {
      if (this.kind === Track.Kind.Video && this.isAdaptiveStream) {
        this.log.warn("adaptive stream is enabled, cannot change video track settings", this.logContext);
        return false;
      }
      if (!this.isDesired) {
        this.log.warn("cannot update track settings when not subscribed", this.logContext);
        return false;
      }
      return true;
    }
  }, {
    key: "isAdaptiveStream",
    get: function get2() {
      return this.track instanceof RemoteVideoTrack && this.track.isAdaptiveStream;
    }
    /* @internal */
  }, {
    key: "emitTrackUpdate",
    value: function emitTrackUpdate() {
      var settings = new UpdateTrackSettings({
        trackSids: [this.trackSid],
        disabled: this.disabled,
        fps: this.fps
      });
      if (this.videoDimensions) {
        settings.width = Math.ceil(this.videoDimensions.width);
        settings.height = Math.ceil(this.videoDimensions.height);
      } else if (this.currentVideoQuality !== void 0) {
        settings.quality = this.currentVideoQuality;
      } else {
        settings.quality = VideoQuality.HIGH;
      }
      this.emit(TrackEvent.UpdateSettings, settings);
    }
  }]);
}(TrackPublication);
var RemoteParticipant = function(_Participant) {
  function RemoteParticipant2(signalClient, sid, identity, name, metadata, attributes, loggerOptions) {
    var _this;
    var kind = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : ParticipantInfo_Kind.STANDARD;
    _classCallCheck(this, RemoteParticipant2);
    _this = _callSuper(this, RemoteParticipant2, [sid, identity || "", name, metadata, attributes, loggerOptions, kind]);
    _this.signalClient = signalClient;
    _this.trackPublications = /* @__PURE__ */ new Map();
    _this.audioTrackPublications = /* @__PURE__ */ new Map();
    _this.videoTrackPublications = /* @__PURE__ */ new Map();
    _this.volumeMap = /* @__PURE__ */ new Map();
    return _this;
  }
  _inherits(RemoteParticipant2, _Participant);
  return _createClass(RemoteParticipant2, [{
    key: "logContext",
    get: function get2() {
      return Object.assign(Object.assign({}, _superPropGet(RemoteParticipant2, "logContext", this, 1)), {
        rpID: this.sid,
        remoteParticipant: this.identity
      });
    }
  }, {
    key: "addTrackPublication",
    value: function addTrackPublication(publication) {
      var _this2 = this;
      _superPropGet(RemoteParticipant2, "addTrackPublication", this, 3)([publication]);
      publication.on(TrackEvent.UpdateSettings, function(settings) {
        _this2.log.debug("send update settings", Object.assign(Object.assign({}, _this2.logContext), getLogContextFromTrack(publication)));
        _this2.signalClient.sendUpdateTrackSettings(settings);
      });
      publication.on(TrackEvent.UpdateSubscription, function(sub) {
        sub.participantTracks.forEach(function(pt) {
          pt.participantSid = _this2.sid;
        });
        _this2.signalClient.sendUpdateSubscription(sub);
      });
      publication.on(TrackEvent.SubscriptionPermissionChanged, function(status) {
        _this2.emit(ParticipantEvent.TrackSubscriptionPermissionChanged, publication, status);
      });
      publication.on(TrackEvent.SubscriptionStatusChanged, function(status) {
        _this2.emit(ParticipantEvent.TrackSubscriptionStatusChanged, publication, status);
      });
      publication.on(TrackEvent.Subscribed, function(track) {
        _this2.emit(ParticipantEvent.TrackSubscribed, track, publication);
      });
      publication.on(TrackEvent.Unsubscribed, function(previousTrack) {
        _this2.emit(ParticipantEvent.TrackUnsubscribed, previousTrack, publication);
      });
      publication.on(TrackEvent.SubscriptionFailed, function(error) {
        _this2.emit(ParticipantEvent.TrackSubscriptionFailed, publication.trackSid, error);
      });
    }
  }, {
    key: "getTrackPublication",
    value: function getTrackPublication(source) {
      var track = _superPropGet(RemoteParticipant2, "getTrackPublication", this, 3)([source]);
      if (track) {
        return track;
      }
    }
  }, {
    key: "getTrackPublicationByName",
    value: function getTrackPublicationByName(name) {
      var track = _superPropGet(RemoteParticipant2, "getTrackPublicationByName", this, 3)([name]);
      if (track) {
        return track;
      }
    }
    /**
     * sets the volume on the participant's audio track
     * by default, this affects the microphone publication
     * a different source can be passed in as a second argument
     * if no track exists the volume will be applied when the microphone track is added
     */
  }, {
    key: "setVolume",
    value: function setVolume(volume) {
      var source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Track.Source.Microphone;
      this.volumeMap.set(source, volume);
      var audioPublication = this.getTrackPublication(source);
      if (audioPublication && audioPublication.track) {
        audioPublication.track.setVolume(volume);
      }
    }
    /**
     * gets the volume on the participant's microphone track
     */
  }, {
    key: "getVolume",
    value: function getVolume() {
      var source = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Track.Source.Microphone;
      var audioPublication = this.getTrackPublication(source);
      if (audioPublication && audioPublication.track) {
        return audioPublication.track.getVolume();
      }
      return this.volumeMap.get(source);
    }
    /** @internal */
  }, {
    key: "addSubscribedMediaTrack",
    value: function addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft) {
      var _this3 = this;
      var publication = this.getTrackPublicationBySid(sid);
      if (!publication) {
        if (!sid.startsWith("TR")) {
          this.trackPublications.forEach(function(p) {
            if (!publication && mediaTrack.kind === p.kind.toString()) {
              publication = p;
            }
          });
        }
      }
      if (!publication) {
        if (triesLeft === 0) {
          this.log.error("could not find published track", Object.assign(Object.assign({}, this.logContext), {
            trackSid: sid
          }));
          this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);
          return;
        }
        if (triesLeft === void 0) triesLeft = 20;
        setTimeout(function() {
          _this3.addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft - 1);
        }, 150);
        return;
      }
      if (mediaTrack.readyState === "ended") {
        this.log.error("unable to subscribe because MediaStreamTrack is ended. Do not call MediaStreamTrack.stop()", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));
        this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);
        return;
      }
      var isVideo = mediaTrack.kind === "video";
      var track;
      if (isVideo) {
        track = new RemoteVideoTrack(mediaTrack, sid, receiver, adaptiveStreamSettings);
      } else {
        track = new RemoteAudioTrack(mediaTrack, sid, receiver, this.audioContext, this.audioOutput);
      }
      track.source = publication.source;
      track.isMuted = publication.isMuted;
      track.setMediaStream(mediaStream);
      track.start();
      publication.setTrack(track);
      if (this.volumeMap.has(publication.source) && track instanceof RemoteAudioTrack) {
        track.setVolume(this.volumeMap.get(publication.source));
      }
      return publication;
    }
    /** @internal */
  }, {
    key: "hasMetadata",
    get: function get2() {
      return !!this.participantInfo;
    }
    /**
     * @internal
     */
  }, {
    key: "getTrackPublicationBySid",
    value: function getTrackPublicationBySid(sid) {
      return this.trackPublications.get(sid);
    }
    /** @internal */
  }, {
    key: "updateInfo",
    value: function updateInfo(info) {
      var _this4 = this;
      if (!_superPropGet(RemoteParticipant2, "updateInfo", this, 3)([info])) {
        return false;
      }
      var validTracks = /* @__PURE__ */ new Map();
      var newTracks = /* @__PURE__ */ new Map();
      info.tracks.forEach(function(ti) {
        var _a, _b;
        var publication = _this4.getTrackPublicationBySid(ti.sid);
        if (!publication) {
          var kind = Track.kindFromProto(ti.type);
          if (!kind) {
            return;
          }
          publication = new RemoteTrackPublication(kind, ti, (_a = _this4.signalClient.connectOptions) === null || _a === void 0 ? void 0 : _a.autoSubscribe, {
            loggerContextCb: function loggerContextCb() {
              return _this4.logContext;
            },
            loggerName: (_b = _this4.loggerOptions) === null || _b === void 0 ? void 0 : _b.loggerName
          });
          publication.updateInfo(ti);
          newTracks.set(ti.sid, publication);
          var existingTrackOfSource = Array.from(_this4.trackPublications.values()).find(function(publishedTrack) {
            return publishedTrack.source === (publication === null || publication === void 0 ? void 0 : publication.source);
          });
          if (existingTrackOfSource && publication.source !== Track.Source.Unknown) {
            _this4.log.debug("received a second track publication for ".concat(_this4.identity, " with the same source: ").concat(publication.source), Object.assign(Object.assign({}, _this4.logContext), {
              oldTrack: getLogContextFromTrack(existingTrackOfSource),
              newTrack: getLogContextFromTrack(publication)
            }));
          }
          _this4.addTrackPublication(publication);
        } else {
          publication.updateInfo(ti);
        }
        validTracks.set(ti.sid, publication);
      });
      this.trackPublications.forEach(function(publication) {
        if (!validTracks.has(publication.trackSid)) {
          _this4.log.trace("detected removed track on remote participant, unpublishing", Object.assign(Object.assign({}, _this4.logContext), getLogContextFromTrack(publication)));
          _this4.unpublishTrack(publication.trackSid, true);
        }
      });
      newTracks.forEach(function(publication) {
        _this4.emit(ParticipantEvent.TrackPublished, publication);
      });
      return true;
    }
    /** @internal */
  }, {
    key: "unpublishTrack",
    value: function unpublishTrack(sid, sendUnpublish) {
      var publication = this.trackPublications.get(sid);
      if (!publication) {
        return;
      }
      var track = publication.track;
      if (track) {
        track.stop();
        publication.setTrack(void 0);
      }
      this.trackPublications["delete"](sid);
      switch (publication.kind) {
        case Track.Kind.Audio:
          this.audioTrackPublications["delete"](sid);
          break;
        case Track.Kind.Video:
          this.videoTrackPublications["delete"](sid);
          break;
      }
      if (sendUnpublish) {
        this.emit(ParticipantEvent.TrackUnpublished, publication);
      }
    }
    /**
     * @internal
     */
  }, {
    key: "setAudioOutput",
    value: function setAudioOutput(output) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee() {
        var promises;
        return _regenerator().w(function(_context) {
          while (1) switch (_context.n) {
            case 0:
              this.audioOutput = output;
              promises = [];
              this.audioTrackPublications.forEach(function(pub) {
                var _a;
                if (pub.track instanceof RemoteAudioTrack) {
                  promises.push(pub.track.setSinkId((_a = output.deviceId) !== null && _a !== void 0 ? _a : "default"));
                }
              });
              _context.n = 1;
              return Promise.all(promises);
            case 1:
              return _context.a(2);
          }
        }, _callee, this);
      }));
    }
    /** @internal */
  }, {
    key: "emit",
    value: function emit2(event) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      this.log.trace("participant event", Object.assign(Object.assign({}, this.logContext), {
        event,
        args
      }));
      return _superPropGet(RemoteParticipant2, "emit", this, 3)([event].concat(args));
    }
  }], [{
    key: "fromParticipantInfo",
    value: (
      /** @internal */
      function fromParticipantInfo(signalClient, pi, loggerOptions) {
        return new RemoteParticipant2(signalClient, pi.sid, pi.identity, pi.name, pi.metadata, pi.attributes, loggerOptions, pi.kind);
      }
    )
  }]);
}(Participant);
var ConnectionState;
(function(ConnectionState2) {
  ConnectionState2["Disconnected"] = "disconnected";
  ConnectionState2["Connecting"] = "connecting";
  ConnectionState2["Connected"] = "connected";
  ConnectionState2["Reconnecting"] = "reconnecting";
  ConnectionState2["SignalReconnecting"] = "signalReconnecting";
})(ConnectionState || (ConnectionState = {}));
var connectionReconcileFrequency = 4 * 1e3;
var Room = function(_EventEmitter) {
  function Room2(options) {
    var _this;
    _classCallCheck(this, Room2);
    var _a, _b, _c;
    _this = _callSuper(this, Room2);
    _this.state = ConnectionState.Disconnected;
    _this.activeSpeakers = [];
    _this.isE2EEEnabled = false;
    _this.audioEnabled = true;
    _this.isVideoPlaybackBlocked = false;
    _this.log = livekitLogger;
    _this.bufferedEvents = [];
    _this.isResuming = false;
    _this.connect = function(url, token, opts) {
      return __awaiter(_this, void 0, void 0, _regenerator().m(function _callee2() {
        var _this2 = this;
        var _a2, refreshedToken, unlockDisconnect, _connectFn, regionUrl;
        return _regenerator().w(function(_context2) {
          while (1) switch (_context2.n) {
            case 0:
              if (isBrowserSupported()) {
                _context2.n = 2;
                break;
              }
              if (!isReactNative()) {
                _context2.n = 1;
                break;
              }
              throw Error("WebRTC isn't detected, have you called registerGlobals?");
            case 1:
              throw Error("LiveKit doesn't seem to be supported on this browser. Try to update your browser and make sure no browser extensions are disabling webRTC.");
            case 2:
              refreshedToken = sessionStorage.getItem("token");
              if ((!token || token.trim().length === 0) && refreshedToken != null) {
                livekitLogger.info("Reload Performed, using latest token to refresh: " + refreshedToken);
                token = refreshedToken;
              }
              _context2.n = 3;
              return this.disconnectLock.lock();
            case 3:
              unlockDisconnect = _context2.v;
              if (!(this.state === ConnectionState.Connected)) {
                _context2.n = 4;
                break;
              }
              this.log.info("already connected to room ".concat(this.name), this.logContext);
              unlockDisconnect();
              return _context2.a(2, Promise.resolve());
            case 4:
              if (!this.connectFuture) {
                _context2.n = 5;
                break;
              }
              unlockDisconnect();
              return _context2.a(2, this.connectFuture.promise);
            case 5:
              this.setAndEmitConnectionState(ConnectionState.Connecting);
              if (((_a2 = this.regionUrlProvider) === null || _a2 === void 0 ? void 0 : _a2.getServerUrl().toString()) !== url) {
                this.regionUrl = void 0;
                this.regionUrlProvider = void 0;
              }
              if (isCloud(new URL(url))) {
                if (this.regionUrlProvider === void 0) {
                  this.regionUrlProvider = new RegionUrlProvider(url, token);
                } else {
                  this.regionUrlProvider.updateToken(token);
                }
                this.regionUrlProvider.fetchRegionSettings().then(function(settings) {
                  var _a3;
                  (_a3 = _this2.regionUrlProvider) === null || _a3 === void 0 ? void 0 : _a3.setServerReportedRegions(settings);
                })["catch"](function(e) {
                  _this2.log.warn("could not fetch region settings", Object.assign(Object.assign({}, _this2.logContext), {
                    error: e
                  }));
                });
              }
              _connectFn = function connectFn(resolve, reject, regionUrl2) {
                return __awaiter(_this2, void 0, void 0, _regenerator().m(function _callee() {
                  var _a3, _b2, abortController2, nextUrl, disconnectReason, _t, _t2;
                  return _regenerator().w(function(_context) {
                    while (1) switch (_context.n) {
                      case 0:
                        if (this.abortController) {
                          this.abortController.abort();
                        }
                        abortController2 = new AbortController();
                        this.abortController = abortController2;
                        unlockDisconnect === null || unlockDisconnect === void 0 ? void 0 : unlockDisconnect();
                        _context.p = 1;
                        _context.n = 2;
                        return this.attemptConnection(regionUrl2 !== null && regionUrl2 !== void 0 ? regionUrl2 : url, token, opts, abortController2);
                      case 2:
                        this.abortController = void 0;
                        resolve();
                        _context.n = 12;
                        break;
                      case 3:
                        _context.p = 3;
                        _t = _context.v;
                        if (!(this.regionUrlProvider && _t instanceof ConnectionError && _t.reason !== 3 && _t.reason !== 0)) {
                          _context.n = 11;
                          break;
                        }
                        nextUrl = null;
                        _context.p = 4;
                        _context.n = 5;
                        return this.regionUrlProvider.getNextBestRegionUrl((_a3 = this.abortController) === null || _a3 === void 0 ? void 0 : _a3.signal);
                      case 5:
                        nextUrl = _context.v;
                        _context.n = 7;
                        break;
                      case 6:
                        _context.p = 6;
                        _t2 = _context.v;
                        if (!(_t2 instanceof ConnectionError && (_t2.status === 401 || _t2.reason === 3))) {
                          _context.n = 7;
                          break;
                        }
                        this.handleDisconnect(this.options.stopLocalTrackOnUnpublish);
                        reject(_t2);
                        return _context.a(2);
                      case 7:
                        if (!(nextUrl && !((_b2 = this.abortController) === null || _b2 === void 0 ? void 0 : _b2.signal.aborted))) {
                          _context.n = 9;
                          break;
                        }
                        this.log.info("Initial connection failed with ConnectionError: ".concat(_t.message, ". Retrying with another region: ").concat(nextUrl), this.logContext);
                        this.recreateEngine();
                        _context.n = 8;
                        return _connectFn(resolve, reject, nextUrl);
                      case 8:
                        _context.n = 10;
                        break;
                      case 9:
                        this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, getDisconnectReasonFromConnectionError(_t));
                        reject(_t);
                      case 10:
                        _context.n = 12;
                        break;
                      case 11:
                        disconnectReason = DisconnectReason.UNKNOWN_REASON;
                        if (_t instanceof ConnectionError) {
                          disconnectReason = getDisconnectReasonFromConnectionError(_t);
                        }
                        this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, disconnectReason);
                        reject(_t);
                      case 12:
                        return _context.a(2);
                    }
                  }, _callee, this, [[4, 6], [1, 3]]);
                }));
              };
              regionUrl = this.regionUrl;
              this.regionUrl = void 0;
              this.connectFuture = new Future(function(resolve, reject) {
                _connectFn(resolve, reject, regionUrl);
              }, function() {
                _this2.clearConnectionFutures();
              });
              return _context2.a(2, this.connectFuture.promise);
          }
        }, _callee2, this);
      }));
    };
    _this.connectSignal = function(url, token, engine, connectOptions, roomOptions, abortController2) {
      return __awaiter(_this, void 0, void 0, _regenerator().m(function _callee3() {
        var _a2, _b2, _c2, joinResponse, serverInfo;
        return _regenerator().w(function(_context3) {
          while (1) switch (_context3.n) {
            case 0:
              _context3.n = 1;
              return engine.join(url, token, {
                autoSubscribe: connectOptions.autoSubscribe,
                adaptiveStream: _typeof(roomOptions.adaptiveStream) === "object" ? true : roomOptions.adaptiveStream,
                maxRetries: connectOptions.maxRetries,
                e2eeEnabled: !!this.e2eeManager,
                websocketTimeout: connectOptions.websocketTimeout
              }, abortController2.signal);
            case 1:
              joinResponse = _context3.v;
              serverInfo = joinResponse.serverInfo;
              if (!serverInfo) {
                serverInfo = {
                  version: joinResponse.serverVersion,
                  region: joinResponse.serverRegion
                };
              }
              this.serverInfo = serverInfo;
              this.log.debug("connected to Livekit Server ".concat(Object.entries(serverInfo).map(function(_ref) {
                var _ref2 = _slicedToArray(_ref, 2), key = _ref2[0], value = _ref2[1];
                return "".concat(key, ": ").concat(value);
              }).join(", ")), {
                room: (_a2 = joinResponse.room) === null || _a2 === void 0 ? void 0 : _a2.name,
                roomSid: (_b2 = joinResponse.room) === null || _b2 === void 0 ? void 0 : _b2.sid,
                identity: (_c2 = joinResponse.participant) === null || _c2 === void 0 ? void 0 : _c2.identity
              });
              if (serverInfo.version) {
                _context3.n = 2;
                break;
              }
              throw new UnsupportedServer("unknown server version");
            case 2:
              if (serverInfo.version === "0.15.1" && this.options.dynacast) {
                this.log.debug("disabling dynacast due to server version", this.logContext);
                roomOptions.dynacast = false;
              }
              return _context3.a(2, joinResponse);
          }
        }, _callee3, this);
      }));
    };
    _this.applyJoinResponse = function(joinResponse) {
      var pi = joinResponse.participant;
      _this.localParticipant.sid = pi.sid;
      _this.localParticipant.identity = pi.identity;
      _this.localParticipant.setEnabledPublishCodecs(joinResponse.enabledPublishCodecs);
      if (_this.options.e2ee && _this.e2eeManager) {
        try {
          _this.e2eeManager.setSifTrailer(joinResponse.sifTrailer);
        } catch (e) {
          _this.log.error(e instanceof Error ? e.message : "Could not set SifTrailer", Object.assign(Object.assign({}, _this.logContext), {
            error: e
          }));
        }
      }
      _this.handleParticipantUpdates([pi].concat(_toConsumableArray(joinResponse.otherParticipants)));
      if (joinResponse.room) {
        _this.handleRoomUpdate(joinResponse.room);
      }
    };
    _this.attemptConnection = function(url, token, opts, abortController2) {
      return __awaiter(_this, void 0, void 0, _regenerator().m(function _callee4() {
        var _a2, _b2, joinResponse, resultingError, _t3, _t4;
        return _regenerator().w(function(_context4) {
          while (1) switch (_context4.n) {
            case 0:
              if (this.state === ConnectionState.Reconnecting || this.isResuming || ((_a2 = this.engine) === null || _a2 === void 0 ? void 0 : _a2.pendingReconnect)) {
                this.log.info("Reconnection attempt replaced by new connection attempt", this.logContext);
                this.recreateEngine();
              } else {
                this.maybeCreateEngine();
              }
              if ((_b2 = this.regionUrlProvider) === null || _b2 === void 0 ? void 0 : _b2.isCloud()) {
                this.engine.setRegionUrlProvider(this.regionUrlProvider);
              }
              this.acquireAudioContext();
              this.connOptions = Object.assign(Object.assign({}, roomConnectOptionDefaults), opts);
              if (this.connOptions.rtcConfig) {
                this.engine.rtcConfig = this.connOptions.rtcConfig;
              }
              if (this.connOptions.peerConnectionTimeout) {
                this.engine.peerConnectionTimeout = this.connOptions.peerConnectionTimeout;
              }
              _context4.p = 1;
              _context4.n = 2;
              return this.connectSignal(url, token, this.engine, this.connOptions, this.options, abortController2);
            case 2:
              joinResponse = _context4.v;
              this.applyJoinResponse(joinResponse);
              this.setupLocalParticipantEvents();
              this.emit(RoomEvent.SignalConnected);
              _context4.n = 5;
              break;
            case 3:
              _context4.p = 3;
              _t3 = _context4.v;
              _context4.n = 4;
              return this.engine.close();
            case 4:
              this.recreateEngine();
              resultingError = new ConnectionError(
                "could not establish signal connection",
                1
                /* ConnectionErrorReason.ServerUnreachable */
              );
              if (_t3 instanceof Error) {
                resultingError.message = "".concat(resultingError.message, ": ").concat(_t3.message);
              }
              if (_t3 instanceof ConnectionError) {
                resultingError.reason = _t3.reason;
                resultingError.status = _t3.status;
              }
              this.log.debug("error trying to establish signal connection", Object.assign(Object.assign({}, this.logContext), {
                error: _t3
              }));
              throw resultingError;
            case 5:
              if (!abortController2.signal.aborted) {
                _context4.n = 7;
                break;
              }
              _context4.n = 6;
              return this.engine.close();
            case 6:
              this.recreateEngine();
              throw new ConnectionError(
                "Connection attempt aborted",
                3
                /* ConnectionErrorReason.Cancelled */
              );
            case 7:
              _context4.p = 7;
              _context4.n = 8;
              return this.engine.waitForPCInitialConnection(this.connOptions.peerConnectionTimeout, abortController2);
            case 8:
              _context4.n = 11;
              break;
            case 9:
              _context4.p = 9;
              _t4 = _context4.v;
              _context4.n = 10;
              return this.engine.close();
            case 10:
              this.recreateEngine();
              throw _t4;
            case 11:
              if (isWeb() && this.options.disconnectOnPageLeave) {
                window.addEventListener("pagehide", this.onPageLeave);
                window.addEventListener("beforeunload", this.onPageLeave);
              }
              if (isWeb()) {
                document.addEventListener("freeze", this.onPageLeave);
              }
              this.setAndEmitConnectionState(ConnectionState.Connected);
              this.emit(RoomEvent.Connected);
              this.registerConnectionReconcile();
            case 12:
              return _context4.a(2);
          }
        }, _callee4, this, [[7, 9], [1, 3]]);
      }));
    };
    _this.disconnect = function() {
      for (var _len = arguments.length, args_1 = new Array(_len), _key = 0; _key < _len; _key++) {
        args_1[_key] = arguments[_key];
      }
      return __awaiter(_this, [].concat(args_1), void 0, function() {
        var _this3 = this;
        var stopTracks = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        return _regenerator().m(function _callee5() {
          var _a2, _b2, _c2, _d, unlock;
          return _regenerator().w(function(_context5) {
            while (1) switch (_context5.n) {
              case 0:
                sessionStorage.removeItem("token");
                sessionStorage.removeItem("isAudioMuted");
                sessionStorage.removeItem("isVideoMuted");
                _context5.n = 1;
                return _this3.disconnectLock.lock();
              case 1:
                unlock = _context5.v;
                _context5.p = 2;
                if (!(_this3.state === ConnectionState.Disconnected)) {
                  _context5.n = 3;
                  break;
                }
                _this3.log.debug("already disconnected", _this3.logContext);
                return _context5.a(2);
              case 3:
                _this3.log.info("disconnect from room", Object.assign({}, _this3.logContext));
                if (_this3.state === ConnectionState.Connecting || _this3.state === ConnectionState.Reconnecting || _this3.isResuming) {
                  _this3.log.warn("abort connection attempt", _this3.logContext);
                  (_a2 = _this3.abortController) === null || _a2 === void 0 ? void 0 : _a2.abort();
                  (_c2 = (_b2 = _this3.connectFuture) === null || _b2 === void 0 ? void 0 : _b2.reject) === null || _c2 === void 0 ? void 0 : _c2.call(_b2, new ConnectionError(
                    "Client initiated disconnect",
                    3
                    /* ConnectionErrorReason.Cancelled */
                  ));
                  _this3.connectFuture = void 0;
                }
                if ((_d = _this3.engine) === null || _d === void 0 ? void 0 : _d.client.isDisconnected) {
                  _context5.n = 4;
                  break;
                }
                _context5.n = 4;
                return _this3.engine.client.sendLeave();
              case 4:
                if (!_this3.engine) {
                  _context5.n = 5;
                  break;
                }
                _context5.n = 5;
                return _this3.engine.close();
              case 5:
                _this3.handleDisconnect(stopTracks, DisconnectReason.CLIENT_INITIATED);
                _this3.engine = void 0;
              case 6:
                _context5.p = 6;
                unlock();
                return _context5.f(6);
              case 7:
                return _context5.a(2);
            }
          }, _callee5, null, [[2, , 6, 7]]);
        })();
      });
    };
    _this.onPageLeave = function() {
      return __awaiter(_this, void 0, void 0, _regenerator().m(function _callee6() {
        var token, isAudioMuted, isVideoMuted;
        return _regenerator().w(function(_context6) {
          while (1) switch (_context6.n) {
            case 0:
              alert("on page leave");
              this.log.info("Page leave detected, disconnecting", this.logContext);
              token = sessionStorage.getItem("token");
              isAudioMuted = sessionStorage.getItem("isAudioMuted");
              isVideoMuted = sessionStorage.getItem("isVideoMuted");
              this.disconnect();
              sessionStorage.setItem("token", token);
              sessionStorage.setItem("isAudioMuted", isAudioMuted);
              sessionStorage.setItem("isVideoMuted", isVideoMuted);
            case 1:
              return _context6.a(2);
          }
        }, _callee6, this);
      }));
    };
    _this.startAudio = function() {
      return __awaiter(_this, void 0, void 0, _regenerator().m(function _callee7() {
        var _this4 = this;
        var elements, browser, audioId, dummyAudioEl, track, stream, _t5;
        return _regenerator().w(function(_context7) {
          while (1) switch (_context7.n) {
            case 0:
              elements = [];
              browser = getBrowser();
              if (browser && browser.os === "iOS") {
                audioId = "livekit-dummy-audio-el";
                dummyAudioEl = document.getElementById(audioId);
                if (!dummyAudioEl) {
                  dummyAudioEl = document.createElement("audio");
                  dummyAudioEl.id = audioId;
                  dummyAudioEl.autoplay = true;
                  dummyAudioEl.hidden = true;
                  track = getEmptyAudioStreamTrack();
                  track.enabled = true;
                  stream = new MediaStream([track]);
                  dummyAudioEl.srcObject = stream;
                  document.addEventListener("visibilitychange", function() {
                    if (!dummyAudioEl) {
                      return;
                    }
                    dummyAudioEl.srcObject = document.hidden ? null : stream;
                    if (!document.hidden) {
                      _this4.log.debug("page visible again, triggering startAudio to resume playback and update playback status", _this4.logContext);
                      _this4.startAudio();
                    }
                  });
                  document.body.append(dummyAudioEl);
                  this.once(RoomEvent.Disconnected, function() {
                    dummyAudioEl === null || dummyAudioEl === void 0 ? void 0 : dummyAudioEl.remove();
                    dummyAudioEl = null;
                  });
                }
                elements.push(dummyAudioEl);
              }
              this.remoteParticipants.forEach(function(p) {
                p.audioTrackPublications.forEach(function(t) {
                  if (t.track) {
                    t.track.attachedElements.forEach(function(e) {
                      elements.push(e);
                    });
                  }
                });
              });
              _context7.p = 1;
              _context7.n = 2;
              return Promise.all([this.acquireAudioContext()].concat(_toConsumableArray(elements.map(function(e) {
                e.muted = false;
                return e.play();
              }))));
            case 2:
              this.handleAudioPlaybackStarted();
              _context7.n = 4;
              break;
            case 3:
              _context7.p = 3;
              _t5 = _context7.v;
              this.handleAudioPlaybackFailed(_t5);
              throw _t5;
            case 4:
              return _context7.a(2);
          }
        }, _callee7, this, [[1, 3]]);
      }));
    };
    _this.startVideo = function() {
      return __awaiter(_this, void 0, void 0, _regenerator().m(function _callee8() {
        var _this5 = this;
        var elements, _iterator, _step, p;
        return _regenerator().w(function(_context8) {
          while (1) switch (_context8.n) {
            case 0:
              elements = [];
              _iterator = _createForOfIteratorHelper(this.remoteParticipants.values());
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                  p = _step.value;
                  p.videoTrackPublications.forEach(function(tr) {
                    var _a2;
                    (_a2 = tr.track) === null || _a2 === void 0 ? void 0 : _a2.attachedElements.forEach(function(el) {
                      if (!elements.includes(el)) {
                        elements.push(el);
                      }
                    });
                  });
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
              _context8.n = 1;
              return Promise.all(elements.map(function(el) {
                return el.play();
              })).then(function() {
                _this5.handleVideoPlaybackStarted();
              })["catch"](function(e) {
                if (e.name === "NotAllowedError") {
                  _this5.handleVideoPlaybackFailed();
                } else {
                  _this5.log.warn("Resuming video playback failed, make sure you call `startVideo` directly in a user gesture handler", _this5.logContext);
                }
              });
            case 1:
              return _context8.a(2);
          }
        }, _callee8, this);
      }));
    };
    _this.handleRestarting = function() {
      _this.clearConnectionReconcile();
      _this.isResuming = false;
      var _iterator2 = _createForOfIteratorHelper(_this.remoteParticipants.values()), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var p = _step2.value;
          _this.handleParticipantDisconnected(p.identity, p);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      if (_this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {
        _this.emit(RoomEvent.Reconnecting);
      }
    };
    _this.handleSignalRestarted = function(joinResponse) {
      return __awaiter(_this, void 0, void 0, _regenerator().m(function _callee9() {
        var _t6;
        return _regenerator().w(function(_context9) {
          while (1) switch (_context9.n) {
            case 0:
              this.log.debug("signal reconnected to server, region ".concat(joinResponse.serverRegion), Object.assign(Object.assign({}, this.logContext), {
                region: joinResponse.serverRegion
              }));
              this.bufferedEvents = [];
              this.applyJoinResponse(joinResponse);
              _context9.p = 1;
              _context9.n = 2;
              return this.localParticipant.republishAllTracks(void 0, true);
            case 2:
              _context9.n = 4;
              break;
            case 3:
              _context9.p = 3;
              _t6 = _context9.v;
              this.log.error("error trying to re-publish tracks after reconnection", Object.assign(Object.assign({}, this.logContext), {
                error: _t6
              }));
            case 4:
              _context9.p = 4;
              _context9.n = 5;
              return this.engine.waitForRestarted();
            case 5:
              this.log.debug("fully reconnected to server", Object.assign(Object.assign({}, this.logContext), {
                region: joinResponse.serverRegion
              }));
              _context9.n = 7;
              break;
            case 6:
              _context9.p = 6;
              _context9.v;
              return _context9.a(2);
            case 7:
              this.setAndEmitConnectionState(ConnectionState.Connected);
              this.emit(RoomEvent.Reconnected);
              this.registerConnectionReconcile();
              this.emitBufferedEvents();
            case 8:
              return _context9.a(2);
          }
        }, _callee9, this, [[4, 6], [1, 3]]);
      }));
    };
    _this.handleParticipantUpdates = function(participantInfos) {
      participantInfos.forEach(function(info) {
        var _a2;
        if (info.identity === _this.localParticipant.identity) {
          _this.localParticipant.updateInfo(info);
          return;
        }
        if (info.identity === "") {
          info.identity = (_a2 = _this.sidToIdentity.get(info.sid)) !== null && _a2 !== void 0 ? _a2 : "";
        }
        var remoteParticipant = _this.remoteParticipants.get(info.identity);
        if (info.state === ParticipantInfo_State.DISCONNECTED) {
          _this.handleParticipantDisconnected(info.identity, remoteParticipant);
        } else {
          remoteParticipant = _this.getOrCreateParticipant(info.identity, info);
        }
      });
    };
    _this.handleActiveSpeakersUpdate = function(speakers) {
      var activeSpeakers = [];
      var seenSids = {};
      speakers.forEach(function(speaker) {
        seenSids[speaker.sid] = true;
        if (speaker.sid === _this.localParticipant.sid) {
          _this.localParticipant.audioLevel = speaker.level;
          _this.localParticipant.setIsSpeaking(true);
          activeSpeakers.push(_this.localParticipant);
        } else {
          var p = _this.getRemoteParticipantBySid(speaker.sid);
          if (p) {
            p.audioLevel = speaker.level;
            p.setIsSpeaking(true);
            activeSpeakers.push(p);
          }
        }
      });
      if (!seenSids[_this.localParticipant.sid]) {
        _this.localParticipant.audioLevel = 0;
        _this.localParticipant.setIsSpeaking(false);
      }
      _this.remoteParticipants.forEach(function(p) {
        if (!seenSids[p.sid]) {
          p.audioLevel = 0;
          p.setIsSpeaking(false);
        }
      });
      _this.activeSpeakers = activeSpeakers;
      _this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);
    };
    _this.handleSpeakersChanged = function(speakerUpdates) {
      var lastSpeakers = /* @__PURE__ */ new Map();
      _this.activeSpeakers.forEach(function(p) {
        var remoteParticipant = _this.remoteParticipants.get(p.identity);
        if (remoteParticipant && remoteParticipant.sid !== p.sid) {
          return;
        }
        lastSpeakers.set(p.sid, p);
      });
      speakerUpdates.forEach(function(speaker) {
        var p = _this.getRemoteParticipantBySid(speaker.sid);
        if (speaker.sid === _this.localParticipant.sid) {
          p = _this.localParticipant;
        }
        if (!p) {
          return;
        }
        p.audioLevel = speaker.level;
        p.setIsSpeaking(speaker.active);
        if (speaker.active) {
          lastSpeakers.set(speaker.sid, p);
        } else {
          lastSpeakers["delete"](speaker.sid);
        }
      });
      var activeSpeakers = Array.from(lastSpeakers.values());
      activeSpeakers.sort(function(a, b) {
        return b.audioLevel - a.audioLevel;
      });
      _this.activeSpeakers = activeSpeakers;
      _this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);
    };
    _this.handleStreamStateUpdate = function(streamStateUpdate) {
      streamStateUpdate.streamStates.forEach(function(streamState) {
        var participant = _this.getRemoteParticipantBySid(streamState.participantSid);
        if (!participant) {
          return;
        }
        var pub = participant.getTrackPublicationBySid(streamState.trackSid);
        if (!pub || !pub.track) {
          return;
        }
        var newStreamState = Track.streamStateFromProto(streamState.state);
        if (newStreamState !== pub.track.streamState) {
          pub.track.streamState = newStreamState;
          participant.emit(ParticipantEvent.TrackStreamStateChanged, pub, pub.track.streamState);
          _this.emitWhenConnected(RoomEvent.TrackStreamStateChanged, pub, pub.track.streamState, participant);
        }
      });
    };
    _this.handleSubscriptionPermissionUpdate = function(update) {
      var participant = _this.getRemoteParticipantBySid(update.participantSid);
      if (!participant) {
        return;
      }
      var pub = participant.getTrackPublicationBySid(update.trackSid);
      if (!pub) {
        return;
      }
      pub.setAllowed(update.allowed);
    };
    _this.handleSubscriptionError = function(update) {
      var participant = Array.from(_this.remoteParticipants.values()).find(function(p) {
        return p.trackPublications.has(update.trackSid);
      });
      if (!participant) {
        return;
      }
      var pub = participant.getTrackPublicationBySid(update.trackSid);
      if (!pub) {
        return;
      }
      pub.setSubscriptionError(update.err);
    };
    _this.handleDataPacket = function(packet) {
      var participant = _this.remoteParticipants.get(packet.participantIdentity);
      if (packet.value["case"] === "user") {
        _this.handleUserPacket(participant, packet.value.value, packet.kind);
      } else if (packet.value["case"] === "transcription") {
        _this.handleTranscription(participant, packet.value.value);
      } else if (packet.value["case"] === "sipDtmf") {
        _this.handleSipDtmf(participant, packet.value.value);
      } else if (packet.value["case"] === "metrics") {
        _this.handleMetrics(packet.value.value, participant);
      } else if (packet.value["case"] === "chatMessage") {
        _this.handleChatMessage(participant, packet.value.value);
      }
    };
    _this.handleUserPacket = function(participant, userPacket, kind) {
      _this.emit(RoomEvent.DataReceived, userPacket.payload, participant, kind, userPacket.topic);
      participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.DataReceived, userPacket.payload, kind, userPacket.destinationIdentities);
    };
    _this.handleSipDtmf = function(participant, dtmf) {
      _this.emit(RoomEvent.SipDTMFReceived, dtmf, participant);
      participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.SipDTMFReceived, dtmf);
    };
    _this.bufferedSegments = /* @__PURE__ */ new Map();
    _this.handleTranscription = function(_remoteParticipant, transcription) {
      var participant = transcription.transcribedParticipantIdentity === _this.localParticipant.identity ? _this.localParticipant : _this.getParticipantByIdentity(transcription.transcribedParticipantIdentity);
      var publication = participant === null || participant === void 0 ? void 0 : participant.trackPublications.get(transcription.trackId);
      var segments = extractTranscriptionSegments(transcription, _this.transcriptionReceivedTimes);
      publication === null || publication === void 0 ? void 0 : publication.emit(TrackEvent.TranscriptionReceived, segments);
      participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.TranscriptionReceived, segments, publication);
      _this.emit(RoomEvent.TranscriptionReceived, segments, participant, publication);
    };
    _this.handleMetrics = function(metrics, participant) {
      _this.emit(RoomEvent.MetricsReceived, metrics, participant);
    };
    _this.handleChatMessage = function(participant, chatMessage) {
      var msg = extractChatMessage(chatMessage);
      _this.emit(RoomEvent.ChatMessage, msg, participant);
    };
    _this.handleAudioPlaybackStarted = function() {
      if (_this.canPlaybackAudio) {
        return;
      }
      _this.audioEnabled = true;
      _this.emit(RoomEvent.AudioPlaybackStatusChanged, true);
    };
    _this.handleAudioPlaybackFailed = function(e) {
      _this.log.warn("could not playback audio", Object.assign(Object.assign({}, _this.logContext), {
        error: e
      }));
      if (!_this.canPlaybackAudio) {
        return;
      }
      _this.audioEnabled = false;
      _this.emit(RoomEvent.AudioPlaybackStatusChanged, false);
    };
    _this.handleVideoPlaybackStarted = function() {
      if (_this.isVideoPlaybackBlocked) {
        _this.isVideoPlaybackBlocked = false;
        _this.emit(RoomEvent.VideoPlaybackStatusChanged, true);
      }
    };
    _this.handleVideoPlaybackFailed = function() {
      if (!_this.isVideoPlaybackBlocked) {
        _this.isVideoPlaybackBlocked = true;
        _this.emit(RoomEvent.VideoPlaybackStatusChanged, false);
      }
    };
    _this.handleDeviceChange = function() {
      return __awaiter(_this, void 0, void 0, _regenerator().m(function _callee0() {
        var _this6 = this;
        var _a2, _b2, previousDevices, availableDevices, browser, _iterator3, _step3, _loop, kinds, _loop2, _ret, _i, _kinds, _t8;
        return _regenerator().w(function(_context10) {
          while (1) switch (_context10.n) {
            case 0:
              previousDevices = DeviceManager.getInstance().previousDevices;
              _context10.n = 1;
              return DeviceManager.getInstance().getDevices(void 0, false);
            case 1:
              availableDevices = _context10.v;
              browser = getBrowser();
              if (!((browser === null || browser === void 0 ? void 0 : browser.name) === "Chrome" && browser.os !== "iOS")) {
                _context10.n = 8;
                break;
              }
              _iterator3 = _createForOfIteratorHelper(availableDevices);
              _context10.p = 2;
              _loop = _regenerator().m(function _loop3() {
                var availableDevice, previousDevice;
                return _regenerator().w(function(_context0) {
                  while (1) switch (_context0.n) {
                    case 0:
                      availableDevice = _step3.value;
                      previousDevice = previousDevices.find(function(info) {
                        return info.deviceId === availableDevice.deviceId;
                      });
                      if (previousDevice && previousDevice.label !== "" && previousDevice.kind === availableDevice.kind && previousDevice.label !== availableDevice.label) {
                        if (_this6.getActiveDevice(availableDevice.kind) === "default") {
                          _this6.emit(RoomEvent.ActiveDeviceChanged, availableDevice.kind, availableDevice.deviceId);
                        }
                      }
                    case 1:
                      return _context0.a(2);
                  }
                }, _loop3);
              });
              _iterator3.s();
            case 3:
              if ((_step3 = _iterator3.n()).done) {
                _context10.n = 5;
                break;
              }
              return _context10.d(_regeneratorValues(_loop()), 4);
            case 4:
              _context10.n = 3;
              break;
            case 5:
              _context10.n = 7;
              break;
            case 6:
              _context10.p = 6;
              _t8 = _context10.v;
              _iterator3.e(_t8);
            case 7:
              _context10.p = 7;
              _iterator3.f();
              return _context10.f(7);
            case 8:
              kinds = ["audiooutput", "audioinput", "videoinput"];
              _loop2 = _regenerator().m(function _loop22() {
                var kind, devicesOfKind, activeDevice;
                return _regenerator().w(function(_context1) {
                  while (1) switch (_context1.n) {
                    case 0:
                      kind = _kinds[_i];
                      devicesOfKind = availableDevices.filter(function(d) {
                        return d.kind === kind;
                      });
                      activeDevice = _this6.getActiveDevice(kind);
                      if (!(activeDevice === ((_a2 = previousDevices.filter(function(info) {
                        return info.kind === kind;
                      })[0]) === null || _a2 === void 0 ? void 0 : _a2.deviceId))) {
                        _context1.n = 2;
                        break;
                      }
                      if (!(devicesOfKind.length > 0 && ((_b2 = devicesOfKind[0]) === null || _b2 === void 0 ? void 0 : _b2.deviceId) !== activeDevice)) {
                        _context1.n = 2;
                        break;
                      }
                      _context1.n = 1;
                      return _this6.switchActiveDevice(kind, devicesOfKind[0].deviceId);
                    case 1:
                      return _context1.a(2, 0);
                    case 2:
                      if (!(kind === "audioinput" && !isSafari() || kind === "videoinput")) {
                        _context1.n = 3;
                        break;
                      }
                      return _context1.a(2, 0);
                    case 3:
                      if (!(devicesOfKind.length > 0 && !devicesOfKind.find(function(deviceInfo) {
                        return deviceInfo.deviceId === _this6.getActiveDevice(kind);
                      }))) {
                        _context1.n = 4;
                        break;
                      }
                      _context1.n = 4;
                      return _this6.switchActiveDevice(kind, devicesOfKind[0].deviceId);
                    case 4:
                      return _context1.a(2);
                  }
                }, _loop22);
              });
              _i = 0, _kinds = kinds;
            case 9:
              if (!(_i < _kinds.length)) {
                _context10.n = 12;
                break;
              }
              return _context10.d(_regeneratorValues(_loop2()), 10);
            case 10:
              _ret = _context10.v;
              if (!(_ret === 0)) {
                _context10.n = 11;
                break;
              }
              return _context10.a(3, 11);
            case 11:
              _i++;
              _context10.n = 9;
              break;
            case 12:
              this.emit(RoomEvent.MediaDevicesChanged);
            case 13:
              return _context10.a(2);
          }
        }, _callee0, this, [[2, 6, 7, 8]]);
      }));
    };
    _this.handleRoomUpdate = function(room) {
      var oldRoom = _this.roomInfo;
      _this.roomInfo = room;
      if (oldRoom && oldRoom.metadata !== room.metadata) {
        _this.emitWhenConnected(RoomEvent.RoomMetadataChanged, room.metadata);
      }
      if ((oldRoom === null || oldRoom === void 0 ? void 0 : oldRoom.activeRecording) !== room.activeRecording) {
        _this.emitWhenConnected(RoomEvent.RecordingStatusChanged, room.activeRecording);
      }
    };
    _this.handleConnectionQualityUpdate = function(update) {
      update.updates.forEach(function(info) {
        if (info.participantSid === _this.localParticipant.sid) {
          _this.localParticipant.setConnectionQuality(info.quality);
          return;
        }
        var participant = _this.getRemoteParticipantBySid(info.participantSid);
        if (participant) {
          participant.setConnectionQuality(info.quality);
        }
      });
    };
    _this.onLocalParticipantMetadataChanged = function(metadata) {
      _this.emit(RoomEvent.ParticipantMetadataChanged, metadata, _this.localParticipant);
    };
    _this.onLocalParticipantNameChanged = function(name) {
      _this.emit(RoomEvent.ParticipantNameChanged, name, _this.localParticipant);
    };
    _this.onLocalAttributesChanged = function(changedAttributes) {
      _this.emit(RoomEvent.ParticipantAttributesChanged, changedAttributes, _this.localParticipant);
    };
    _this.onLocalTrackMuted = function(pub) {
      _this.emit(RoomEvent.TrackMuted, pub, _this.localParticipant);
    };
    _this.onLocalTrackUnmuted = function(pub) {
      _this.emit(RoomEvent.TrackUnmuted, pub, _this.localParticipant);
    };
    _this.onTrackProcessorUpdate = function(processor) {
      var _a2;
      (_a2 = processor === null || processor === void 0 ? void 0 : processor.onPublish) === null || _a2 === void 0 ? void 0 : _a2.call(processor, _this);
    };
    _this.onLocalTrackPublished = function(pub) {
      return __awaiter(_this, void 0, void 0, _regenerator().m(function _callee1() {
        var _a2, _b2, _c2, _d, _e, _f, trackIsSilent, deviceId, deviceKind;
        return _regenerator().w(function(_context11) {
          while (1) switch (_context11.n) {
            case 0:
              (_a2 = pub.track) === null || _a2 === void 0 ? void 0 : _a2.on(TrackEvent.TrackProcessorUpdate, this.onTrackProcessorUpdate);
              (_b2 = pub.track) === null || _b2 === void 0 ? void 0 : _b2.on(TrackEvent.Restarted, this.onLocalTrackRestarted);
              (_e = (_d = (_c2 = pub.track) === null || _c2 === void 0 ? void 0 : _c2.getProcessor()) === null || _d === void 0 ? void 0 : _d.onPublish) === null || _e === void 0 ? void 0 : _e.call(_d, this);
              this.emit(RoomEvent.LocalTrackPublished, pub, this.localParticipant);
              if (!(pub.track instanceof LocalAudioTrack)) {
                _context11.n = 2;
                break;
              }
              _context11.n = 1;
              return pub.track.checkForSilence();
            case 1:
              trackIsSilent = _context11.v;
              if (trackIsSilent) {
                this.emit(RoomEvent.LocalAudioSilenceDetected, pub);
              }
            case 2:
              _context11.n = 3;
              return (_f = pub.track) === null || _f === void 0 ? void 0 : _f.getDeviceId(false);
            case 3:
              deviceId = _context11.v;
              deviceKind = sourceToKind(pub.source);
              if (deviceKind && deviceId && deviceId !== this.localParticipant.activeDeviceMap.get(deviceKind)) {
                this.localParticipant.activeDeviceMap.set(deviceKind, deviceId);
                this.emit(RoomEvent.ActiveDeviceChanged, deviceKind, deviceId);
              }
            case 4:
              return _context11.a(2);
          }
        }, _callee1, this);
      }));
    };
    _this.onLocalTrackUnpublished = function(pub) {
      var _a2, _b2;
      (_a2 = pub.track) === null || _a2 === void 0 ? void 0 : _a2.off(TrackEvent.TrackProcessorUpdate, _this.onTrackProcessorUpdate);
      (_b2 = pub.track) === null || _b2 === void 0 ? void 0 : _b2.off(TrackEvent.Restarted, _this.onLocalTrackRestarted);
      _this.emit(RoomEvent.LocalTrackUnpublished, pub, _this.localParticipant);
    };
    _this.onLocalTrackRestarted = function(track) {
      return __awaiter(_this, void 0, void 0, _regenerator().m(function _callee10() {
        var deviceId, deviceKind;
        return _regenerator().w(function(_context12) {
          while (1) switch (_context12.n) {
            case 0:
              _context12.n = 1;
              return track.getDeviceId(false);
            case 1:
              deviceId = _context12.v;
              deviceKind = sourceToKind(track.source);
              if (deviceKind && deviceId && deviceId !== this.localParticipant.activeDeviceMap.get(deviceKind)) {
                this.log.debug("local track restarted, setting ".concat(deviceKind, " ").concat(deviceId, " active"), this.logContext);
                this.localParticipant.activeDeviceMap.set(deviceKind, deviceId);
                this.emit(RoomEvent.ActiveDeviceChanged, deviceKind, deviceId);
              }
            case 2:
              return _context12.a(2);
          }
        }, _callee10, this);
      }));
    };
    _this.onLocalConnectionQualityChanged = function(quality) {
      _this.emit(RoomEvent.ConnectionQualityChanged, quality, _this.localParticipant);
    };
    _this.onMediaDevicesError = function(e) {
      _this.emit(RoomEvent.MediaDevicesError, e);
    };
    _this.onLocalParticipantPermissionsChanged = function(prevPermissions) {
      _this.emit(RoomEvent.ParticipantPermissionsChanged, prevPermissions, _this.localParticipant);
    };
    _this.onLocalChatMessageSent = function(msg) {
      _this.emit(RoomEvent.ChatMessage, msg, _this.localParticipant);
    };
    _this.setMaxListeners(100);
    _this.remoteParticipants = /* @__PURE__ */ new Map();
    _this.sidToIdentity = /* @__PURE__ */ new Map();
    _this.options = Object.assign(Object.assign({}, roomOptionDefaults), options);
    _this.log = getLogger((_a = _this.options.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Room);
    _this.transcriptionReceivedTimes = /* @__PURE__ */ new Map();
    _this.options.audioCaptureDefaults = Object.assign(Object.assign({}, audioDefaults), options === null || options === void 0 ? void 0 : options.audioCaptureDefaults);
    _this.options.videoCaptureDefaults = Object.assign(Object.assign({}, videoDefaults), options === null || options === void 0 ? void 0 : options.videoCaptureDefaults);
    _this.options.publishDefaults = Object.assign(Object.assign({}, publishDefaults), options === null || options === void 0 ? void 0 : options.publishDefaults);
    _this.maybeCreateEngine();
    _this.disconnectLock = new Mutex();
    _this.localParticipant = new LocalParticipant("", "", _this.engine, _this.options);
    if (_this.options.videoCaptureDefaults.deviceId) {
      _this.localParticipant.activeDeviceMap.set("videoinput", unwrapConstraint(_this.options.videoCaptureDefaults.deviceId));
    }
    if (_this.options.audioCaptureDefaults.deviceId) {
      _this.localParticipant.activeDeviceMap.set("audioinput", unwrapConstraint(_this.options.audioCaptureDefaults.deviceId));
    }
    if ((_b = _this.options.audioOutput) === null || _b === void 0 ? void 0 : _b.deviceId) {
      _this.switchActiveDevice("audiooutput", unwrapConstraint(_this.options.audioOutput.deviceId))["catch"](function(e) {
        return _this.log.warn("Could not set audio output: ".concat(e.message), _this.logContext);
      });
    }
    if (_this.options.e2ee) {
      _this.setupE2EE();
    }
    if (isWeb()) {
      var abortController = new AbortController();
      (_c = navigator.mediaDevices) === null || _c === void 0 ? void 0 : _c.addEventListener("devicechange", _this.handleDeviceChange, {
        signal: abortController.signal
      });
      if (Room2.cleanupRegistry) {
        Room2.cleanupRegistry.register(_this, function() {
          abortController.abort();
        });
      }
    }
    return _this;
  }
  _inherits(Room2, _EventEmitter);
  return _createClass(Room2, [{
    key: "setE2EEEnabled",
    value: function setE2EEEnabled(enabled) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee11() {
        return _regenerator().w(function(_context13) {
          while (1) switch (_context13.n) {
            case 0:
              if (!this.e2eeManager) {
                _context13.n = 2;
                break;
              }
              _context13.n = 1;
              return Promise.all([this.localParticipant.setE2EEEnabled(enabled)]);
            case 1:
              if (this.localParticipant.identity !== "") {
                this.e2eeManager.setParticipantCryptorEnabled(enabled, this.localParticipant.identity);
              }
              _context13.n = 3;
              break;
            case 2:
              throw Error("e2ee not configured, please set e2ee settings within the room options");
            case 3:
              return _context13.a(2);
          }
        }, _callee11, this);
      }));
    }
  }, {
    key: "setupE2EE",
    value: function setupE2EE() {
      var _this7 = this;
      var _a;
      if (this.options.e2ee) {
        if ("e2eeManager" in this.options.e2ee) {
          this.e2eeManager = this.options.e2ee.e2eeManager;
        } else {
          this.e2eeManager = new E2EEManager(this.options.e2ee);
        }
        this.e2eeManager.on(EncryptionEvent.ParticipantEncryptionStatusChanged, function(enabled, participant) {
          if (participant instanceof LocalParticipant) {
            _this7.isE2EEEnabled = enabled;
          }
          _this7.emit(RoomEvent.ParticipantEncryptionStatusChanged, enabled, participant);
        });
        this.e2eeManager.on(EncryptionEvent.EncryptionError, function(error) {
          return _this7.emit(RoomEvent.EncryptionError, error);
        });
        (_a = this.e2eeManager) === null || _a === void 0 ? void 0 : _a.setup(this);
      }
    }
  }, {
    key: "logContext",
    get: function get2() {
      var _a;
      return {
        room: this.name,
        roomID: (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.sid,
        participant: this.localParticipant.identity,
        pID: this.localParticipant.sid
      };
    }
    /**
     * if the current room has a participant with `recorder: true` in its JWT grant
     **/
  }, {
    key: "isRecording",
    get: function get2() {
      var _a, _b;
      return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.activeRecording) !== null && _b !== void 0 ? _b : false;
    }
    /**
     * server assigned unique room id.
     * returns once a sid has been issued by the server.
     */
  }, {
    key: "getSid",
    value: function getSid() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee12() {
        var _this8 = this;
        return _regenerator().w(function(_context14) {
          while (1) switch (_context14.n) {
            case 0:
              if (!(this.state === ConnectionState.Disconnected)) {
                _context14.n = 1;
                break;
              }
              return _context14.a(2, "");
            case 1:
              if (!(this.roomInfo && this.roomInfo.sid !== "")) {
                _context14.n = 2;
                break;
              }
              return _context14.a(2, this.roomInfo.sid);
            case 2:
              return _context14.a(2, new Promise(function(resolve, reject) {
                var _handleRoomUpdate = function handleRoomUpdate(roomInfo) {
                  if (roomInfo.sid !== "") {
                    _this8.engine.off(EngineEvent.RoomUpdate, _handleRoomUpdate);
                    resolve(roomInfo.sid);
                  }
                };
                _this8.engine.on(EngineEvent.RoomUpdate, _handleRoomUpdate);
                _this8.once(RoomEvent.Disconnected, function() {
                  _this8.engine.off(EngineEvent.RoomUpdate, _handleRoomUpdate);
                  reject("Room disconnected before room server id was available");
                });
              }));
          }
        }, _callee12, this);
      }));
    }
    /** user assigned name, derived from JWT token */
  }, {
    key: "name",
    get: function get2() {
      var _a, _b;
      return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : "";
    }
    /** room metadata */
  }, {
    key: "metadata",
    get: function get2() {
      var _a;
      return (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.metadata;
    }
  }, {
    key: "numParticipants",
    get: function get2() {
      var _a, _b;
      return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.numParticipants) !== null && _b !== void 0 ? _b : 0;
    }
  }, {
    key: "numPublishers",
    get: function get2() {
      var _a, _b;
      return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.numPublishers) !== null && _b !== void 0 ? _b : 0;
    }
  }, {
    key: "maybeCreateEngine",
    value: function maybeCreateEngine() {
      var _this9 = this;
      if (this.engine && !this.engine.isClosed) {
        return;
      }
      var iceDelay = 0;
      this.engine = new RTCEngine(this.options);
      this.engine.on(EngineEvent.ParticipantUpdate, this.handleParticipantUpdates).on(EngineEvent.RoomUpdate, this.handleRoomUpdate).on(EngineEvent.SpeakersChanged, this.handleSpeakersChanged).on(EngineEvent.StreamStateChanged, this.handleStreamStateUpdate).on(EngineEvent.ConnectionQualityUpdate, this.handleConnectionQualityUpdate).on(EngineEvent.SubscriptionError, this.handleSubscriptionError).on(EngineEvent.SubscriptionPermissionUpdate, this.handleSubscriptionPermissionUpdate).on(EngineEvent.MediaTrackAdded, function(mediaTrack, stream, receiver) {
        _this9.onTrackAdded(mediaTrack, stream, receiver);
      }).on(EngineEvent.Disconnected, function(reason) {
        _this9.handleDisconnect(_this9.options.stopLocalTrackOnUnpublish, reason);
      }).on(EngineEvent.ActiveSpeakersUpdate, this.handleActiveSpeakersUpdate).on(EngineEvent.DataPacketReceived, this.handleDataPacket).on(EngineEvent.Resuming, function() {
        _this9.clearConnectionReconcile();
        _this9.isResuming = true;
        _this9.log.info("Resuming signal connection", _this9.logContext);
        if (_this9.setAndEmitConnectionState(ConnectionState.SignalReconnecting)) {
          _this9.emit(RoomEvent.SignalReconnecting);
        }
      }).on(EngineEvent.Resumed, function() {
        _this9.registerConnectionReconcile();
        _this9.isResuming = false;
        _this9.log.info("Resumed signal connection", _this9.logContext);
        _this9.updateSubscriptions();
        _this9.emitBufferedEvents();
        if (_this9.setAndEmitConnectionState(ConnectionState.Connected)) {
          _this9.emit(RoomEvent.Reconnected);
        }
      }).on(EngineEvent.SignalResumed, function() {
        _this9.bufferedEvents = [];
        if (_this9.state === ConnectionState.Reconnecting || _this9.isResuming) {
          _this9.sendSyncState();
        }
      }).on(EngineEvent.Restarting, this.handleRestarting).on(EngineEvent.SignalRestarted, this.handleSignalRestarted).on(EngineEvent.Offline, function() {
        if (_this9.setAndEmitConnectionState(ConnectionState.Reconnecting)) {
          _this9.emit(RoomEvent.Reconnecting);
        }
      }).on(EngineEvent.DCBufferStatusChanged, function(status, kind) {
        _this9.emit(RoomEvent.DCBufferStatusChanged, status, kind);
      }).on(EngineEvent.PrimaryDelay, function(delay) {
        iceDelay = Math.max(iceDelay, delay);
      }).on(EngineEvent.SecondaryDelay, function(delay) {
        iceDelay = Math.max(iceDelay, delay);
        _this9.emit(RoomEvent.ReconnectICEDelay, iceDelay / 1e3);
        iceDelay = 0;
      }).on(EngineEvent.LocalTrackSubscribed, function(subscribedSid) {
        var trackPublication = _this9.localParticipant.getTrackPublications().find(function(_ref3) {
          var trackSid = _ref3.trackSid;
          return trackSid === subscribedSid;
        });
        if (!trackPublication) {
          _this9.log.warn("could not find local track subscription for subscribed event", _this9.logContext);
          return;
        }
        _this9.localParticipant.emit(ParticipantEvent.LocalTrackSubscribed, trackPublication);
        _this9.emitWhenConnected(RoomEvent.LocalTrackSubscribed, trackPublication, _this9.localParticipant);
      });
      if (this.localParticipant) {
        this.localParticipant.setupEngine(this.engine);
      }
      if (this.e2eeManager) {
        this.e2eeManager.setupEngine(this.engine);
      }
    }
    /**
     * getLocalDevices abstracts navigator.mediaDevices.enumerateDevices.
     * In particular, it requests device permissions by default if needed
     * and makes sure the returned device does not consist of dummy devices
     * @param kind
     * @returns a list of available local devices
     */
  }, {
    key: "prepareConnection",
    value: (
      /**
       * prepareConnection should be called as soon as the page is loaded, in order
       * to speed up the connection attempt. This function will
       * - perform DNS resolution and pre-warm the DNS cache
       * - establish TLS connection and cache TLS keys
       *
       * With LiveKit Cloud, it will also determine the best edge data center for
       * the current client to connect to if a token is provided.
       */
      function prepareConnection(url, token) {
        return __awaiter(this, void 0, void 0, _regenerator().m(function _callee13() {
          var regionUrl, _t9;
          return _regenerator().w(function(_context15) {
            while (1) switch (_context15.n) {
              case 0:
                if (!(this.state !== ConnectionState.Disconnected)) {
                  _context15.n = 1;
                  break;
                }
                return _context15.a(2);
              case 1:
                this.log.debug("prepareConnection to ".concat(url), this.logContext);
                _context15.p = 2;
                if (!(isCloud(new URL(url)) && token)) {
                  _context15.n = 6;
                  break;
                }
                this.regionUrlProvider = new RegionUrlProvider(url, token);
                _context15.n = 3;
                return this.regionUrlProvider.getNextBestRegionUrl();
              case 3:
                regionUrl = _context15.v;
                if (!(regionUrl && this.state === ConnectionState.Disconnected)) {
                  _context15.n = 5;
                  break;
                }
                this.regionUrl = regionUrl;
                _context15.n = 4;
                return fetch(toHttpUrl(regionUrl), {
                  method: "HEAD"
                });
              case 4:
                this.log.debug("prepared connection to ".concat(regionUrl), this.logContext);
              case 5:
                _context15.n = 7;
                break;
              case 6:
                _context15.n = 7;
                return fetch(toHttpUrl(url), {
                  method: "HEAD"
                });
              case 7:
                _context15.n = 9;
                break;
              case 8:
                _context15.p = 8;
                _t9 = _context15.v;
                this.log.warn("could not prepare connection", Object.assign(Object.assign({}, this.logContext), {
                  error: _t9
                }));
              case 9:
                return _context15.a(2);
            }
          }, _callee13, this, [[2, 8]]);
        }));
      }
    )
    /**
     * retrieves a participant by identity
     * @param identity
     * @returns
     */
  }, {
    key: "getParticipantByIdentity",
    value: function getParticipantByIdentity(identity) {
      if (this.localParticipant.identity === identity) {
        return this.localParticipant;
      }
      return this.remoteParticipants.get(identity);
    }
  }, {
    key: "clearConnectionFutures",
    value: function clearConnectionFutures() {
      this.connectFuture = void 0;
    }
    /**
     * @internal for testing
     */
  }, {
    key: "simulateScenario",
    value: function simulateScenario(scenario, arg) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee17() {
        var _this0 = this;
        var postAction, req, _t0;
        return _regenerator().w(function(_context19) {
          while (1) switch (_context19.n) {
            case 0:
              postAction = function postAction2() {
              };
              _t0 = scenario;
              _context19.n = _t0 === "signal-reconnect" ? 1 : _t0 === "speaker" ? 3 : _t0 === "node-failure" ? 4 : _t0 === "server-leave" ? 5 : _t0 === "migration" ? 6 : _t0 === "resume-reconnect" ? 7 : _t0 === "disconnect-signal-on-resume" ? 9 : _t0 === "disconnect-signal-on-resume-no-messages" ? 10 : _t0 === "full-reconnect" ? 11 : _t0 === "force-tcp" ? 13 : _t0 === "force-tls" ? 13 : _t0 === "subscriber-bandwidth" ? 14 : _t0 === "leave-full-reconnect" ? 16 : 17;
              break;
            case 1:
              _context19.n = 2;
              return this.engine.client.handleOnClose("simulate disconnect");
            case 2:
              return _context19.a(3, 17);
            case 3:
              req = new SimulateScenario({
                scenario: {
                  "case": "speakerUpdate",
                  value: 3
                }
              });
              return _context19.a(3, 17);
            case 4:
              req = new SimulateScenario({
                scenario: {
                  "case": "nodeFailure",
                  value: true
                }
              });
              return _context19.a(3, 17);
            case 5:
              req = new SimulateScenario({
                scenario: {
                  "case": "serverLeave",
                  value: true
                }
              });
              return _context19.a(3, 17);
            case 6:
              req = new SimulateScenario({
                scenario: {
                  "case": "migration",
                  value: true
                }
              });
              return _context19.a(3, 17);
            case 7:
              this.engine.failNext();
              _context19.n = 8;
              return this.engine.client.handleOnClose("simulate resume-disconnect");
            case 8:
              return _context19.a(3, 17);
            case 9:
              postAction = function postAction2() {
                return __awaiter(_this0, void 0, void 0, _regenerator().m(function _callee14() {
                  return _regenerator().w(function(_context16) {
                    while (1) switch (_context16.n) {
                      case 0:
                        _context16.n = 1;
                        return this.engine.client.handleOnClose("simulate resume-disconnect");
                      case 1:
                        return _context16.a(2);
                    }
                  }, _callee14, this);
                }));
              };
              req = new SimulateScenario({
                scenario: {
                  "case": "disconnectSignalOnResume",
                  value: true
                }
              });
              return _context19.a(3, 17);
            case 10:
              postAction = function postAction2() {
                return __awaiter(_this0, void 0, void 0, _regenerator().m(function _callee15() {
                  return _regenerator().w(function(_context17) {
                    while (1) switch (_context17.n) {
                      case 0:
                        _context17.n = 1;
                        return this.engine.client.handleOnClose("simulate resume-disconnect");
                      case 1:
                        return _context17.a(2);
                    }
                  }, _callee15, this);
                }));
              };
              req = new SimulateScenario({
                scenario: {
                  "case": "disconnectSignalOnResumeNoMessages",
                  value: true
                }
              });
              return _context19.a(3, 17);
            case 11:
              this.engine.fullReconnectOnNext = true;
              _context19.n = 12;
              return this.engine.client.handleOnClose("simulate full-reconnect");
            case 12:
              return _context19.a(3, 17);
            case 13:
              req = new SimulateScenario({
                scenario: {
                  "case": "switchCandidateProtocol",
                  value: scenario === "force-tls" ? 2 : 1
                }
              });
              postAction = function postAction2() {
                return __awaiter(_this0, void 0, void 0, _regenerator().m(function _callee16() {
                  var onLeave;
                  return _regenerator().w(function(_context18) {
                    while (1) switch (_context18.n) {
                      case 0:
                        onLeave = this.engine.client.onLeave;
                        if (onLeave) {
                          onLeave(new LeaveRequest({
                            reason: DisconnectReason.CLIENT_INITIATED,
                            action: LeaveRequest_Action.RECONNECT
                          }));
                        }
                      case 1:
                        return _context18.a(2);
                    }
                  }, _callee16, this);
                }));
              };
              return _context19.a(3, 17);
            case 14:
              if (!(arg === void 0 || typeof arg !== "number")) {
                _context19.n = 15;
                break;
              }
              throw new Error("subscriber-bandwidth requires a number as argument");
            case 15:
              req = new SimulateScenario({
                scenario: {
                  "case": "subscriberBandwidth",
                  value: BigInt(arg)
                }
              });
              return _context19.a(3, 17);
            case 16:
              req = new SimulateScenario({
                scenario: {
                  "case": "leaveRequestFullReconnect",
                  value: true
                }
              });
            case 17:
              if (!req) {
                _context19.n = 19;
                break;
              }
              _context19.n = 18;
              return this.engine.client.sendSimulateScenario(req);
            case 18:
              _context19.n = 19;
              return postAction();
            case 19:
              return _context19.a(2);
          }
        }, _callee17, this);
      }));
    }
    /**
     * Returns true if audio playback is enabled
     */
  }, {
    key: "canPlaybackAudio",
    get: function get2() {
      return this.audioEnabled;
    }
    /**
     * Returns true if video playback is enabled
     */
  }, {
    key: "canPlaybackVideo",
    get: function get2() {
      return !this.isVideoPlaybackBlocked;
    }
  }, {
    key: "getActiveDevice",
    value: function getActiveDevice(kind) {
      return this.localParticipant.activeDeviceMap.get(kind);
    }
    /**
     * Switches all active devices used in this room to the given device.
     *
     * Note: setting AudioOutput is not supported on some browsers. See [setSinkId](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId#browser_compatibility)
     *
     * @param kind use `videoinput` for camera track,
     *  `audioinput` for microphone track,
     *  `audiooutput` to set speaker for all incoming audio tracks
     * @param deviceId
     */
  }, {
    key: "switchActiveDevice",
    value: function switchActiveDevice(kind_1, deviceId_1) {
      return __awaiter(this, arguments, void 0, function(kind, deviceId) {
        var _this1 = this;
        var exact = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        return _regenerator().m(function _callee18() {
          var _a, _b, _c, _d, _e, _f, _g, _h, success, needsUpdateWithoutTracks, deviceConstraint, prevDeviceId, tracks, _prevDeviceId, _tracks, _prevDeviceId2, _t1, _t10, _t11, _t12, _t13, _t14;
          return _regenerator().w(function(_context20) {
            while (1) switch (_context20.n) {
              case 0:
                success = true;
                needsUpdateWithoutTracks = false;
                deviceConstraint = exact ? {
                  exact: deviceId
                } : deviceId;
                if (!(kind === "audioinput")) {
                  _context20.n = 5;
                  break;
                }
                needsUpdateWithoutTracks = _this1.localParticipant.audioTrackPublications.size === 0;
                prevDeviceId = (_a = _this1.getActiveDevice(kind)) !== null && _a !== void 0 ? _a : _this1.options.audioCaptureDefaults.deviceId;
                _this1.options.audioCaptureDefaults.deviceId = deviceConstraint;
                tracks = Array.from(_this1.localParticipant.audioTrackPublications.values()).filter(function(track) {
                  return track.source === Track.Source.Microphone;
                });
                _context20.p = 1;
                _context20.n = 2;
                return Promise.all(tracks.map(function(t) {
                  var _a2;
                  return (_a2 = t.audioTrack) === null || _a2 === void 0 ? void 0 : _a2.setDeviceId(deviceConstraint);
                }));
              case 2:
                success = _context20.v.every(function(val) {
                  return val === true;
                });
                _context20.n = 4;
                break;
              case 3:
                _context20.p = 3;
                _t1 = _context20.v;
                _this1.options.audioCaptureDefaults.deviceId = prevDeviceId;
                throw _t1;
              case 4:
                _context20.n = 20;
                break;
              case 5:
                if (!(kind === "videoinput")) {
                  _context20.n = 10;
                  break;
                }
                needsUpdateWithoutTracks = _this1.localParticipant.videoTrackPublications.size === 0;
                _prevDeviceId = (_b = _this1.getActiveDevice(kind)) !== null && _b !== void 0 ? _b : _this1.options.videoCaptureDefaults.deviceId;
                _this1.options.videoCaptureDefaults.deviceId = deviceConstraint;
                _tracks = Array.from(_this1.localParticipant.videoTrackPublications.values()).filter(function(track) {
                  return track.source === Track.Source.Camera;
                });
                _context20.p = 6;
                _context20.n = 7;
                return Promise.all(_tracks.map(function(t) {
                  var _a2;
                  return (_a2 = t.videoTrack) === null || _a2 === void 0 ? void 0 : _a2.setDeviceId(deviceConstraint);
                }));
              case 7:
                success = _context20.v.every(function(val) {
                  return val === true;
                });
                _context20.n = 9;
                break;
              case 8:
                _context20.p = 8;
                _t10 = _context20.v;
                _this1.options.videoCaptureDefaults.deviceId = _prevDeviceId;
                throw _t10;
              case 9:
                _context20.n = 20;
                break;
              case 10:
                if (!(kind === "audiooutput")) {
                  _context20.n = 20;
                  break;
                }
                if (!(!supportsSetSinkId() && !_this1.options.webAudioMix || _this1.options.webAudioMix && _this1.audioContext && !("setSinkId" in _this1.audioContext))) {
                  _context20.n = 11;
                  break;
                }
                throw new Error("cannot switch audio output, setSinkId not supported");
              case 11:
                if (!_this1.options.webAudioMix) {
                  _context20.n = 16;
                  break;
                }
                _context20.n = 12;
                return DeviceManager.getInstance().normalizeDeviceId("audiooutput", deviceId);
              case 12:
                _t12 = _c = _context20.v;
                _t11 = _t12 !== null;
                if (!_t11) {
                  _context20.n = 13;
                  break;
                }
                _t11 = _c !== void 0;
              case 13:
                if (!_t11) {
                  _context20.n = 14;
                  break;
                }
                _t13 = _c;
                _context20.n = 15;
                break;
              case 14:
                _t13 = "";
              case 15:
                deviceId = _t13;
              case 16:
                (_d = (_h = _this1.options).audioOutput) !== null && _d !== void 0 ? _d : _h.audioOutput = {};
                _prevDeviceId2 = (_e = _this1.getActiveDevice(kind)) !== null && _e !== void 0 ? _e : _this1.options.audioOutput.deviceId;
                _this1.options.audioOutput.deviceId = deviceId;
                _context20.p = 17;
                if (_this1.options.webAudioMix) {
                  (_f = _this1.audioContext) === null || _f === void 0 ? void 0 : _f.setSinkId(deviceId);
                }
                _context20.n = 18;
                return Promise.all(Array.from(_this1.remoteParticipants.values()).map(function(p) {
                  return p.setAudioOutput({
                    deviceId
                  });
                }));
              case 18:
                _context20.n = 20;
                break;
              case 19:
                _context20.p = 19;
                _t14 = _context20.v;
                _this1.options.audioOutput.deviceId = _prevDeviceId2;
                throw _t14;
              case 20:
                if (needsUpdateWithoutTracks || kind === "audiooutput") {
                  _this1.localParticipant.activeDeviceMap.set(kind, kind === "audiooutput" && ((_g = _this1.options.audioOutput) === null || _g === void 0 ? void 0 : _g.deviceId) || deviceId);
                  _this1.emit(RoomEvent.ActiveDeviceChanged, kind, deviceId);
                }
                return _context20.a(2, success);
            }
          }, _callee18, null, [[17, 19], [6, 8], [1, 3]]);
        })();
      });
    }
  }, {
    key: "setupLocalParticipantEvents",
    value: function setupLocalParticipantEvents() {
      this.localParticipant.on(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).on(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).on(ParticipantEvent.AttributesChanged, this.onLocalAttributesChanged).on(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).on(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).on(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).on(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).on(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).on(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).on(ParticipantEvent.AudioStreamAcquired, this.startAudio).on(ParticipantEvent.ChatMessage, this.onLocalChatMessageSent).on(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);
    }
  }, {
    key: "recreateEngine",
    value: function recreateEngine() {
      var _a;
      (_a = this.engine) === null || _a === void 0 ? void 0 : _a.close();
      this.engine = void 0;
      this.isResuming = false;
      this.remoteParticipants.clear();
      this.sidToIdentity.clear();
      this.bufferedEvents = [];
      this.maybeCreateEngine();
    }
  }, {
    key: "onTrackAdded",
    value: function onTrackAdded(mediaTrack, stream, receiver) {
      var _this10 = this;
      if (this.state === ConnectionState.Connecting || this.state === ConnectionState.Reconnecting) {
        var reconnectedHandler = function reconnectedHandler2() {
          _this10.onTrackAdded(mediaTrack, stream, receiver);
          _cleanup();
        };
        var _cleanup = function cleanup() {
          _this10.off(RoomEvent.Reconnected, reconnectedHandler);
          _this10.off(RoomEvent.Connected, reconnectedHandler);
          _this10.off(RoomEvent.Disconnected, _cleanup);
        };
        this.once(RoomEvent.Reconnected, reconnectedHandler);
        this.once(RoomEvent.Connected, reconnectedHandler);
        this.once(RoomEvent.Disconnected, _cleanup);
        return;
      }
      if (this.state === ConnectionState.Disconnected) {
        this.log.warn("skipping incoming track after Room disconnected", this.logContext);
        return;
      }
      var parts = unpackStreamId(stream.id);
      var participantSid = parts[0];
      var streamId = parts[1];
      var trackId = mediaTrack.id;
      if (streamId && streamId.startsWith("TR")) trackId = streamId;
      if (participantSid === this.localParticipant.sid) {
        this.log.warn("tried to create RemoteParticipant for local participant", this.logContext);
        return;
      }
      var participant = Array.from(this.remoteParticipants.values()).find(function(p) {
        return p.sid === participantSid;
      });
      if (!participant) {
        this.log.error("Tried to add a track for a participant, that's not present. Sid: ".concat(participantSid), this.logContext);
        return;
      }
      var adaptiveStreamSettings;
      if (this.options.adaptiveStream) {
        if (_typeof(this.options.adaptiveStream) === "object") {
          adaptiveStreamSettings = this.options.adaptiveStream;
        } else {
          adaptiveStreamSettings = {};
        }
      }
      participant.addSubscribedMediaTrack(mediaTrack, trackId, stream, receiver, adaptiveStreamSettings);
    }
  }, {
    key: "handleDisconnect",
    value: function handleDisconnect() {
      var _this11 = this;
      var shouldStopTracks = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      var reason = arguments.length > 1 ? arguments[1] : void 0;
      var _a;
      this.clearConnectionReconcile();
      this.isResuming = false;
      this.bufferedEvents = [];
      this.transcriptionReceivedTimes.clear();
      if (this.state === ConnectionState.Disconnected) {
        return;
      }
      this.regionUrl = void 0;
      try {
        this.remoteParticipants.forEach(function(p) {
          p.trackPublications.forEach(function(pub) {
            p.unpublishTrack(pub.trackSid);
          });
        });
        this.localParticipant.trackPublications.forEach(function(pub) {
          var _a2, _b, _c;
          if (pub.track) {
            _this11.localParticipant.unpublishTrack(pub.track, shouldStopTracks);
          }
          if (shouldStopTracks) {
            (_a2 = pub.track) === null || _a2 === void 0 ? void 0 : _a2.detach();
            (_b = pub.track) === null || _b === void 0 ? void 0 : _b.stop();
          } else {
            (_c = pub.track) === null || _c === void 0 ? void 0 : _c.stopMonitor();
          }
        });
        this.localParticipant.off(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).off(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).off(ParticipantEvent.AttributesChanged, this.onLocalAttributesChanged).off(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).off(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).off(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).off(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).off(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).off(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).off(ParticipantEvent.AudioStreamAcquired, this.startAudio).off(ParticipantEvent.ChatMessage, this.onLocalChatMessageSent).off(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);
        this.localParticipant.trackPublications.clear();
        this.localParticipant.videoTrackPublications.clear();
        this.localParticipant.audioTrackPublications.clear();
        this.remoteParticipants.clear();
        this.sidToIdentity.clear();
        this.activeSpeakers = [];
        if (this.audioContext && typeof this.options.webAudioMix === "boolean") {
          this.audioContext.close();
          this.audioContext = void 0;
        }
        if (isWeb()) {
          window.removeEventListener("beforeunload", this.onPageLeave);
          window.removeEventListener("pagehide", this.onPageLeave);
          window.removeEventListener("freeze", this.onPageLeave);
          (_a = navigator.mediaDevices) === null || _a === void 0 ? void 0 : _a.removeEventListener("devicechange", this.handleDeviceChange);
        }
      } finally {
        this.setAndEmitConnectionState(ConnectionState.Disconnected);
        this.emit(RoomEvent.Disconnected, reason);
      }
    }
  }, {
    key: "handleParticipantDisconnected",
    value: function handleParticipantDisconnected(identity, participant) {
      var _a;
      this.remoteParticipants["delete"](identity);
      if (!participant) {
        return;
      }
      participant.trackPublications.forEach(function(publication) {
        participant.unpublishTrack(publication.trackSid, true);
      });
      this.emit(RoomEvent.ParticipantDisconnected, participant);
      (_a = this.localParticipant) === null || _a === void 0 ? void 0 : _a.handleParticipantDisconnected(participant.identity);
    }
  }, {
    key: "acquireAudioContext",
    value: function acquireAudioContext() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee19() {
        var _this12 = this;
        var _a, _b, newContextIsRunning, _t15;
        return _regenerator().w(function(_context21) {
          while (1) switch (_context21.n) {
            case 0:
              if (typeof this.options.webAudioMix !== "boolean" && this.options.webAudioMix.audioContext) {
                this.audioContext = this.options.webAudioMix.audioContext;
              } else if (!this.audioContext || this.audioContext.state === "closed") {
                this.audioContext = (_a = getNewAudioContext()) !== null && _a !== void 0 ? _a : void 0;
              }
              if (!(this.audioContext && this.audioContext.state === "suspended")) {
                _context21.n = 4;
                break;
              }
              _context21.p = 1;
              _context21.n = 2;
              return this.audioContext.resume();
            case 2:
              _context21.n = 4;
              break;
            case 3:
              _context21.p = 3;
              _t15 = _context21.v;
              this.log.warn("Could not resume audio context", Object.assign(Object.assign({}, this.logContext), {
                error: _t15
              }));
            case 4:
              if (this.options.webAudioMix) {
                this.remoteParticipants.forEach(function(participant) {
                  return participant.setAudioContext(_this12.audioContext);
                });
              }
              this.localParticipant.setAudioContext(this.audioContext);
              newContextIsRunning = ((_b = this.audioContext) === null || _b === void 0 ? void 0 : _b.state) === "running";
              if (newContextIsRunning !== this.canPlaybackAudio) {
                this.audioEnabled = newContextIsRunning;
                this.emit(RoomEvent.AudioPlaybackStatusChanged, newContextIsRunning);
              }
            case 5:
              return _context21.a(2);
          }
        }, _callee19, this, [[1, 3]]);
      }));
    }
  }, {
    key: "createParticipant",
    value: function createParticipant(identity, info) {
      var _this13 = this;
      var _a;
      var participant;
      if (info) {
        participant = RemoteParticipant.fromParticipantInfo(this.engine.client, info, {
          loggerContextCb: function loggerContextCb() {
            return _this13.logContext;
          },
          loggerName: this.options.loggerName
        });
      } else {
        participant = new RemoteParticipant(this.engine.client, "", identity, void 0, void 0, void 0, {
          loggerContextCb: function loggerContextCb() {
            return _this13.logContext;
          },
          loggerName: this.options.loggerName
        });
      }
      if (this.options.webAudioMix) {
        participant.setAudioContext(this.audioContext);
      }
      if ((_a = this.options.audioOutput) === null || _a === void 0 ? void 0 : _a.deviceId) {
        participant.setAudioOutput(this.options.audioOutput)["catch"](function(e) {
          return _this13.log.warn("Could not set audio output: ".concat(e.message), _this13.logContext);
        });
      }
      return participant;
    }
  }, {
    key: "getOrCreateParticipant",
    value: function getOrCreateParticipant(identity, info) {
      var _this14 = this;
      if (this.remoteParticipants.has(identity)) {
        var existingParticipant = this.remoteParticipants.get(identity);
        if (info) {
          var wasUpdated = existingParticipant.updateInfo(info);
          if (wasUpdated) {
            this.sidToIdentity.set(info.sid, info.identity);
          }
        }
        return existingParticipant;
      }
      var participant = this.createParticipant(identity, info);
      this.remoteParticipants.set(identity, participant);
      this.sidToIdentity.set(info.sid, info.identity);
      this.emitWhenConnected(RoomEvent.ParticipantConnected, participant);
      participant.on(ParticipantEvent.TrackPublished, function(trackPublication) {
        _this14.emitWhenConnected(RoomEvent.TrackPublished, trackPublication, participant);
      }).on(ParticipantEvent.TrackSubscribed, function(track, publication) {
        if (track.kind === Track.Kind.Audio) {
          track.on(TrackEvent.AudioPlaybackStarted, _this14.handleAudioPlaybackStarted);
          track.on(TrackEvent.AudioPlaybackFailed, _this14.handleAudioPlaybackFailed);
        } else if (track.kind === Track.Kind.Video) {
          track.on(TrackEvent.VideoPlaybackFailed, _this14.handleVideoPlaybackFailed);
          track.on(TrackEvent.VideoPlaybackStarted, _this14.handleVideoPlaybackStarted);
        }
        _this14.emit(RoomEvent.TrackSubscribed, track, publication, participant);
      }).on(ParticipantEvent.TrackUnpublished, function(publication) {
        _this14.emit(RoomEvent.TrackUnpublished, publication, participant);
      }).on(ParticipantEvent.TrackUnsubscribed, function(track, publication) {
        _this14.emit(RoomEvent.TrackUnsubscribed, track, publication, participant);
      }).on(ParticipantEvent.TrackSubscriptionFailed, function(sid) {
        _this14.emit(RoomEvent.TrackSubscriptionFailed, sid, participant);
      }).on(ParticipantEvent.TrackMuted, function(pub) {
        _this14.emitWhenConnected(RoomEvent.TrackMuted, pub, participant);
      }).on(ParticipantEvent.TrackUnmuted, function(pub) {
        _this14.emitWhenConnected(RoomEvent.TrackUnmuted, pub, participant);
      }).on(ParticipantEvent.ParticipantMetadataChanged, function(metadata) {
        _this14.emitWhenConnected(RoomEvent.ParticipantMetadataChanged, metadata, participant);
      }).on(ParticipantEvent.ParticipantNameChanged, function(name) {
        _this14.emitWhenConnected(RoomEvent.ParticipantNameChanged, name, participant);
      }).on(ParticipantEvent.AttributesChanged, function(changedAttributes) {
        _this14.emitWhenConnected(RoomEvent.ParticipantAttributesChanged, changedAttributes, participant);
      }).on(ParticipantEvent.ConnectionQualityChanged, function(quality) {
        _this14.emitWhenConnected(RoomEvent.ConnectionQualityChanged, quality, participant);
      }).on(ParticipantEvent.ParticipantPermissionsChanged, function(prevPermissions) {
        _this14.emitWhenConnected(RoomEvent.ParticipantPermissionsChanged, prevPermissions, participant);
      }).on(ParticipantEvent.TrackSubscriptionStatusChanged, function(pub, status) {
        _this14.emitWhenConnected(RoomEvent.TrackSubscriptionStatusChanged, pub, status, participant);
      }).on(ParticipantEvent.TrackSubscriptionFailed, function(trackSid, error) {
        _this14.emit(RoomEvent.TrackSubscriptionFailed, trackSid, participant, error);
      }).on(ParticipantEvent.TrackSubscriptionPermissionChanged, function(pub, status) {
        _this14.emitWhenConnected(RoomEvent.TrackSubscriptionPermissionChanged, pub, status, participant);
      });
      if (info) {
        participant.updateInfo(info);
      }
      return participant;
    }
  }, {
    key: "sendSyncState",
    value: function sendSyncState() {
      var remoteTracks = Array.from(this.remoteParticipants.values()).reduce(function(acc, participant) {
        acc.push.apply(acc, _toConsumableArray(participant.getTrackPublications()));
        return acc;
      }, []);
      var localTracks = this.localParticipant.getTrackPublications();
      this.engine.sendSyncState(remoteTracks, localTracks);
    }
    /**
     * After resuming, we'll need to notify the server of the current
     * subscription settings.
     */
  }, {
    key: "updateSubscriptions",
    value: function updateSubscriptions() {
      var _iterator4 = _createForOfIteratorHelper(this.remoteParticipants.values()), _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
          var p = _step4.value;
          var _iterator5 = _createForOfIteratorHelper(p.videoTrackPublications.values()), _step5;
          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
              var pub = _step5.value;
              if (pub.isSubscribed && pub instanceof RemoteTrackPublication) {
                pub.emitTrackUpdate();
              }
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    }
  }, {
    key: "getRemoteParticipantBySid",
    value: function getRemoteParticipantBySid(sid) {
      var identity = this.sidToIdentity.get(sid);
      if (identity) {
        return this.remoteParticipants.get(identity);
      }
    }
  }, {
    key: "registerConnectionReconcile",
    value: function registerConnectionReconcile() {
      var _this15 = this;
      this.clearConnectionReconcile();
      var consecutiveFailures = 0;
      this.connectionReconcileInterval = CriticalTimers.setInterval(function() {
        if (
          // ensure we didn't tear it down
          !_this15.engine || // engine detected close, but Room missed it
          _this15.engine.isClosed || // transports failed without notifying engine
          !_this15.engine.verifyTransport()
        ) {
          consecutiveFailures++;
          _this15.log.warn("detected connection state mismatch", Object.assign(Object.assign({}, _this15.logContext), {
            numFailures: consecutiveFailures,
            engine: _this15.engine ? {
              closed: _this15.engine.isClosed,
              transportsConnected: _this15.engine.verifyTransport()
            } : void 0
          }));
          if (consecutiveFailures >= 3) {
            _this15.recreateEngine();
            _this15.handleDisconnect(_this15.options.stopLocalTrackOnUnpublish, DisconnectReason.STATE_MISMATCH);
          }
        } else {
          consecutiveFailures = 0;
        }
      }, connectionReconcileFrequency);
    }
  }, {
    key: "clearConnectionReconcile",
    value: function clearConnectionReconcile() {
      if (this.connectionReconcileInterval) {
        CriticalTimers.clearInterval(this.connectionReconcileInterval);
      }
    }
  }, {
    key: "setAndEmitConnectionState",
    value: function setAndEmitConnectionState(state) {
      if (state === this.state) {
        return false;
      }
      this.state = state;
      this.emit(RoomEvent.ConnectionStateChanged, this.state);
      return true;
    }
  }, {
    key: "emitBufferedEvents",
    value: function emitBufferedEvents() {
      var _this16 = this;
      this.bufferedEvents.forEach(function(_ref4) {
        var _ref5 = _slicedToArray(_ref4, 2), ev = _ref5[0], args = _ref5[1];
        _this16.emit.apply(_this16, [ev].concat(_toConsumableArray(args)));
      });
      this.bufferedEvents = [];
    }
  }, {
    key: "emitWhenConnected",
    value: function emitWhenConnected(event) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      if (this.state === ConnectionState.Reconnecting || this.isResuming || !this.engine || this.engine.pendingReconnect) {
        this.bufferedEvents.push([event, args]);
      } else if (this.state === ConnectionState.Connected) {
        return this.emit.apply(this, [event].concat(args));
      }
      return false;
    }
    /**
     * Allows to populate a room with simulated participants.
     * No actual connection to a server will be established, all state is
     * @experimental
     */
  }, {
    key: "simulateParticipants",
    value: function simulateParticipants(options) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee20() {
        var _this17 = this;
        var _a, _b, publishOptions, participantOptions, camPub, audioPub, i, info, p, dummyVideo, videoTrack, dummyTrack, audioTrack, _t16, _t17, _t18, _t19, _t20, _t21, _t22, _t23, _t24, _t25, _t26, _t27, _t28, _t29, _t30, _t31, _t32, _t33, _t34, _t35, _t36;
        return _regenerator().w(function(_context22) {
          while (1) switch (_context22.n) {
            case 0:
              publishOptions = Object.assign({
                audio: true,
                video: true,
                useRealTracks: false
              }, options.publish);
              participantOptions = Object.assign({
                count: 9,
                audio: false,
                video: true,
                aspectRatios: [1.66, 1.7, 1.3]
              }, options.participants);
              this.handleDisconnect();
              this.roomInfo = new Room$1({
                sid: "RM_SIMULATED",
                name: "simulated-room",
                emptyTimeout: 0,
                maxParticipants: 0,
                creationTime: protoInt64.parse((/* @__PURE__ */ new Date()).getTime()),
                metadata: "",
                numParticipants: 1,
                numPublishers: 1,
                turnPassword: "",
                enabledCodecs: [],
                activeRecording: false
              });
              this.localParticipant.updateInfo(new ParticipantInfo({
                identity: "simulated-local",
                name: "local-name"
              }));
              this.setupLocalParticipantEvents();
              this.emit(RoomEvent.SignalConnected);
              this.emit(RoomEvent.Connected);
              this.setAndEmitConnectionState(ConnectionState.Connected);
              if (!publishOptions.video) {
                _context22.n = 4;
                break;
              }
              _t16 = LocalTrackPublication;
              _t17 = Track.Kind.Video;
              _t18 = new TrackInfo({
                source: TrackSource.CAMERA,
                sid: Math.floor(Math.random() * 1e4).toString(),
                type: TrackType.AUDIO,
                name: "video-dummy"
              });
              _t19 = LocalVideoTrack;
              if (!publishOptions.useRealTracks) {
                _context22.n = 2;
                break;
              }
              _context22.n = 1;
              return window.navigator.mediaDevices.getUserMedia({
                video: true
              });
            case 1:
              _t20 = _context22.v.getVideoTracks()[0];
              _context22.n = 3;
              break;
            case 2:
              _t20 = createDummyVideoStreamTrack(160 * ((_a = participantOptions.aspectRatios[0]) !== null && _a !== void 0 ? _a : 1), 160, true, true);
            case 3:
              _t21 = _t20;
              _t22 = void 0;
              _t23 = {
                loggerName: this.options.loggerName,
                loggerContextCb: function loggerContextCb() {
                  return _this17.logContext;
                }
              };
              _t24 = new _t19(_t21, _t22, false, _t23);
              _t25 = {
                loggerName: this.options.loggerName,
                loggerContextCb: function loggerContextCb() {
                  return _this17.logContext;
                }
              };
              camPub = new _t16(_t17, _t18, _t24, _t25);
              this.localParticipant.addTrackPublication(camPub);
              this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, camPub);
            case 4:
              if (!publishOptions.audio) {
                _context22.n = 8;
                break;
              }
              _t26 = LocalTrackPublication;
              _t27 = Track.Kind.Audio;
              _t28 = new TrackInfo({
                source: TrackSource.MICROPHONE,
                sid: Math.floor(Math.random() * 1e4).toString(),
                type: TrackType.AUDIO
              });
              _t29 = LocalAudioTrack;
              if (!publishOptions.useRealTracks) {
                _context22.n = 6;
                break;
              }
              _context22.n = 5;
              return navigator.mediaDevices.getUserMedia({
                audio: true
              });
            case 5:
              _t30 = _context22.v.getAudioTracks()[0];
              _context22.n = 7;
              break;
            case 6:
              _t30 = getEmptyAudioStreamTrack();
            case 7:
              _t31 = _t30;
              _t32 = void 0;
              _t33 = this.audioContext;
              _t34 = {
                loggerName: this.options.loggerName,
                loggerContextCb: function loggerContextCb() {
                  return _this17.logContext;
                }
              };
              _t35 = new _t29(_t31, _t32, false, _t33, _t34);
              _t36 = {
                loggerName: this.options.loggerName,
                loggerContextCb: function loggerContextCb() {
                  return _this17.logContext;
                }
              };
              audioPub = new _t26(_t27, _t28, _t35, _t36);
              this.localParticipant.addTrackPublication(audioPub);
              this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, audioPub);
            case 8:
              for (i = 0; i < participantOptions.count - 1; i += 1) {
                info = new ParticipantInfo({
                  sid: Math.floor(Math.random() * 1e4).toString(),
                  identity: "simulated-".concat(i),
                  state: ParticipantInfo_State.ACTIVE,
                  tracks: [],
                  joinedAt: protoInt64.parse(Date.now())
                });
                p = this.getOrCreateParticipant(info.identity, info);
                if (participantOptions.video) {
                  dummyVideo = createDummyVideoStreamTrack(160 * ((_b = participantOptions.aspectRatios[i % participantOptions.aspectRatios.length]) !== null && _b !== void 0 ? _b : 1), 160, false, true);
                  videoTrack = new TrackInfo({
                    source: TrackSource.CAMERA,
                    sid: Math.floor(Math.random() * 1e4).toString(),
                    type: TrackType.AUDIO
                  });
                  p.addSubscribedMediaTrack(dummyVideo, videoTrack.sid, new MediaStream([dummyVideo]), new RTCRtpReceiver());
                  info.tracks = [].concat(_toConsumableArray(info.tracks), [videoTrack]);
                }
                if (participantOptions.audio) {
                  dummyTrack = getEmptyAudioStreamTrack();
                  audioTrack = new TrackInfo({
                    source: TrackSource.MICROPHONE,
                    sid: Math.floor(Math.random() * 1e4).toString(),
                    type: TrackType.AUDIO
                  });
                  p.addSubscribedMediaTrack(dummyTrack, audioTrack.sid, new MediaStream([dummyTrack]), new RTCRtpReceiver());
                  info.tracks = [].concat(_toConsumableArray(info.tracks), [audioTrack]);
                }
                p.updateInfo(info);
              }
            case 9:
              return _context22.a(2);
          }
        }, _callee20, this);
      }));
    }
    // /** @internal */
  }, {
    key: "emit",
    value: function emit2(event) {
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }
      if (event !== RoomEvent.ActiveSpeakersChanged) {
        var minimizedArgs = mapArgs(args).filter(function(arg) {
          return arg !== void 0;
        });
        this.log.debug("room event ".concat(event), Object.assign(Object.assign({}, this.logContext), {
          event,
          args: minimizedArgs
        }));
      }
      return _superPropGet(Room2, "emit", this, 3)([event].concat(args));
    }
  }], [{
    key: "getLocalDevices",
    value: function getLocalDevices(kind) {
      var requestPermissions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      return DeviceManager.getInstance().getDevices(kind, requestPermissions);
    }
  }]);
}(eventsExports.EventEmitter);
Room.cleanupRegistry = typeof FinalizationRegistry !== "undefined" && new FinalizationRegistry(function(cleanup) {
  cleanup();
});
function mapArgs(args) {
  return args.map(function(arg) {
    if (!arg) {
      return;
    }
    if (Array.isArray(arg)) {
      return mapArgs(arg);
    }
    if (_typeof(arg) === "object") {
      return "logContext" in arg && arg.logContext;
    }
    return arg;
  });
}
var CheckStatus;
(function(CheckStatus2) {
  CheckStatus2[CheckStatus2["IDLE"] = 0] = "IDLE";
  CheckStatus2[CheckStatus2["RUNNING"] = 1] = "RUNNING";
  CheckStatus2[CheckStatus2["SKIPPED"] = 2] = "SKIPPED";
  CheckStatus2[CheckStatus2["SUCCESS"] = 3] = "SUCCESS";
  CheckStatus2[CheckStatus2["FAILED"] = 4] = "FAILED";
})(CheckStatus || (CheckStatus = {}));
var Checker = function(_EventEmitter) {
  function Checker2(url, token) {
    var _this;
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    _classCallCheck(this, Checker2);
    _this = _callSuper(this, Checker2);
    _this.status = CheckStatus.IDLE;
    _this.logs = [];
    _this.errorsAsWarnings = false;
    _this.url = url;
    _this.token = token;
    _this.name = _this.constructor.name;
    _this.room = new Room(options.roomOptions);
    _this.connectOptions = options.connectOptions;
    if (options.errorsAsWarnings) {
      _this.errorsAsWarnings = options.errorsAsWarnings;
    }
    return _this;
  }
  _inherits(Checker2, _EventEmitter);
  return _createClass(Checker2, [{
    key: "run",
    value: function run(onComplete) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee() {
        var _t;
        return _regenerator().w(function(_context) {
          while (1) switch (_context.n) {
            case 0:
              if (!(this.status !== CheckStatus.IDLE)) {
                _context.n = 1;
                break;
              }
              throw Error("check is running already");
            case 1:
              this.setStatus(CheckStatus.RUNNING);
              _context.p = 2;
              _context.n = 3;
              return this.perform();
            case 3:
              _context.n = 5;
              break;
            case 4:
              _context.p = 4;
              _t = _context.v;
              if (_t instanceof Error) {
                if (this.errorsAsWarnings) {
                  this.appendWarning(_t.message);
                } else {
                  this.appendError(_t.message);
                }
              }
            case 5:
              _context.n = 6;
              return this.disconnect();
            case 6:
              _context.n = 7;
              return new Promise(function(resolve) {
                return setTimeout(resolve, 500);
              });
            case 7:
              if (this.status !== CheckStatus.SKIPPED) {
                this.setStatus(this.isSuccess() ? CheckStatus.SUCCESS : CheckStatus.FAILED);
              }
              if (onComplete) {
                onComplete();
              }
              return _context.a(2, this.getInfo());
          }
        }, _callee, this, [[2, 4]]);
      }));
    }
  }, {
    key: "isSuccess",
    value: function isSuccess() {
      return !this.logs.some(function(l) {
        return l.level === "error";
      });
    }
  }, {
    key: "connect",
    value: function connect() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee2() {
        return _regenerator().w(function(_context2) {
          while (1) switch (_context2.n) {
            case 0:
              if (!(this.room.state === ConnectionState.Connected)) {
                _context2.n = 1;
                break;
              }
              return _context2.a(2, this.room);
            case 1:
              _context2.n = 2;
              return this.room.connect(this.url, this.token, this.connectOptions);
            case 2:
              return _context2.a(2, this.room);
          }
        }, _callee2, this);
      }));
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee3() {
        return _regenerator().w(function(_context3) {
          while (1) switch (_context3.n) {
            case 0:
              if (!(this.room && this.room.state !== ConnectionState.Disconnected)) {
                _context3.n = 2;
                break;
              }
              _context3.n = 1;
              return this.room.disconnect();
            case 1:
              _context3.n = 2;
              return new Promise(function(resolve) {
                return setTimeout(resolve, 500);
              });
            case 2:
              return _context3.a(2);
          }
        }, _callee3, this);
      }));
    }
  }, {
    key: "skip",
    value: function skip() {
      this.setStatus(CheckStatus.SKIPPED);
    }
  }, {
    key: "appendMessage",
    value: function appendMessage(message) {
      this.logs.push({
        level: "info",
        message
      });
      this.emit("update", this.getInfo());
    }
  }, {
    key: "appendWarning",
    value: function appendWarning(message) {
      this.logs.push({
        level: "warning",
        message
      });
      this.emit("update", this.getInfo());
    }
  }, {
    key: "appendError",
    value: function appendError(message) {
      this.logs.push({
        level: "error",
        message
      });
      this.emit("update", this.getInfo());
    }
  }, {
    key: "setStatus",
    value: function setStatus(status) {
      this.status = status;
      this.emit("update", this.getInfo());
    }
  }, {
    key: "engine",
    get: function get2() {
      var _a;
      return (_a = this.room) === null || _a === void 0 ? void 0 : _a.engine;
    }
  }, {
    key: "getInfo",
    value: function getInfo() {
      return {
        logs: this.logs,
        name: this.name,
        status: this.status,
        description: this.description
      };
    }
  }]);
}(eventsExports.EventEmitter);
function createLocalTracks(options) {
  return __awaiter(this, void 0, void 0, _regenerator().m(function _callee2() {
    var _this = this;
    var _a, _b, _extractProcessorsFro, audioProcessor, videoProcessor, opts, constraints, mediaPromise, stream;
    return _regenerator().w(function(_context2) {
      while (1) switch (_context2.n) {
        case 0:
          options !== null && options !== void 0 ? options : options = {};
          (_a = options.audio) !== null && _a !== void 0 ? _a : options.audio = {
            deviceId: "default"
          };
          (_b = options.video) !== null && _b !== void 0 ? _b : options.video = {
            deviceId: "default"
          };
          _extractProcessorsFro = extractProcessorsFromOptions(options), audioProcessor = _extractProcessorsFro.audioProcessor, videoProcessor = _extractProcessorsFro.videoProcessor;
          opts = mergeDefaultOptions(options, audioDefaults, videoDefaults);
          constraints = constraintsForOptions(opts);
          mediaPromise = navigator.mediaDevices.getUserMedia(constraints);
          if (options.audio) {
            DeviceManager.userMediaPromiseMap.set("audioinput", mediaPromise);
            mediaPromise["catch"](function() {
              return DeviceManager.userMediaPromiseMap["delete"]("audioinput");
            });
          }
          if (options.video) {
            DeviceManager.userMediaPromiseMap.set("videoinput", mediaPromise);
            mediaPromise["catch"](function() {
              return DeviceManager.userMediaPromiseMap["delete"]("videoinput");
            });
          }
          _context2.n = 1;
          return mediaPromise;
        case 1:
          stream = _context2.v;
          return _context2.a(2, Promise.all(stream.getTracks().map(function(mediaStreamTrack) {
            return __awaiter(_this, void 0, void 0, _regenerator().m(function _callee() {
              var isAudio, trackConstraints, conOrBool, track;
              return _regenerator().w(function(_context) {
                while (1) switch (_context.n) {
                  case 0:
                    isAudio = mediaStreamTrack.kind === "audio";
                    isAudio ? opts.audio : opts.video;
                    conOrBool = isAudio ? constraints.audio : constraints.video;
                    if (typeof conOrBool !== "boolean") {
                      trackConstraints = conOrBool;
                    }
                    if (trackConstraints) {
                      trackConstraints.deviceId = mediaStreamTrack.getSettings().deviceId;
                    } else {
                      trackConstraints = {
                        deviceId: mediaStreamTrack.getSettings().deviceId
                      };
                    }
                    track = mediaTrackToLocalTrack(mediaStreamTrack, trackConstraints);
                    if (track.kind === Track.Kind.Video) {
                      track.source = Track.Source.Camera;
                    } else if (track.kind === Track.Kind.Audio) {
                      track.source = Track.Source.Microphone;
                    }
                    track.mediaStream = stream;
                    if (!(track instanceof LocalAudioTrack && audioProcessor)) {
                      _context.n = 2;
                      break;
                    }
                    _context.n = 1;
                    return track.setProcessor(audioProcessor);
                  case 1:
                    _context.n = 3;
                    break;
                  case 2:
                    if (!(track instanceof LocalVideoTrack && videoProcessor)) {
                      _context.n = 3;
                      break;
                    }
                    _context.n = 3;
                    return track.setProcessor(videoProcessor);
                  case 3:
                    return _context.a(2, track);
                }
              }, _callee);
            }));
          })));
      }
    }, _callee2);
  }));
}
function createLocalVideoTrack(options) {
  return __awaiter(this, void 0, void 0, _regenerator().m(function _callee3() {
    var tracks;
    return _regenerator().w(function(_context3) {
      while (1) switch (_context3.n) {
        case 0:
          _context3.n = 1;
          return createLocalTracks({
            audio: false,
            video: options
          });
        case 1:
          tracks = _context3.v;
          return _context3.a(2, tracks[0]);
      }
    }, _callee3);
  }));
}
function createLocalAudioTrack(options) {
  return __awaiter(this, void 0, void 0, _regenerator().m(function _callee4() {
    var tracks;
    return _regenerator().w(function(_context4) {
      while (1) switch (_context4.n) {
        case 0:
          _context4.n = 1;
          return createLocalTracks({
            audio: options,
            video: false
          });
        case 1:
          tracks = _context4.v;
          return _context4.a(2, tracks[0]);
      }
    }, _callee4);
  }));
}
function createLocalScreenTracks(options) {
  return __awaiter(this, void 0, void 0, _regenerator().m(function _callee5() {
    var constraints, stream, tracks, screenVideo, localTracks, screenAudio;
    return _regenerator().w(function(_context5) {
      while (1) switch (_context5.n) {
        case 0:
          if (options === void 0) {
            options = {};
          }
          if (options.resolution === void 0 && !isSafari17()) {
            options.resolution = ScreenSharePresets.h1080fps30.resolution;
          }
          if (!(navigator.mediaDevices.getDisplayMedia === void 0)) {
            _context5.n = 1;
            break;
          }
          throw new DeviceUnsupportedError("getDisplayMedia not supported");
        case 1:
          constraints = screenCaptureToDisplayMediaStreamOptions(options);
          _context5.n = 2;
          return navigator.mediaDevices.getDisplayMedia(constraints);
        case 2:
          stream = _context5.v;
          tracks = stream.getVideoTracks();
          if (!(tracks.length === 0)) {
            _context5.n = 3;
            break;
          }
          throw new TrackInvalidError("no video track found");
        case 3:
          screenVideo = new LocalVideoTrack(tracks[0], void 0, false);
          screenVideo.source = Track.Source.ScreenShare;
          localTracks = [screenVideo];
          if (stream.getAudioTracks().length > 0) {
            screenAudio = new LocalAudioTrack(stream.getAudioTracks()[0], void 0, false);
            screenAudio.source = Track.Source.ScreenShareAudio;
            localTracks.push(screenAudio);
          }
          return _context5.a(2, localTracks);
      }
    }, _callee5);
  }));
}
var PublishAudioCheck = function(_Checker) {
  function PublishAudioCheck2() {
    _classCallCheck(this, PublishAudioCheck2);
    return _callSuper(this, PublishAudioCheck2, arguments);
  }
  _inherits(PublishAudioCheck2, _Checker);
  return _createClass(PublishAudioCheck2, [{
    key: "description",
    get: function get2() {
      return "Can publish audio";
    }
  }, {
    key: "perform",
    value: function perform() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee() {
        var _a, room, track, stats, numPackets;
        return _regenerator().w(function(_context) {
          while (1) switch (_context.n) {
            case 0:
              _context.n = 1;
              return this.connect();
            case 1:
              room = _context.v;
              _context.n = 2;
              return createLocalAudioTrack();
            case 2:
              track = _context.v;
              room.localParticipant.publishTrack(track);
              _context.n = 3;
              return new Promise(function(resolve) {
                return setTimeout(resolve, 3e3);
              });
            case 3:
              _context.n = 4;
              return (_a = track.sender) === null || _a === void 0 ? void 0 : _a.getStats();
            case 4:
              stats = _context.v;
              if (stats) {
                _context.n = 5;
                break;
              }
              throw new Error("Could not get RTCStats");
            case 5:
              numPackets = 0;
              stats.forEach(function(stat) {
                if (stat.type === "outbound-rtp" && (stat.kind === "audio" || !stat.kind && stat.mediaType === "audio")) ;
              });
              if (!(numPackets === 0)) {
                _context.n = 6;
                break;
              }
              throw new Error("Could not determine packets are sent");
            case 6:
              this.appendMessage("published ".concat(numPackets, " audio packets"));
            case 7:
              return _context.a(2);
          }
        }, _callee, this);
      }));
    }
  }]);
}(Checker);
var PublishVideoCheck = function(_Checker) {
  function PublishVideoCheck2() {
    _classCallCheck(this, PublishVideoCheck2);
    return _callSuper(this, PublishVideoCheck2, arguments);
  }
  _inherits(PublishVideoCheck2, _Checker);
  return _createClass(PublishVideoCheck2, [{
    key: "description",
    get: function get2() {
      return "Can publish video";
    }
  }, {
    key: "perform",
    value: function perform() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee() {
        var _a, room, track, stats, numPackets;
        return _regenerator().w(function(_context) {
          while (1) switch (_context.n) {
            case 0:
              _context.n = 1;
              return this.connect();
            case 1:
              room = _context.v;
              _context.n = 2;
              return createLocalVideoTrack();
            case 2:
              track = _context.v;
              room.localParticipant.publishTrack(track);
              _context.n = 3;
              return new Promise(function(resolve) {
                return setTimeout(resolve, 5e3);
              });
            case 3:
              _context.n = 4;
              return (_a = track.sender) === null || _a === void 0 ? void 0 : _a.getStats();
            case 4:
              stats = _context.v;
              if (stats) {
                _context.n = 5;
                break;
              }
              throw new Error("Could not get RTCStats");
            case 5:
              numPackets = 0;
              stats.forEach(function(stat) {
                if (stat.type === "outbound-rtp" && (stat.kind === "video" || !stat.kind && stat.mediaType === "video")) {
                  numPackets += stat.packetsSent;
                }
              });
              if (!(numPackets === 0)) {
                _context.n = 6;
                break;
              }
              throw new Error("Could not determine packets are sent");
            case 6:
              this.appendMessage("published ".concat(numPackets, " video packets"));
            case 7:
              return _context.a(2);
          }
        }, _callee, this);
      }));
    }
  }]);
}(Checker);
var ReconnectCheck = function(_Checker) {
  function ReconnectCheck2() {
    _classCallCheck(this, ReconnectCheck2);
    return _callSuper(this, ReconnectCheck2, arguments);
  }
  _inherits(ReconnectCheck2, _Checker);
  return _createClass(ReconnectCheck2, [{
    key: "description",
    get: function get2() {
      return "Resuming connection after interruption";
    }
  }, {
    key: "perform",
    value: function perform() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee() {
        var _a, room, reconnectingTriggered, reconnected, reconnectResolver, reconnectTimeout, handleReconnecting, onClose;
        return _regenerator().w(function(_context) {
          while (1) switch (_context.n) {
            case 0:
              _context.n = 1;
              return this.connect();
            case 1:
              room = _context.v;
              reconnectingTriggered = false;
              reconnected = false;
              reconnectTimeout = new Promise(function(resolve) {
                setTimeout(resolve, 5e3);
                reconnectResolver = resolve;
              });
              handleReconnecting = function handleReconnecting2() {
                reconnectingTriggered = true;
              };
              room.on(RoomEvent.SignalReconnecting, handleReconnecting).on(RoomEvent.Reconnecting, handleReconnecting).on(RoomEvent.Reconnected, function() {
                reconnected = true;
                reconnectResolver(true);
              });
              (_a = room.engine.client.ws) === null || _a === void 0 ? void 0 : _a.close();
              onClose = room.engine.client.onClose;
              if (onClose) {
                onClose("");
              }
              _context.n = 2;
              return reconnectTimeout;
            case 2:
              if (reconnectingTriggered) {
                _context.n = 3;
                break;
              }
              throw new Error("Did not attempt to reconnect");
            case 3:
              if (!(!reconnected || room.state !== ConnectionState.Connected)) {
                _context.n = 4;
                break;
              }
              this.appendWarning("reconnection is only possible in Redis-based configurations");
              throw new Error("Not able to reconnect");
            case 4:
              return _context.a(2);
          }
        }, _callee, this);
      }));
    }
  }]);
}(Checker);
var TURNCheck = function(_Checker) {
  function TURNCheck2() {
    _classCallCheck(this, TURNCheck2);
    return _callSuper(this, TURNCheck2, arguments);
  }
  _inherits(TURNCheck2, _Checker);
  return _createClass(TURNCheck2, [{
    key: "description",
    get: function get2() {
      return "Can connect via TURN";
    }
  }, {
    key: "perform",
    value: function perform() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee() {
        var _a, _b, signalClient, joinRes, hasTLS, hasTURN, hasSTUN, _iterator, _step, iceServer, _iterator2, _step2, url;
        return _regenerator().w(function(_context) {
          while (1) switch (_context.n) {
            case 0:
              signalClient = new SignalClient();
              _context.n = 1;
              return signalClient.join(this.url, this.token, {
                autoSubscribe: true,
                maxRetries: 0,
                e2eeEnabled: false,
                websocketTimeout: 15e3
              });
            case 1:
              joinRes = _context.v;
              hasTLS = false;
              hasTURN = false;
              hasSTUN = false;
              _iterator = _createForOfIteratorHelper(joinRes.iceServers);
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                  iceServer = _step.value;
                  _iterator2 = _createForOfIteratorHelper(iceServer.urls);
                  try {
                    for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                      url = _step2.value;
                      if (url.startsWith("turn:")) {
                        hasTURN = true;
                        hasSTUN = true;
                      } else if (url.startsWith("turns:")) {
                        hasTURN = true;
                        hasSTUN = true;
                        hasTLS = true;
                      }
                      if (url.startsWith("stun:")) {
                        hasSTUN = true;
                      }
                    }
                  } catch (err) {
                    _iterator2.e(err);
                  } finally {
                    _iterator2.f();
                  }
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
              if (!hasSTUN) {
                this.appendWarning("No STUN servers configured on server side.");
              } else if (hasTURN && !hasTLS) {
                this.appendWarning("TURN is configured server side, but TURN/TLS is unavailable.");
              }
              _context.n = 2;
              return signalClient.close();
            case 2:
              if (!(((_b = (_a = this.connectOptions) === null || _a === void 0 ? void 0 : _a.rtcConfig) === null || _b === void 0 ? void 0 : _b.iceServers) || hasTURN)) {
                _context.n = 4;
                break;
              }
              _context.n = 3;
              return this.room.connect(this.url, this.token, {
                rtcConfig: {
                  iceTransportPolicy: "relay"
                }
              });
            case 3:
              _context.n = 5;
              break;
            case 4:
              this.appendWarning("No TURN servers configured.");
              this.skip();
              _context.n = 5;
              return new Promise(function(resolve) {
                return setTimeout(resolve, 0);
              });
            case 5:
              return _context.a(2);
          }
        }, _callee, this);
      }));
    }
  }]);
}(Checker);
var WebRTCCheck = function(_Checker) {
  function WebRTCCheck2() {
    _classCallCheck(this, WebRTCCheck2);
    return _callSuper(this, WebRTCCheck2, arguments);
  }
  _inherits(WebRTCCheck2, _Checker);
  return _createClass(WebRTCCheck2, [{
    key: "description",
    get: function get2() {
      return "Establishing WebRTC connection";
    }
  }, {
    key: "perform",
    value: function perform() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee() {
        var _this = this;
        var hasTcp, hasIpv4Udp, _t;
        return _regenerator().w(function(_context) {
          while (1) switch (_context.n) {
            case 0:
              hasTcp = false;
              hasIpv4Udp = false;
              this.room.on(RoomEvent.SignalConnected, function() {
                var prevTrickle = _this.room.engine.client.onTrickle;
                _this.room.engine.client.onTrickle = function(sd, target) {
                  if (sd.candidate) {
                    var candidate = new RTCIceCandidate(sd);
                    var str = "".concat(candidate.protocol, " ").concat(candidate.address, ":").concat(candidate.port, " ").concat(candidate.type);
                    if (candidate.address) {
                      if (isIPPrivate(candidate.address)) {
                        str += " (private)";
                      } else {
                        if (candidate.protocol === "tcp" && candidate.tcpType === "passive") {
                          hasTcp = true;
                          str += " (passive)";
                        } else if (candidate.protocol === "udp") {
                          hasIpv4Udp = true;
                        }
                      }
                    }
                    _this.appendMessage(str);
                  }
                  if (prevTrickle) {
                    prevTrickle(sd, target);
                  }
                };
                if (_this.room.engine.pcManager) {
                  _this.room.engine.pcManager.subscriber.onIceCandidateError = function(ev) {
                    if (ev instanceof RTCPeerConnectionIceErrorEvent) {
                      _this.appendWarning("error with ICE candidate: ".concat(ev.errorCode, " ").concat(ev.errorText, " ").concat(ev.url));
                    }
                  };
                }
              });
              _context.p = 1;
              _context.n = 2;
              return this.connect();
            case 2:
              livekitLogger.info("now the room is connected");
              _context.n = 4;
              break;
            case 3:
              _context.p = 3;
              _t = _context.v;
              this.appendWarning("ports need to be open on firewall in order to connect.");
              throw _t;
            case 4:
              if (!hasTcp) {
                this.appendWarning("Server is not configured for ICE/TCP");
              }
              if (!hasIpv4Udp) {
                this.appendWarning("No public IPv4 UDP candidates were found. Your server is likely not configured correctly");
              }
            case 5:
              return _context.a(2);
          }
        }, _callee, this, [[1, 3]]);
      }));
    }
  }]);
}(Checker);
function isIPPrivate(address) {
  var parts = address.split(".");
  if (parts.length === 4) {
    if (parts[0] === "10") {
      return true;
    } else if (parts[0] === "192" && parts[1] === "168") {
      return true;
    } else if (parts[0] === "172") {
      var second = parseInt(parts[1], 10);
      if (second >= 16 && second <= 31) {
        return true;
      }
    }
  }
  return false;
}
var WebSocketCheck = function(_Checker) {
  function WebSocketCheck2() {
    _classCallCheck(this, WebSocketCheck2);
    return _callSuper(this, WebSocketCheck2, arguments);
  }
  _inherits(WebSocketCheck2, _Checker);
  return _createClass(WebSocketCheck2, [{
    key: "description",
    get: function get2() {
      return "Connecting to signal connection via WebSocket";
    }
  }, {
    key: "perform",
    value: function perform() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee() {
        var _a, _b, _c, signalClient, joinRes;
        return _regenerator().w(function(_context) {
          while (1) switch (_context.n) {
            case 0:
              if (this.url.startsWith("ws:") || this.url.startsWith("http:")) {
                this.appendWarning("Server is insecure, clients may block connections to it");
              }
              signalClient = new SignalClient();
              _context.n = 1;
              return signalClient.join(this.url, this.token, {
                autoSubscribe: true,
                maxRetries: 0,
                e2eeEnabled: false,
                websocketTimeout: 15e3
              });
            case 1:
              joinRes = _context.v;
              this.appendMessage("Connected to server, version ".concat(joinRes.serverVersion, "."));
              if (((_a = joinRes.serverInfo) === null || _a === void 0 ? void 0 : _a.edition) === ServerInfo_Edition.Cloud && ((_b = joinRes.serverInfo) === null || _b === void 0 ? void 0 : _b.region)) {
                this.appendMessage("LiveKit Cloud: ".concat((_c = joinRes.serverInfo) === null || _c === void 0 ? void 0 : _c.region));
              }
              _context.n = 2;
              return signalClient.close();
            case 2:
              return _context.a(2);
          }
        }, _callee, this);
      }));
    }
  }]);
}(Checker);
var ConnectionCheck = function(_EventEmitter) {
  function ConnectionCheck2(url, token) {
    var _this;
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    _classCallCheck(this, ConnectionCheck2);
    _this = _callSuper(this, ConnectionCheck2);
    _this.options = {};
    _this.checkResults = /* @__PURE__ */ new Map();
    _this.url = url;
    _this.token = token;
    _this.options = options;
    return _this;
  }
  _inherits(ConnectionCheck2, _EventEmitter);
  return _createClass(ConnectionCheck2, [{
    key: "getNextCheckId",
    value: function getNextCheckId() {
      var nextId = this.checkResults.size;
      this.checkResults.set(nextId, {
        logs: [],
        status: CheckStatus.IDLE,
        name: "",
        description: ""
      });
      return nextId;
    }
  }, {
    key: "updateCheck",
    value: function updateCheck(checkId, info) {
      this.checkResults.set(checkId, info);
      this.emit("checkUpdate", checkId, info);
    }
  }, {
    key: "isSuccess",
    value: function isSuccess() {
      return Array.from(this.checkResults.values()).every(function(r2) {
        return r2.status !== CheckStatus.FAILED;
      });
    }
  }, {
    key: "getResults",
    value: function getResults() {
      return Array.from(this.checkResults.values());
    }
  }, {
    key: "createAndRunCheck",
    value: function createAndRunCheck(check) {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee() {
        var _this2 = this;
        var checkId, test, handleUpdate, result;
        return _regenerator().w(function(_context) {
          while (1) switch (_context.n) {
            case 0:
              checkId = this.getNextCheckId();
              test = new check(this.url, this.token, this.options);
              handleUpdate = function handleUpdate2(info) {
                _this2.updateCheck(checkId, info);
              };
              test.on("update", handleUpdate);
              _context.n = 1;
              return test.run();
            case 1:
              result = _context.v;
              test.off("update", handleUpdate);
              return _context.a(2, result);
          }
        }, _callee, this);
      }));
    }
  }, {
    key: "checkWebsocket",
    value: function checkWebsocket() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee2() {
        return _regenerator().w(function(_context2) {
          while (1) switch (_context2.n) {
            case 0:
              return _context2.a(2, this.createAndRunCheck(WebSocketCheck));
          }
        }, _callee2, this);
      }));
    }
  }, {
    key: "checkWebRTC",
    value: function checkWebRTC() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee3() {
        return _regenerator().w(function(_context3) {
          while (1) switch (_context3.n) {
            case 0:
              return _context3.a(2, this.createAndRunCheck(WebRTCCheck));
          }
        }, _callee3, this);
      }));
    }
  }, {
    key: "checkTURN",
    value: function checkTURN() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee4() {
        return _regenerator().w(function(_context4) {
          while (1) switch (_context4.n) {
            case 0:
              return _context4.a(2, this.createAndRunCheck(TURNCheck));
          }
        }, _callee4, this);
      }));
    }
  }, {
    key: "checkReconnect",
    value: function checkReconnect() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee5() {
        return _regenerator().w(function(_context5) {
          while (1) switch (_context5.n) {
            case 0:
              return _context5.a(2, this.createAndRunCheck(ReconnectCheck));
          }
        }, _callee5, this);
      }));
    }
  }, {
    key: "checkPublishAudio",
    value: function checkPublishAudio() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee6() {
        return _regenerator().w(function(_context6) {
          while (1) switch (_context6.n) {
            case 0:
              return _context6.a(2, this.createAndRunCheck(PublishAudioCheck));
          }
        }, _callee6, this);
      }));
    }
  }, {
    key: "checkPublishVideo",
    value: function checkPublishVideo() {
      return __awaiter(this, void 0, void 0, _regenerator().m(function _callee7() {
        return _regenerator().w(function(_context7) {
          while (1) switch (_context7.n) {
            case 0:
              return _context7.a(2, this.createAndRunCheck(PublishVideoCheck));
          }
        }, _callee7, this);
      }));
    }
  }]);
}(eventsExports.EventEmitter);
function facingModeFromLocalTrack(localTrack) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var _a;
  var track = localTrack instanceof LocalTrack ? localTrack.mediaStreamTrack : localTrack;
  var trackSettings = track.getSettings();
  var result = {
    facingMode: (_a = options.defaultFacingMode) !== null && _a !== void 0 ? _a : "user",
    confidence: "low"
  };
  if ("facingMode" in trackSettings) {
    var rawFacingMode = trackSettings.facingMode;
    livekitLogger.trace("rawFacingMode", {
      rawFacingMode
    });
    if (rawFacingMode && typeof rawFacingMode === "string" && isFacingModeValue(rawFacingMode)) {
      result = {
        facingMode: rawFacingMode,
        confidence: "high"
      };
    }
  }
  if (["low", "medium"].includes(result.confidence)) {
    livekitLogger.trace("Try to get facing mode from device label: (".concat(track.label, ")"));
    var labelAnalysisResult = facingModeFromDeviceLabel(track.label);
    if (labelAnalysisResult !== void 0) {
      result = labelAnalysisResult;
    }
  }
  return result;
}
var knownDeviceLabels = /* @__PURE__ */ new Map([["obs virtual camera", {
  facingMode: "environment",
  confidence: "medium"
}]]);
var knownDeviceLabelSections = /* @__PURE__ */ new Map([["iphone", {
  facingMode: "environment",
  confidence: "medium"
}], ["ipad", {
  facingMode: "environment",
  confidence: "medium"
}]]);
function facingModeFromDeviceLabel(deviceLabel) {
  var _a;
  var label = deviceLabel.trim().toLowerCase();
  if (label === "") {
    return void 0;
  }
  if (knownDeviceLabels.has(label)) {
    return knownDeviceLabels.get(label);
  }
  return (_a = Array.from(knownDeviceLabelSections.entries()).find(function(_ref) {
    var _ref2 = _slicedToArray(_ref, 1), section = _ref2[0];
    return label.includes(section);
  })) === null || _a === void 0 ? void 0 : _a[1];
}
function isFacingModeValue(item) {
  var allowedValues = ["user", "environment", "left", "right"];
  return item === void 0 || allowedValues.includes(item);
}
export {
  AudioPresets,
  BaseKeyProvider,
  CheckStatus,
  Checker,
  ConnectionCheck,
  ConnectionError,
  ConnectionQuality,
  ConnectionState,
  CriticalTimers,
  CryptorError,
  CryptorErrorReason,
  CryptorEvent,
  DataPacket_Kind,
  DefaultReconnectPolicy,
  DeviceUnsupportedError,
  DisconnectReason,
  EncryptionEvent,
  EngineEvent,
  ExternalE2EEKeyProvider,
  KeyHandlerEvent,
  KeyProviderEvent,
  LivekitError,
  LocalAudioTrack,
  LocalParticipant,
  LocalTrack,
  LocalTrackPublication,
  LocalVideoTrack,
  LogLevel,
  LoggerNames,
  MediaDeviceFailure,
  Mutex,
  NegotiationError,
  Participant,
  ParticipantEvent,
  ParticipantInfo_Kind as ParticipantKind,
  PublishDataError,
  RemoteAudioTrack,
  RemoteParticipant,
  RemoteTrack,
  RemoteTrackPublication,
  RemoteVideoTrack,
  Room,
  RoomEvent,
  RpcError,
  ScreenSharePresets,
  SignalRequestError,
  SubscriptionError,
  Track,
  TrackEvent,
  TrackInvalidError,
  TrackPublication,
  UnexpectedConnectionState,
  UnsupportedServer,
  VideoPreset,
  VideoPresets,
  VideoPresets43,
  VideoQuality,
  attachToElement,
  compareVersions,
  createAudioAnalyser,
  createE2EEKey,
  createKeyMaterialFromBuffer,
  createKeyMaterialFromString,
  createLocalAudioTrack,
  createLocalScreenTracks,
  createLocalTracks,
  createLocalVideoTrack,
  deriveKeys,
  detachTrack,
  facingModeFromDeviceLabel,
  facingModeFromLocalTrack,
  getBrowser,
  getEmptyAudioStreamTrack,
  getEmptyVideoStreamTrack,
  getLogger,
  importKey,
  isBackupCodec,
  isBrowserSupported,
  isE2EESupported,
  isInsertableStreamSupported,
  isScriptTransformSupported,
  isVideoFrame,
  needsRbspUnescaping,
  parseRbsp,
  protocolVersion,
  ratchet,
  setLogExtension,
  setLogLevel,
  supportsAV1,
  supportsAdaptiveStream,
  supportsDynacast,
  supportsVP9,
  version,
  videoCodecs,
  writeRbsp
};
/*! Bundled license information:

ecprt-client-sdk/dist/ecprt-client-sdk.esm.mjs:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE *)
*/
//# sourceMappingURL=ecprt-client-sdk.js.map
