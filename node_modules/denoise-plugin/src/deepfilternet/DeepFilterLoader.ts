import { gzipSync } from 'fflate';

// Get package name from build-time injection
const PACKAGE_NAME = process.env.PACKAGE_NAME || 'denoise-plugin';

/**
 * Main thread WASM loader for DeepFilter
 * Handles loading WASM files and model data before AudioWorklet creation
 */
export class DeepFilterLoader {
    private static wasmJsCode?: string;
    private static wasmBinary?: Uint8Array;
    private static modelData?: Uint8Array;
    private static isLoading = false;
    private static isLoaded = false;
    private static basePath?: string;

    /**
     * Set the base path for loading WASM files.
     * Default: './node_modules/${PACKAGE_NAME}/dist/'
     * For custom hosting: '/path/to/your/wasm/files/'
     */
    static setBasePath(path: string): void {
        this.basePath = path.endsWith('/') ? path : path + '/';
        // Reset loaded state when path changes
        if (this.isLoaded) {
            this.reset();
        }
    }

    /**
     * Get the current base path being used for loading WASM files
     */
    static getBasePath(): string {
        // If manually set, use that
        if (this.basePath) {
            return this.basePath;
        }

        // Default to npm package path
        return `./node_modules/${PACKAGE_NAME}/dist/`;
    }

    /**
     * Load DeepFilter WASM files and model data in the main thread
     */
    static async loadWasmData(): Promise<void> {
        if (this.isLoaded) {
            return;
        }

        if (this.isLoading) {
            // Wait for ongoing loading to complete
            while (this.isLoading) {
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            return;
        }

        this.isLoading = true;
        
        try {
            const basePath = this.getBasePath();

            // Load WASM JavaScript file
            const jsResponse = await fetch(`${basePath}df.js`);
            if (!jsResponse.ok) {
                throw new Error(`Failed to fetch WASM JS file: ${jsResponse.status} from ${basePath}df.js`);
            }
            this.wasmJsCode = await jsResponse.text();

            // Load WASM binary
            const wasmResponse = await fetch(`${basePath}df_bg.wasm`);
            if (!wasmResponse.ok) {
                throw new Error(`Failed to fetch WASM binary: ${wasmResponse.status} from ${basePath}df_bg.wasm`);
            }
            this.wasmBinary = await wasmResponse.arrayBuffer().then(buffer => new Uint8Array(buffer));

            // Load model data with headers to prevent auto-decompression
            const modelResponse = await fetch(`${basePath}DeepFilterNet3_onnx.tar.gz`, {
                headers: {
                    'Accept-Encoding': 'identity' // Request no compression to get raw file
                }
            });
            if (!modelResponse.ok) {
                throw new Error(`Failed to fetch model data: ${modelResponse.status} from ${basePath}DeepFilterNet3_onnx.tar.gz`);
            }
            this.modelData = await modelResponse.arrayBuffer().then(buffer => new Uint8Array(buffer));
            
            // Check if we got gzipped data
            const gzipMagic = [0x1f, 0x8b];
            const isGzipped = this.modelData.length >= 2 && this.modelData[0] === gzipMagic[0] && this.modelData[1] === gzipMagic[1];
            
            // If the file was auto-decompressed by the server, re-compress it
              if (!isGzipped) {
                try {
                    this.modelData = gzipSync(this.modelData);
                } catch (gzipError) {
                    throw new Error(`Failed to re-compress model data: ${gzipError}`);
                }
            }            

            this.isLoaded = true;

        } catch (error) {
            this.isLoaded = false;
            throw error;
        } finally {
            this.isLoading = false;
        }
    }

    /**
     * Get the loaded WASM data for passing to AudioWorklet
     */
    static getWasmData(): {
        wasmJsCode: string;
        wasmBinary: Uint8Array;
        modelData: Uint8Array;
    } | null {
        if (!this.isLoaded || !this.wasmJsCode || !this.wasmBinary || !this.modelData) {
            return null;
        }

        return {
            wasmJsCode: this.wasmJsCode,
            wasmBinary: this.wasmBinary,
            modelData: this.modelData
        };
    }    

    /**
     * Reset the loader state (for testing or re-initialization)
     */
    static reset(): void {
        this.wasmJsCode = undefined;
        this.wasmBinary = undefined;
        this.modelData = undefined;
        this.isLoading = false;
        this.isLoaded = false;
        // Note: we don't reset basePath as it might be manually set
    }
}
